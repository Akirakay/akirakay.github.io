<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring-依赖注入的方式</title>
      <link href="/2025/06/76dd52308ab3.html"/>
      <url>/2025/06/76dd52308ab3.html</url>
      
        <content type="html"><![CDATA[<h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// Setter 注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>不可以注入final修饰的对象</li><li>注入对象可以被set方法修改</li></ul><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// constructor() 注入</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>可以注入final修饰的对象</li><li>注入对象不会被修改</li><li>注入对象完全初始化</li><li>更加通用</li></ul><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：</p><ul><li>无法注入final修饰的对象</li><li>只适用于IoC容器</li></ul><h2 id="推荐构造器注入的理由"><a href="#推荐构造器注入的理由" class="headerlink" title="推荐构造器注入的理由"></a>推荐构造器注入的理由</h2><ol><li>注入对象不可变：final修饰</li><li>注入对象不为空：实例化对象会走我们自己实现的有参构造，如果依赖对象为空会报错</li><li>注入对象完全初始化</li><li>提前暴露循环依赖问题：注解注入只会在使用时暴露出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL窗口函数</title>
      <link href="/2025/05/0d76087c8b31.html"/>
      <url>/2025/05/0d76087c8b31.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-窗口函数概念和语法"><a href="#1-窗口函数概念和语法" class="headerlink" title="1. 窗口函数概念和语法"></a><strong>1. 窗口函数概念和语法</strong></h3><p>窗口函数对一组查询行执行类似聚合的操作。然而，聚合操作将查询行分组到单个结果行，而窗口函数为每个查询行产生一个结果:</p><ul><li>函数求值发生的行称为当前行</li><li>与发生函数求值的当前行相关的查询行组成了当前行的窗口</li></ul><p>相比之下，窗口操作不会将一组查询行折叠到单个输出行。相反，它们为每一行生成一个结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    manufacturer, product, profit,</span><br><span class="line">    <span class="built_in">SUM</span>(profit) <span class="keyword">OVER</span>() <span class="keyword">AS</span> total_profit,</span><br><span class="line">    <span class="built_in">SUM</span>(profit) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manufacturer) <span class="keyword">AS</span> manufacturer_profit</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/27/Tn8skE7ogyAUOcm.png" alt="concept"></p><p>查询中的每个窗口操作都通过包含一个 OVER 子句来表示，该子句指定如何将查询行划分为组以供窗口函数处理：</p><ul><li>第一个 <strong>OVER</strong> 子句是空的，它将整个查询行集视为一个分区。窗口函数因此产生一个全局和，但对每一行都这样做。</li><li>第二个 <strong>OVER</strong> 子句按 manufacturer 划分行，产生每个分区（每个manufacturer）的总和。该函数为每个分区行生成此总和。</li></ul><p>窗口函数只允许在查询列表和 <strong>ORDER BY</strong> 子句中使用。</p><p>查询结果行由 <strong>FROM</strong> 子句确定，在 <strong>WHERE</strong>、<strong>GROUP BY</strong> 和 <strong>HAVING</strong> 处理之后，窗口执行发生在 <strong>ORDER BY</strong>、<strong>LIMIT</strong> 和 <strong>SELECT DISTINCT</strong> 之前。</p><p><strong>OVER</strong>子句被允许用于许多聚合函数，因此，这些聚合函数可以用作窗口函数或非窗口函数，具体取决于是否存在 <strong>OVER</strong> 子句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVG</span>()</span><br><span class="line">BIT_AND()</span><br><span class="line">BIT_OR()</span><br><span class="line">BIT_XOR()</span><br><span class="line"><span class="built_in">COUNT</span>()</span><br><span class="line"><span class="built_in">JSON_ARRAYAGG</span>()</span><br><span class="line"><span class="built_in">JSON_OBJECTAGG</span>()</span><br><span class="line"><span class="built_in">MAX</span>()</span><br><span class="line"><span class="built_in">MIN</span>()</span><br><span class="line"><span class="built_in">STDDEV_POP</span>(), STDDEV(), STD()</span><br><span class="line"><span class="built_in">STDDEV_SAMP</span>()</span><br><span class="line"><span class="built_in">SUM</span>()</span><br><span class="line"><span class="built_in">VAR_POP</span>(), VARIANCE()</span><br><span class="line"><span class="built_in">VAR_SAMP</span>()</span><br></pre></td></tr></table></figure><p>MySQL还支持只能作为窗口函数使用的非聚合函数。对于这些，OVER子句是必须的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CUME_DIST</span>()</span><br><span class="line"><span class="built_in">DENSE_RANK</span>()</span><br><span class="line"><span class="built_in">FIRST_VALUE</span>()</span><br><span class="line"><span class="built_in">LAG</span>()</span><br><span class="line"><span class="built_in">LAST_VALUE</span>()</span><br><span class="line"><span class="built_in">LEAD</span>()</span><br><span class="line"><span class="built_in">NTH_VALUE</span>()</span><br><span class="line"><span class="built_in">NTILE</span>()</span><br><span class="line"><span class="built_in">PERCENT_RANK</span>()</span><br><span class="line"><span class="built_in">RANK</span>()</span><br><span class="line"><span class="built_in">ROW_NUMBER</span>()</span><br></pre></td></tr></table></figure><p><strong>ROW_NUMBER()</strong> 它生成其分区内每一行的行号。默认情况下，分区行是无序的，行编号是不确定的。若要对分区行进行排序，请在窗口定义中包含一个ORDER BY子句。下面的示例中，查询使用无序分区和有序分区(row_num1和row_num2列)来说明省略和包含ORDER BY之间的区别:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    manufacturer, product, profit,</span><br><span class="line">    <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manufacturer) <span class="keyword">AS</span> row_num1,</span><br><span class="line">    <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> manufacturer ORDERBY profit) <span class="keyword">AS</span> row_num2</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/27/8tYQHohiumEg1zv.png" alt="row_number"></p><p>如前所述，要使用窗口函数（或将聚合函数视为窗口函数），需要在函数调用后包含OVER子句。OVER子句有两种形式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">over_clause:</span><br><span class="line">    &#123;<span class="keyword">OVER</span> (window_spec) <span class="operator">|</span><span class="keyword">OVER</span> window_name&#125;</span><br></pre></td></tr></table></figure><p>这两种形式都定义了窗口函数应该如何处理查询行。它们的区别在于窗口是直接在OVER子句中定义的，还是通过对查询中其他地方定义的命名窗口的引用提供的:</p><ul><li>在第一种情况下，窗口规范直接出现在 OVER 子句中的括号之间。</li><li>在第二种情况下，window_name 是由查询中其他地方的 WINDOW 子句定义的窗口规范的名称。</li></ul><p>对于 OVER (window_spec) 语法，窗口规范有几个部分，都是可选的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window_spec:</span><br><span class="line">    [window_name] [partition_clause] [order_clause] [frame_clause]</span><br></pre></td></tr></table></figure><p>如果 OVER() 为空，则窗口由所有查询行组成，窗口函数使用所有行计算结果。否则，括号中的子句决定了使用哪些查询行来计算函数结果，以及它们是如何分区和排序的：</p><ul><li><strong>window_name</strong>: 由查询中其他地方的window子句定义的窗口的名称。如果window_name单独出现在OVER子句中，则它完全定义了窗口。如果分区、排序或分帧子句也给出了，它们会修改被命名窗口的解释。</li><li><strong>partition_clause</strong>: PARTITION BY 子句指示如何将查询行分组。给定行的窗口函数结果基于包含该行的分区的行。如果省略 PARTITION BY，则有一个由所有查询行组成的分区。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">partition_clause:</span><br><span class="line">    PARTITIONBY expr [, expr] ...</span><br></pre></td></tr></table></figure><ul><li><strong>order_clause</strong>: ORDER BY 子句指示如何对每个分区中的行进行排序。根据 ORDER BY 子句相等的分区行被视为对等。如果省略 ORDER BY，则分区行是无序的，没有隐含的处理顺序，并且所有分区行都是对等的。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">order_clause:</span><br><span class="line">    ORDERBY expr [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>] [, expr [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]] ...</span><br></pre></td></tr></table></figure><p>每个ORDER BY表达式后面可以有选择地跟着ASC或DESC来表示排序方向。NULL 值首先进行升序排序，最后进行降序排序。</p><p>窗口定义中的 ORDER BY 适用于各个分区。要将结果集作为一个整体进行排序，请在查询顶层包含 ORDER BY。</p><ul><li><strong>frame_clause</strong>: frame是当前分区的子集，frame子句指定如何定义该子集。</li></ul><p><strong>小结：</strong></p><p>窗口，就是数据范围，也可以理解为记录集合，窗口函数就是在满足某种条件的记录集合上执行的特殊函数。即，应用在窗口内的函数。</p><ul><li>静态窗口：窗口大小是固定的，窗口内的每条记录都要执行此函数</li><li>动态窗口：也叫滑动窗口，窗口大小是变化的</li></ul><p>窗口函数有以下功能：</p><ul><li>同时具有分组和排序的功能</li><li>不减少原表的行数</li></ul><h3 id="2-窗口函数frame规范"><a href="#2-窗口函数frame规范" class="headerlink" title="2. 窗口函数frame规范"></a><strong>2. 窗口函数frame规范</strong></h3><p>一个frame是当前分区的一个子集，frame子句指定如何定义这个子集。</p><p>frame是根据当前行确定的，这使得frame可以根据当前行在分区中的位置在分区中移动。</p><ul><li>通过将一个frame定义为从分区开始到当前行的所有行，我们可以计算每一行的运行总数。</li><li>通过将一个frame定义为在当前行的每一边扩展N行，我们可以计算滚动平均。</li></ul><p>下面的查询演示了如何使用移动帧来计算每组按时间顺序排列的值的总和，以及从当前行和紧随其后的行计算的滚动平均值:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  manufacturer, `<span class="keyword">month</span>`, profit,</span><br><span class="line">  <span class="built_in">SUM</span>(profit) <span class="keyword">OVER</span>(</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> manufacturer</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> `<span class="keyword">month</span>`</span><br><span class="line">    <span class="keyword">ROWS</span> unbounded PRECEDING</span><br><span class="line">  ) <span class="keyword">AS</span> running_total,</span><br><span class="line">  <span class="built_in">AVG</span>(profit) <span class="keyword">OVER</span>(</span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> manufacturer</span><br><span class="line">    ORDERBY `<span class="keyword">month</span>`</span><br><span class="line">    <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING</span><br><span class="line">  ) <span class="keyword">AS</span> running_average</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  sales;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/05/27/NuQmH93yzahO56x.png" alt="frame"></p><p>frame 子句语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame_clause:</span><br><span class="line">    frame_units frame_extent</span><br><span class="line"></span><br><span class="line">frame_units:</span><br><span class="line">    &#123;<span class="keyword">ROWS</span><span class="operator">|</span><span class="keyword">RANGE</span>&#125;</span><br></pre></td></tr></table></figure><p>在没有frame子句的情况下，默认frame取决于是否存在ORDER BY子句。</p><p>frame_units值表示当前行和帧行之间的关系类型：</p><ul><li><code>ROWS</code>: frame由开始行和结束行位置定义。偏移量是行号与当前行号之间的差异。</li><li><code>RANGE</code>: frame由值范围内的行定义。偏移量是行值与当前行值之间的差异。</li></ul><p>frame_extend 表示frame的起始点和结束点。可以只指定frame的开始（在这种情况下，当前行隐式地是结束）或使用BETWEEN指定frame的两个端点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">frame_extent:</span><br><span class="line">    &#123;frame_start <span class="operator">|</span> frame_between&#125;</span><br><span class="line"></span><br><span class="line">frame_between:</span><br><span class="line">    <span class="keyword">BETWEEN</span> frame_start <span class="keyword">AND</span> frame_end</span><br><span class="line"></span><br><span class="line">frame_start, frame_end: &#123;</span><br><span class="line">    CURRENTROW<span class="operator">|</span> UNBOUNDED PRECEDING</span><br><span class="line">  <span class="operator">|</span> UNBOUNDED FOLLOWING</span><br><span class="line">  <span class="operator">|</span> expr PRECEDING</span><br><span class="line">  <span class="operator">|</span> expr FOLLOWING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用BETWEEN语法，frame_start不能发生在frame_end之后。</p><p>允许的frame_start和frame_end值含义如下：</p><ul><li><code>CURRENT ROW</code>: 对于ROWS，边界是当前行。对于RANGE，边界是当前行的对等点。</li><li><code>UNBOUNDED PRECEDING</code>: 边界是第一个分区行。</li><li><code>UNBOUNDED FOLLOWING</code>: 边界是最后一个分区行。</li><li><code>expr PRECEDING</code>: 对于ROWS，边界是当前行之前的 expr 行。对于RANGE，边界是值等于当前行值减去 expr 的行，如果当前行值为NULL，则绑定为该行的对等体。</li><li><code>expr FOLLOWING</code>: 对于ROWS，边界是当前行之后的 expr 行。对于RANGE，边界是值等于当前行值加上 expr 的行，如果当前行值为NULL，则绑定为该行的对等体。</li></ul><p>下面是一些有效<code>expr PRECEDING</code> 和<code>expr FOLLOWING</code> 示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> PRECEDING</span><br><span class="line">INTERVAL5DAY PRECEDING</span><br><span class="line"><span class="number">5</span> FOLLOWING</span><br><span class="line"><span class="type">INTERVAL</span><span class="string">&#x27;2:30&#x27;</span> MINUTE_SECOND FOLLOWING</span><br></pre></td></tr></table></figure><p>在没有frame子句的情况下，默认的frame取决于是否存在ORDER BY子句：</p><ul><li>有<code>ORDER BY</code>：默认frame包括从分区开始到当前行的行，包括当前行的所有对等点。与之等效的frame如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br></pre></td></tr></table></figure><ul><li>没有<code>ORDER BY</code>：默认frame包括所有的分区行（因为，如果没有ORDER BY，所有的分区行都是对等的）。与之等效的frame如下：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> UNBOUNDED PRECEDING <span class="keyword">AND</span> UNBOUNDED FOLLOWING</span><br></pre></td></tr></table></figure><p>因为默认frame会根据是否存在ORDER BY而有所不同，所以向查询添加ORDER BY以获得确定性结果可能会更改结果。要获得相同的结果，但按ORDER BY排序，无论ORDER BY是否存在，都要提供要使用的显式frame规范。</p><h3 id="3-窗口函数应用"><a href="#3-窗口函数应用" class="headerlink" title="3. 窗口函数应用"></a><strong>3. 窗口函数应用</strong></h3><p><img src="https://s2.loli.net/2025/05/27/ctSWKkG5zZxhr9q.png" alt="window"></p><p>窗口函数只能在查询或子查询中使用，不能在UPDATE或DELETE语句中使用它们来更新行。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深分页解决方案</title>
      <link href="/2025/04/83e42223e4f8.html"/>
      <url>/2025/04/83e42223e4f8.html</url>
      
        <content type="html"><![CDATA[<h2 id="深分页的原因："><a href="#深分页的原因：" class="headerlink" title="深分页的原因："></a>深分页的原因：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a <span class="operator">=</span> x limit m, n</span><br></pre></td></tr></table></figure><p>数据量比较大的时候，此种方式的查询效果性能会显著下降</p><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>成因：</p><ul><li><strong>全表扫描</strong>：当 OFFSET 值增大时，MySQL必须跳过前面的所有记录。这意味着 MySQL 需要对前面的记录进行排序（如果使用 <code>ORDER BY</code>），即使这些记录并不在最终结果中。这导致查询的执行时间线性增长。</li><li><strong>内存消耗</strong>：随着 OFFSET 的增加，MySQL 需要使用更多的内存来存储那些被跳过的记录，尤其在进行排序时，这会对性能产生显著影响。</li></ul><p>影响：</p><ul><li>响应时间延迟</li><li>数据库负载增加<h2 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h2></li></ul><ol><li><p>基于主键的游标分页（比较依赖主键递增）<br>通过前端传递最后一条数据id，查询大于此id的数据</p></li><li><p>分段加载<br>通过在业务上调整跳页，改成懒加载模式，滚动加载</p></li><li><p>inner join 延迟关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> t1 <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> a <span class="operator">=</span> x limit m, n) t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.id</span><br></pre></td></tr></table></figure></li></ol><p>通过将条件转移到主键树，减少回表降低磁盘IO</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁实现方案</title>
      <link href="/2025/04/4648b9b9cb63.html"/>
      <url>/2025/04/4648b9b9cb63.html</url>
      
        <content type="html"><![CDATA[<h2 id="最简易的分布式锁"><a href="#最简易的分布式锁" class="headerlink" title="最简易的分布式锁"></a>最简易的分布式锁</h2><p>命令：<code>SETNX</code>  key不存在，则设置成功，否则什么也不做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">SETNX lockKey uniqueValue</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure><p>释放锁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEL lockKey</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>也可以使用Lua脚本原子执行，释放锁：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此方式的缺点：如果释放锁过程中出现问题，导致锁没有被正常释放，则其他线程无法再获取到锁</p><h2 id="锁过期"><a href="#锁过期" class="headerlink" title="锁过期"></a>锁过期</h2><p>通过使用<code>SET</code>命令：SET key value EX timeout NX </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET lockKey uniqueValue EX 3 NX</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>要保证设置指定 key 的值和过期时间是一个原子操作</li><li>如果业务执行时间过久，超过timeout时间会导致锁过期释放，丧失锁的意义</li><li>如果timeout设置的太久，则影响服务质量，降低服务性能<h2 id="锁续期"><a href="#锁续期" class="headerlink" title="锁续期"></a>锁续期</h2></li></ul><p>为解决超时时间设置不合理的问题，<code>redisson</code>引入看门狗机制，定时续期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="comment">//......</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                <span class="comment">// 异步续期，基于 Lua 脚本</span></span><br><span class="line">                CompletionStage&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">                future.whenComplete((res, e) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 无法续期</span></span><br><span class="line">                        log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                        EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                        <span class="comment">// 递归调用实现续期</span></span><br><span class="line">                        renewExpiration();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 取消续期</span></span><br><span class="line">                        cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span></span><br><span class="line">        &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        ee.setTimeout(task);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> CompletionStage&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span></span><br><span class="line">            <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()),</span><br><span class="line">            internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2><p>官方分布式锁：</p><ol><li>第一步是，客户端获取当前时间（t1）</li><li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：<ul><li>加锁操作使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。</li><li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li></ul></li><li>第三步是，一旦客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li></ol><p>核心要求：</p><ul><li>过半节点上锁成功</li><li>总耗时不超过锁过期时间<h3 id="RedLock分布式问题"><a href="#RedLock分布式问题" class="headerlink" title="RedLock分布式问题"></a>RedLock分布式问题</h3></li></ul><p>分布式面临的三大问题：NPC<br>N: network delay 网络延迟<br>P: process pause 进程暂停<br>C: clock drift 时钟漂移</p><blockquote><p><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/">深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了!</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID解决方案</title>
      <link href="/2025/04/53672db5ba40.html"/>
      <url>/2025/04/53672db5ba40.html</url>
      
        <content type="html"><![CDATA[<h2 id="分布式ID介绍"><a href="#分布式ID介绍" class="headerlink" title="分布式ID介绍"></a>分布式ID介绍</h2><h3 id="什么是-ID？"><a href="#什么是-ID？" class="headerlink" title="什么是 ID？"></a>什么是 ID？</h3><p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p><h3 id="什么是分布式-ID？"><a href="#什么是分布式-ID？" class="headerlink" title="什么是分布式 ID？"></a>什么是分布式 ID？</h3><p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p><p>随着数据量越来越大，系统开始分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>如何为不同的数据节点生成全局唯一主键呢？</strong></p><p>这个时候就需要生成<strong>分布式 ID</strong>了。</p><p><img src="https://s2.loli.net/2025/04/18/yCWcn3qm2IgYfwe.png" alt="1717569876026-757e1ce1-8a1b-4079-b134-ad6a1d7ff3e8.png"></p><h3 id="分布式-ID-需要满足哪些要求"><a href="#分布式-ID-需要满足哪些要求" class="headerlink" title="分布式 ID 需要满足哪些要求?"></a>分布式 ID 需要满足哪些要求?</h3><p><img src="https://s2.loli.net/2025/04/18/kqOsEyGiAUdwWrS.png" alt="1717569876154-fb797c77-aac1-4cfa-a050-ad88aa5b1c54.png"></p><p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。</p><p>一个最基本的分布式 ID 需要满足下面这些要求：</p><ul><li><strong>全局唯一</strong>：ID 的全局唯一性肯定是首先要满足的！</li><li><strong>高性能</strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。</li><li><strong>高可用</strong>：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li><li><strong>方便易用</strong>：拿来即用，使用方便，快速接入！</li></ul><p>除了这些之外，一个比较好的分布式 ID 还应保证：</p><ul><li><strong>安全</strong>：ID 中不包含敏感信息。</li><li><strong>有序递增</strong>：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li><li><strong>有具体的业务含义</strong>：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li><li><strong>独立部署</strong>：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。<h2 id="分布式-ID-常见解决方案"><a href="#分布式-ID-常见解决方案" class="headerlink" title="分布式 ID 常见解决方案"></a>分布式 ID 常见解决方案</h2></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="数据库主键自增"><a href="#数据库主键自增" class="headerlink" title="数据库主键自增"></a>数据库主键自增</h4><p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p><p><img src="https://s2.loli.net/2025/04/18/mRNh5fPDZduCb7c.png" alt="1717569876232-84620fb3-cae5-4485-bd64-5f2a6b6dfe3f.png"></p><p>以 MySQL 举例</p><p><strong>1.创建一个数据库表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `sequence_id` (  </span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,  </span><br><span class="line">  `stub` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>,  </span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `stub` (`stub`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>stub 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 stub 字段创建了唯一索引，保证其唯一性。</p><p><strong>2.通过 replace into 来插入数据。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;  </span><br><span class="line">REPLACE <span class="keyword">INTO</span> sequence_id (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;stub&#x27;</span>);  </span><br><span class="line"><span class="keyword">SELECT</span> LAST_INSERT_ID();  </span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>插入数据这里，我们没有使用 insert into 而是使用 replace into 来插入数据，具体步骤是这样的：</p><ul><li>第一步：尝试把数据插入到表中。</li><li>第二步：如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</li></ul><p>这种方式的优缺点也比较明显：</p><ul><li><strong>优点</strong>：实现起来比较简单、ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong>：支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）<h4 id="数据库号段模式"><a href="#数据库号段模式" class="headerlink" title="数据库号段模式"></a>数据库号段模式</h4></li></ul><p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p><p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p><p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">Tinyid</a> 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p><p>以 MySQL 举例</p><p><strong>1. 创建一个数据库表。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `sequence_id_generator` (  </span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span>,  </span><br><span class="line">  `current_max_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;当前最大id&#x27;</span>,  </span><br><span class="line">  `step` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;号段的长度&#x27;</span>,  </span><br><span class="line">  `version` <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;版本号&#x27;</span>,  </span><br><span class="line">  `biz_type`    <span class="type">int</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;业务类型&#x27;</span>,  </span><br><span class="line">   <span class="keyword">PRIMARY KEY</span> (`id`)  </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>current_max_id 字段和step字段主要用于获取批量 ID，获取的批量 id 为：<code>current_max_id ~ current_max_id + step</code></p><p><img src="https://s2.loli.net/2025/04/18/DUcrC5wVeFJBSYg.png" alt="1717569876294-1046ec20-d580-46ca-96aa-c204f10afd20.png"></p><p>version 字段主要用于解决并发问题（乐观锁）,biz_type 主要用于表示业务类型。</p><p><strong>2. 先插入一行数据。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)  </span><br><span class="line"><span class="keyword">VALUES</span>  (<span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 通过 SELECT 获取指定业务下的批量唯一 ID</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `current_max_id`, `step`,`version` <span class="keyword">FROM</span> `sequence_id_generator` <span class="keyword">where</span> `biz_type` <span class="operator">=</span> <span class="number">101</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span> id <span class="operator">|</span> current_max_id <span class="operator">|</span> step <span class="operator">|</span> version <span class="operator">|</span> biz_type <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span>       <span class="number">0</span>        <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span>     <span class="number">0</span>   <span class="operator">|</span>    <span class="number">101</span>   <span class="operator">|</span></span><br></pre></td></tr></table></figure><p><strong>4. 不够用的话，更新之后重新 SELECT 即可。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sequence_id_generator <span class="keyword">SET</span> current_max_id <span class="operator">=</span> <span class="number">0</span><span class="operator">+</span><span class="number">100</span>, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> version <span class="operator">=</span> <span class="number">0</span>  <span class="keyword">AND</span> `biz_type` <span class="operator">=</span> <span class="number">101</span>;  </span><br><span class="line"><span class="keyword">SELECT</span> `current_max_id`, `step`,`version` <span class="keyword">FROM</span> `sequence_id_generator` <span class="keyword">where</span> `biz_type` <span class="operator">=</span> <span class="number">101</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">|</span> id <span class="operator">|</span> current_max_id <span class="operator">|</span> step <span class="operator">|</span> version <span class="operator">|</span> biz_type <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span>       <span class="number">100</span>      <span class="operator">|</span>  <span class="number">101</span> <span class="operator">|</span>     <span class="number">1</span>   <span class="operator">|</span>    <span class="number">101</span>   <span class="operator">|</span></span><br></pre></td></tr></table></figure><p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p><p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p><p><strong>数据库号段模式的优缺点:</strong></p><ul><li><strong>优点</strong>：ID 有序递增、存储消耗空间小</li><li><strong>缺点</strong>：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）<h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4></li></ul><p><img src="https://s2.loli.net/2025/04/18/c7WDrTd1epQHXAf.png" alt="1717569876379-15a519e2-3993-425f-accf-faf735261dc5.png"></p><p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 incr 命令即可实现对 id 原子顺序递增。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set sequence_id_biz_type 1  </span><br><span class="line">OK  </span><br><span class="line">127.0.0.1:6379&gt; incr sequence_id_biz_type  </span><br><span class="line">(integer) 2  </span><br><span class="line">127.0.0.1:6379&gt; get sequence_id_biz_type  </span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure><p>为了提高可用性和并发，我们可以使用 Redis Cluster。Redis Cluster 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p><p><strong>Redis 方案的优缺点：</strong></p><ul><li><strong>优点</strong>：性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong>：和数据库主键自增方案的缺点类似</li></ul><p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p><p><img src="https://s2.loli.net/2025/04/18/Q1ezbEm578RaMnD.png" alt="1717569876463-7529d10c-c28c-47cf-92de-1b14a6411c6c.png"></p><p>MongoDB ObjectId 一共需要 12 个字节存储：</p><ul><li>0~3：时间戳</li><li>3~6：代表机器 ID</li><li>7~8：机器进程 ID</li><li>9~11：自增值</li></ul><p><strong>MongoDB 方案的优缺点：</strong></p><ul><li><strong>优点</strong>：性能不错并且生成的 ID 是有序递增的</li><li><strong>缺点</strong>：需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）、有安全性问题（ID 生成有规律性）<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3></li></ul><h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p><p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了：<code>UUID.randomUUID()</code></p><p><a href="https://tools.ietf.org/html/rfc4122">RFC 4122</a> 中关于 UUID 的示例是这样的：</p><p><img src="https://s2.loli.net/2025/04/18/dHw41AgPIVh2oTY.png" alt="1717569876532-f2c0b034-0460-44ef-adea-390c8291a4bf.png"></p><p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p><p>5 种不同的 Version(版本)值分别对应的含义（参考<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81">维基百科对于 UUID 的介绍</a>）：</p><ul><li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li><li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li><li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li><li><strong>版本 4</strong> : UUID 使用<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7">随机性</a>或<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7">伪随机性</a>生成。</li></ul><p>下面是 Version 1 版本下生成的 UUID 的示例：</p><p><img src="https://s2.loli.net/2025/04/18/cuNYStzKCRa7DlX.png" alt="1717569876591-461ffcb2-31fc-4d5b-afc8-923657235854.png"></p><p>JDK 中通过 UUID 的 randomUUID() 方法生成的 UUID 的版本默认为 4。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();  </span><br><span class="line"><span class="type">int</span> <span class="variable">version</span> <span class="operator">=</span> uuid.version();<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p><p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p><p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p><ul><li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li><li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li></ul><p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong></p><ul><li><strong>优点</strong>：生成速度比较快、简单易用</li><li><strong>缺点</strong>：存储消耗空间大（32 个字符串，128 位）、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）<h4 id="Snowflake-雪花算法"><a href="#Snowflake-雪花算法" class="headerlink" title="Snowflake(雪花算法)"></a>Snowflake(雪花算法)</h4></li></ul><p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p><p><img src="https://s2.loli.net/2025/04/18/nHrwX9mosNJv5C1.png" alt="1717569876674-503ea3bc-d69d-4054-83c1-31b63471ccdd.png"></p><ul><li><strong>sign(1bit)</strong>:符号位（标识正负），始终为 0，代表生成的 ID 为正数。</li><li><strong>timestamp (41 bits)</strong>:一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li><li><strong>datacenter id + worker id (10 bits)</strong>:一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li><li><strong>sequence (12 bits)</strong>:一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li></ul><p>在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p><p>我们再来看看 Snowflake 算法的优缺点：</p><ul><li><strong>优点</strong>：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）    </li><li><strong>缺点</strong>：需要解决重复 ID 问题（ID 生成依赖时间，在获取时间的时候，可能会出现时间回拨的问题，也就是服务器上的时间突然倒退到之前的时间，进而导致会产生重复 ID）、依赖机器 ID 对分布式环境不友好（当需要自动启停或增减机器时，固定的机器 ID 可能不够灵活）。<h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3></li></ul><h4 id="UidGenerator-百度"><a href="#UidGenerator-百度" class="headerlink" title="UidGenerator(百度)"></a>UidGenerator(百度)</h4><p><a href="https://github.com/baidu/uid-generator">UidGenerator</a> 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p><p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下：</p><p><img src="https://s2.loli.net/2025/04/18/PMruGhmNcOijCD8.png" alt="1717569876795-08c4f066-3124-44f9-b235-9fa5f3264648.png"></p><ul><li><strong>sign(1bit)</strong>:符号位（标识正负），始终为 0，代表生成的 ID 为正数。</li><li><strong>delta seconds (28 bits)</strong>:当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约 8.7 年</li><li><strong>worker id (22 bits)</strong>:机器 id，最多可支持约 420w 次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</li><li><strong>sequence (13 bits)</strong>:每秒下的并发序列，13 bits 可支持每秒 8192 个并发。</li></ul><p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p><p>UidGenerator 官方文档中的介绍如下：</p><p><img src="https://s2.loli.net/2025/04/18/siTRo9avnVNEmr4.png" alt="1717569876938-6047d39a-df9a-47e9-ab99-d88fe6bcc163.png"></p><p>自 18 年后，UidGenerator 就基本没有再维护了</p><h4 id="Leaf-美团"><a href="#Leaf-美团" class="headerlink" title="Leaf(美团)"></a>Leaf(美团)</h4><p><a href="https://github.com/Meituan-Dianping/Leaf">Leaf</a> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话：“There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p><p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper（使用 Zookeeper 作为注册中心，通过在特定路径下读取和创建子节点来管理 workId） 。</p><p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p><p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段</p><p><img src="https://s2.loli.net/2025/04/18/lNmonO3kpGYsMVT.png" alt="1717569877026-a190aab9-165c-450f-aec2-e5dcdfbcad13.png"></p><p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p><h4 id="Tinyid-滴滴"><a href="#Tinyid-滴滴" class="headerlink" title="Tinyid(滴滴)"></a>Tinyid(滴滴)</h4><p><a href="https://github.com/didi/tinyid">Tinyid</a> 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p><p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p><p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">《Tinyid 原理介绍》</a>）</p><p><img src="https://s2.loli.net/2025/04/18/8kVl1TWj7F4SgLt.png" alt="1717569877088-402e9c44-9893-44d6-b473-ff495f8d949b.png"></p><p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p><p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p><ul><li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li><li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li></ul><p>除此之外，HTTP 调用也存在网络开销。</p><p>Tinyid 的原理比较简单，其架构如下图所示：</p><p><img src="https://s2.loli.net/2025/04/18/hFUzGklxv3VpAJj.png" alt="1717569877157-f83b74a9-7cdd-4ae3-a9f7-248af58d54f9.png"></p><p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p><ul><li><strong>双号段缓存</strong>：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li><li><strong>增加多 db 支持</strong>：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li><li><strong>增加 tinyid-client</strong>：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>数据库</strong><ol><li>主键自增<ul><li>优点：实现起来比较简单、ID 有序递增、存储消耗空间小。</li><li>缺点：<ul><li>支持的并发量不大</li><li>存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）</li><li>ID 没有具体业务含义</li><li>安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量）</li><li>每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li></ul></li></ul></li><li>号段模式<ul><li>优点：ID 有序递增、存储消耗空间小</li><li>缺点：<ul><li>存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）</li><li>ID 没有具体业务含义</li><li>安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量）</li></ul></li></ul></li><li>NoSQL，比如Redis<ul><li>优点：性能不错并且生成的 ID 是有序递增的</li><li>缺点：和数据库主键自增方案的缺点类似</li></ul></li></ol></li><li><strong>算法</strong><ol><li>UUID<ul><li>优点：生成速度比较快、简单易用</li><li>缺点：存储消耗空间大（32 个字符串，128 位）、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li></ul></li><li>Snowflake(雪花算法)<ul><li>优点：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li><li>缺点：需要解决重复 ID 问题（ID 生成依赖时间，在获取时间的时候，可能会出现时间回拨的问题，也就是服务器上的时间突然倒退到之前的时间，进而导致会产生重复 ID）、依赖机器 ID 对分布式环境不友好（当需要自动启停或增减机器时，固定的机器 ID 可能不够灵活）。</li></ul></li></ol></li><li><strong>开源框架</strong><ol><li>UidGenerator(百度)：基于Snowflake(雪花算法)做了改进</li><li>Leaf(美团)： 支持号段模式 和 Snowflake(雪花算法) 来生成分布式 ID，增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程</li><li>Tinyid(滴滴)<ul><li>双号段缓存：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li><li>增加多 db 支持：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li><li>增加 tinyid-client：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li></ul></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性Hash算法</title>
      <link href="/2025/04/4227f15fd919.html"/>
      <url>/2025/04/4227f15fd919.html</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于常规的<code>hash(obj) % n</code>算法，如果n有变化，则会导致计算的偏离，致使数据无法找回等。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>判断hash算法好坏的定义：</p><ul><li>平衡性：hash结果尽可能分散，充分利用所有缓冲空间</li><li>单调性：哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去</li><li>分散性：分布式环境中，终端有可能只能看到部分缓冲空间，从而导致相同结果被映射到不同缓冲中去</li><li>负载：对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容</li></ul><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="Hash环"><a href="#Hash环" class="headerlink" title="Hash环"></a>Hash环</h3><p> key值哈希之后的结果顺时针找上述环形hash空间中，距离自己最近的机器节点，然后将数据存储到上面<br><img src="https://pdai.tech/images/alg/alg-dist-hash-4.jpg" alt="hash-ring"></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节点会将之前存储在此节点的数据重新存储到下一临近节点，其他键不受影响。<br>避免了 <code>hash(obj) % n</code> 缓存雪崩的问题</p><p><img src="https://pdai.tech/images/alg/alg-dist-hash-5.jpg" alt="hash-ring-del-node"></p><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>与删除节点类似</p><h3 id="不平衡问题"><a href="#不平衡问题" class="headerlink" title="不平衡问题"></a>不平衡问题</h3><ul><li>由于删除节点数量导致的某一节点存储数据陡增，从而导致节点<strong>存储和流量</strong>过大而宕机</li><li>单节点的宕机从而引发集群风暴，雪崩出现</li></ul><h3 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h3><p>实际节点在hash环中的副本<code>replica</code>，打乱顺序分散在整个hash空间</p><p>通过将虚拟节点打乱分散在hash环上，可以将宕机的节点的数据分散到其他节点上，从而有效避免单机宕机，引起的其他单机存储和流量飙升问题</p><p><img src="https://pdai.tech/images/alg/alg-dist-hash-9.png" alt="hash-ring-vnode"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同Git仓库配置不同的用户名</title>
      <link href="/2025/04/f99615d1c9ba.html"/>
      <url>/2025/04/f99615d1c9ba.html</url>
      
        <content type="html"><![CDATA[<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>一般的情况下执行如下命令，可以对全局项目设置统一的用户名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name ak1ra</span><br></pre></td></tr></table></figure><p>如果我们需要对不同的项目，配置不同的用户名，可以有以下两种方式：</p><ul><li>单独配置</li><li>批量配置</li></ul><h2 id="单独配置"><a href="#单独配置" class="headerlink" title="单独配置"></a>单独配置</h2><p>在需要配置的项目下进行单独配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name ak1ra </span><br><span class="line">git config user.email ak1ra@xxx.com </span><br></pre></td></tr></table></figure><p>之后可以观察当前项目 <strong>.git</strong> 文件夹下 <strong>.gitconfig</strong> 文件是否生效</p><h2 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h2><p>使用 <strong>git</strong> 的 <strong>includeIf</strong> 配置，来实现在某一路径下的 <strong>git</strong> 项目，统一使用同一个 <strong>git</strong> 配置文件</p><ol><li>将需要配置成相同用户名的项目放在一个统一的路径下，如：/Users/ak1ra/Code/</li><li>在该路径下创建 <strong>.gitconfig</strong> 文件，添加配置信息</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">    name = ak1ra</span><br><span class="line">    email = ak1ra@xxx.com</span><br></pre></td></tr></table></figure><ol><li>修改git的全局配置文件 <strong>.gitconfig</strong>，这个配置文件路径一般都是~/.gitconfig。添加以下配置信息:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[includeIf &quot;gitdir:/Users/ak1ra/Code/&quot;]</span><br><span class="line">path = /Users/ak1ra/Code/.gitconfig</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/2025/04/e7d65b34eac2.html"/>
      <url>/2025/04/e7d65b34eac2.html</url>
      
        <content type="html"><![CDATA[<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包问题的基本场景是这样的：</p><p>你有一个背包，它有最大载重量。同时，你有无限数量的不同物品可以选择。每种物品都有自己的重量和价值。你的目标是在不超过背包最大载重的情况下，让背包中物品的总价值最大。</p><p>与01背包不同，完全背包中的每种物品可以无限次选择，而不是只能选择0次或1次。</p><p>让我举一个具体的例子：</p><p>假设你有一个最大承重为10公斤的背包。现在有三种物品可选：</p><ol><li>书本：重2公斤，价值3元</li><li>电子设备：重4公斤，价值5元</li><li>水壶：重3公斤，价值4元</li></ol><p>在完全背包问题中，你可以：</p><ul><li>放入多本相同的书</li><li>放入多个相同的电子设备</li><li>放入多个相同的水壶</li></ul><p>解决完全背包问题的核心思路是动态规划。我给你展示一个Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompleteKnapsack</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完全背包问题的动态规划解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weights 物品重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 物品价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 背包容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最大价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">completeKnapsack</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span>[] values, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一维动态规划表</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充动态规划表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weights[i]; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="comment">// 尝试放入当前物品，更新最大价值</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最大价值</span></span><br><span class="line">        <span class="keyword">return</span> dp[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追踪选择的物品（完全背包）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weights 物品重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 物品价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 背包容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含最大价值和选择物品信息的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">trackItems</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span>[] values, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记录每个容量下最后使用的物品</span></span><br><span class="line">        <span class="type">int</span>[] lastItem = <span class="keyword">new</span> <span class="title class_">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weights[i]; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &lt; dp[j - weights[i]] + values[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j - weights[i]] + values[i];</span><br><span class="line">                    lastItem[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯找出选择的物品</span></span><br><span class="line">        List&lt;Integer&gt; selectedItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remainCapacity</span> <span class="operator">=</span> capacity;</span><br><span class="line">        <span class="keyword">while</span> (remainCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">item</span> <span class="operator">=</span> lastItem[remainCapacity];</span><br><span class="line">            selectedItems.add(item);</span><br><span class="line">            remainCapacity -= weights[item];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(dp[capacity], selectedItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果类，用于返回最大价值和选择的物品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">        <span class="type">int</span> maxValue;</span><br><span class="line">        List&lt;Integer&gt; selectedItems;</span><br><span class="line"></span><br><span class="line">        Result(<span class="type">int</span> maxValue, List&lt;Integer&gt; selectedItems) &#123;</span><br><span class="line">            <span class="built_in">this</span>.maxValue = maxValue;</span><br><span class="line">            <span class="built_in">this</span>.selectedItems = selectedItems;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        <span class="type">int</span>[] weights = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;     <span class="comment">// 物品重量</span></span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;      <span class="comment">// 物品价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;              <span class="comment">// 背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> completeKnapsack(weights, values, capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;完全背包 - 最大价值：&quot;</span> + maxValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪选择的物品</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> trackItems(weights, values, capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大价值：&quot;</span> + result.maxValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;选择的物品索引：&quot;</span> + result.selectedItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的关键在于：</p><ol><li>使用一维数组<code>dp</code>记录每个容量下的最大价值</li><li>外层循环遍历所有可能的背包容量</li><li>内层循环遍历所有物品</li><li>对于每个容量，尝试放入当前物品，更新最大价值</li></ol><p>算法的时间复杂度是O(capacity * n)，其中n是物品种类数。</p><p>在上面的例子中，对于一个10公斤的背包，最终可以获得的最大价值是多少？你可以自己尝试运行这段代码，看看结果。</p><p>需要注意的是，完全背包问题有多种解法，这只是其中最基本的一种动态规划实现。根据具体场景，还可以有空间优化、记忆化搜索等不同的解题思路。</p><h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>01背包问题是动态规划中的经典问题，与完全背包有些相似，但关键区别在于每种物品只能选择0次或1次。</p><p>基本场景是这样的： 你有一个背包，它有最大载重量。同时，你有若干种不同的物品，每种物品只有一个。每种物品都有自己的重量和价值。你的目标是在不超过背包最大载重的情况下，让背包中物品的总价值最大。</p><p>举一个具体的例子： 假设你有一个最大承重为10公斤的背包。现在有三种物品可选：</p><ol><li>笔记本电脑：重5公斤，价值6000元</li><li>平板电脑：重3公斤，价值4000元</li><li>耳机：重2公斤，价值1500元</li></ol><p>在01背包问题中，你只能选择：</p><ul><li>放入1个笔记本电脑，或者不放</li><li>放入1个平板电脑，或者不放</li><li>放入1个耳机，或者不放</li></ul><p>我给你展示一个Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZeroOneKnapsack</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 01背包问题的动态规划解法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weights 物品重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 物品价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 背包容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最大价值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">zeroOneKnapsack</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span>[] values, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 物品数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> weights.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建二维动态规划表</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充动态规划表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">                <span class="comment">// 默认不放入当前物品的价值</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前物品重量小于等于背包剩余容量</span></span><br><span class="line">                <span class="keyword">if</span> (weights[i-<span class="number">1</span>] &lt;= j) &#123;</span><br><span class="line">                    <span class="comment">// 比较不放入 vs 放入当前物品的价值</span></span><br><span class="line">                    dp[i][j] = Math.max(</span><br><span class="line">                        dp[i][j], </span><br><span class="line">                        dp[i-<span class="number">1</span>][j - weights[i-<span class="number">1</span>]] + values[i-<span class="number">1</span>]</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最大价值</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 追踪选择的物品</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weights 物品重量数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 物品价值数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 背包容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含最大价值和选择物品索引的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">trackItems</span><span class="params">(<span class="type">int</span>[] weights, <span class="type">int</span>[] values, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> weights.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][capacity + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 填充动态规划表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= capacity; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (weights[i-<span class="number">1</span>] &lt;= j) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(</span><br><span class="line">                        dp[i][j], </span><br><span class="line">                        dp[i-<span class="number">1</span>][j - weights[i-<span class="number">1</span>]] + values[i-<span class="number">1</span>]</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯找出选择的物品</span></span><br><span class="line">        List&lt;Integer&gt; selectedItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> capacity;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i][j] &gt; dp[i-<span class="number">1</span>][j]) &#123;</span><br><span class="line">                selectedItems.add(i - <span class="number">1</span>);</span><br><span class="line">                j -= weights[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最大价值和选择的物品索引</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(dp[n][capacity], selectedItems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果类，用于返回最大价值和选择的物品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">        <span class="type">int</span> maxValue;</span><br><span class="line">        List&lt;Integer&gt; selectedItems;</span><br><span class="line"></span><br><span class="line">        Result(<span class="type">int</span> maxValue, List&lt;Integer&gt; selectedItems) &#123;</span><br><span class="line">            <span class="built_in">this</span>.maxValue = maxValue;</span><br><span class="line">            <span class="built_in">this</span>.selectedItems = selectedItems;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例数据</span></span><br><span class="line">        <span class="type">int</span>[] weights = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;     <span class="comment">// 物品重量</span></span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">6000</span>, <span class="number">4000</span>, <span class="number">1500</span>&#125;;  <span class="comment">// 物品价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算最大价值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> zeroOneKnapsack(weights, values, capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;01背包 - 最大价值：&quot;</span> + maxValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪选择的物品</span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> trackItems(weights, values, capacity);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大价值：&quot;</span> + result.maxValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;选择的物品索引：&quot;</span> + result.selectedItems);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的关键点解析：</p><ol><li><p>使用二维数组<code>dp</code>记录状态</p><ul><li><code>dp[i][j]</code>表示：前<code>i</code>个物品，在背包容量为<code>j</code>时的最大价值</li><li>初始状态下，背包价值都为0</li></ul></li><li><p>动态规划的核心逻辑：</p><ul><li>对于每个物品，有两种选择： a) 不放入当前物品 b) 放入当前物品（如果背包容量允许）</li><li>选择能够获得最大价值的方案</li></ul></li><li><p>状态转移方程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j - weights[i-<span class="number">1</span>]] + values[i-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><ul><li><code>dp[i-1][j]</code>：不放入当前物品的价值</li><li><code>dp[i-1][j-weights[i-1]] + values[i-1]</code>：放入当前物品的价值</li></ul></li><li><p>我还添加了一个<code>track_items()</code>函数，可以追踪具体选择了哪些物品</p></li></ol><p>与完全背包的主要区别：</p><ul><li>01背包每种物品只能选择0次或1次</li><li>使用二维数组记录状态</li><li>状态转移方程略有不同</li></ul><p>时间复杂度：O(n <em> capacity) 空间复杂度：O(n </em> capacity)</p><p>可以通过空间优化将空间复杂度降低到O(capacity)，但会使代码稍微复杂一些。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【REF】一文讲清多线程与多线程同步</title>
      <link href="/2025/04/fe33c6976349.html"/>
      <url>/2025/04/fe33c6976349.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://tech.meituan.com/2024/07/19/multi-threading-and-multi-thread-synchronization.html">【REF】一文讲清多线程与多线程同步</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解MySQL锁机制</title>
      <link href="/2023/11/8f7f5661afb6.html"/>
      <url>/2023/11/8f7f5661afb6.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解MySQL锁机制"><a href="#深入理解MySQL锁机制" class="headerlink" title="深入理解MySQL锁机制"></a>深入理解MySQL锁机制</h1><p>锁是计算机在执行多线程或线程时用于并发访问同一共享资源时的同步机制，MySQL中的锁是在服务器层或者存储引擎层实现的，保证了数据访问的一致性与有效性。</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>MySQL锁可以按模式分类为：乐观锁与悲观锁。按粒度分可以分为全局锁、表级锁、页级锁、行级锁。按属性可以分为：共享锁、排它锁。按状态分为：意向共享锁、意向排它锁。按算法分为：间隙锁、临键锁、记录锁。</p><p><img src="https://s2.loli.net/2023/11/27/yk6gYvzTtPEGbcl.png" alt="image-20231127150400415"></p><h2 id="2-全局锁、表级锁、页级锁、行级锁"><a href="#2-全局锁、表级锁、页级锁、行级锁" class="headerlink" title="2. 全局锁、表级锁、页级锁、行级锁"></a>2. <strong>全局锁、表级锁、页级锁、行级锁</strong></h2><h3 id="1-全局锁"><a href="#1-全局锁" class="headerlink" title="1. 全局锁"></a>1. 全局锁</h3><p>(1) 概念</p><p>全局锁就是对整个数据库实例加锁。</p><p>(2) 应用场景</p><p>全库逻辑备份（mysqldump）</p><p>(3) 实现方式</p><p>MySQL 提供了一个加全局读锁的方法，命令是Flush tables with read lock (FTWRL)。</p><p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p><p>风险点：</p><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</p><p>如果在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</p><p>解决办法：</p><p>mysqldump使用参数—single-transaction，启动一个事务，确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。</p><h3 id="2-表级锁"><a href="#2-表级锁" class="headerlink" title="2. 表级锁"></a>2. 表级锁</h3><p>(1) 概念</p><p>当前操作的整张表加锁，最常使用的 MyISAM 与 InnoDB 都支持表级锁定。</p><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><p>(2) 实现方式</p><p>表锁：<strong>lock tables … read/write</strong>；</p><p>例如lock tables t1 read, t2 write; 命令，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能在unlock tables之前访问其他表。</p><p><strong>元数据锁</strong>：MDL 不需要显式使用，在访问一个表的时候会被自动加上，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><p>(3) 风险点</p><p>参考于：<a href="https://www.cnblogs.com/keme/p/11065025.html">www.cnblogs.com/keme/p/1106…</a></p><p>给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。</p><ol><li>sessionA:</li></ol><p><strong>begin;</strong></p><p><strong>select * from t limit 1;</strong></p><ol><li>sessionB:</li></ol><p><strong>select * from t limit 1;</strong></p><ol><li>sessionC:</li></ol><p><strong>alter table t add f int;</strong></p><p>#会mdl锁住</p><ol><li>sessionD:</li></ol><p><strong>select * from t limit 1;</strong></p><p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于session B 需要的也是 MDL 读锁，因此可以正常执行。</p><p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 sessionC 需要MDL 写锁，因此只能被阻塞。</p><p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被session C 阻塞。前面说了，<code>所有对表的增删改查操作都需要先申请MDL 读锁，而这时读锁没有释放，对表alter ，产生了mdl写锁，把表t锁住了，这时候就对表t完全不可读写了</code>。</p><p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新session 再请求的话，这个库的线程很快就会爆满。</p><p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p><ul><li><code>*注 ：一般行锁都有锁超时时间。但是MDL锁没有超时时间的限制，只要事务没有提交就会一直锁注。**</code></li></ul><p>(4) 解决办法</p><p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。这也是为什么需要在低峰期做ddl 变更。</p><h3 id="3-页级锁"><a href="#3-页级锁" class="headerlink" title="3. 页级锁"></a>3. 页级锁</h3><p>(1) 概念</p><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。因此，采取了折衷的页级锁，一次锁定相邻的一组记录。BDB 引擎支持页级锁。</p><h3 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4.行级锁"></a>4.行级锁</h3><p>(1) 概念</p><p>行级锁是粒度最低的锁，发生锁冲突的概率也最低、并发度最高。但是加锁慢、开销大，容易发生死锁现象。</p><p>MySQL中只有InnoDB支持行级锁，行级锁分为共享锁和排他锁。</p><p>(2) 实现方式</p><p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p><p>(3) 实战</p><p>我们演示一下行锁的表现，分别在session1和session2中执行update操作，看会不会被锁定。</p><p><img src="https://s2.loli.net/2023/11/27/BlQXFKSN3Re6wb7.png" alt="image-20231127162323552"></p><p><img src="https://s2.loli.net/2023/11/27/zCJv2bmD4THVfeQ.png" alt="image-20231127162627150"></p><p>可以看到由于session1迟迟未提交事务，session2在等待session1释放锁时出现了超过锁定超时的警告了。</p><p>那么如果session2执行id=2的操作会不会成功呢？</p><p>执行id=2的操作是可以成功的。</p><p><img src="https://s2.loli.net/2023/11/27/sgyeU3rWu9jVD1S.png" alt="image-20231127164312229"></p><h2 id="3-乐观锁和悲观锁"><a href="#3-乐观锁和悲观锁" class="headerlink" title="3. 乐观锁和悲观锁"></a>3. 乐观锁和悲观锁</h2><h3 id="1-乐观锁"><a href="#1-乐观锁" class="headerlink" title="1. 乐观锁"></a>1. 乐观锁</h3><p>(1) 概念</p><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p><p>(2) 应用场景</p><p>适用于读多写少，因为如果出现大量的写操作，写冲突的可能性就会增大，业务层需要不断重试，会大大降低系统性能。</p><p>(3) 实现方式</p><p>一般使用数据版本（Version）记录机制实现，在数据库表中增加一个数字类型的“version”字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</p><p><img src="https://s2.loli.net/2023/11/27/4O8mWMXoUPt2hqG.png" alt="image-4O8mWMXoUPt2hqG"></p><p>(4) 实战</p><p>订单order表中 id, status, version 分别代表订单ID，订单状态，版本号。</p><p>1.查询订单信息</p><p><strong>select id, status, version from order where id=#{id};</strong></p><p>2.用户支付成功</p><p>3.修改订单状态</p><p><strong>update set status = 支付成功, version = version + 1 where id = #{id} and version = #{ version};</strong></p><h3 id="2-悲观锁"><a href="#2-悲观锁" class="headerlink" title="2. 悲观锁"></a>2. 悲观锁</h3><p>(1) 概念</p><p>悲观锁，正如其名，具有强烈的独占和排他特性，每次去拿数据的时候都认为别人会修改，对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。</p><p>(2) 应用场景</p><p>适用于并发量不大、写入操作比较频繁、数据一致性比较高的场景。</p><p>(3) 实现方式</p><p>在MySQL中使用悲观锁，必须关闭MySQL的自动提交，set autocommit=0。共享锁和排它锁是悲观锁的不同的实现，它俩都属于悲观锁的范畴。</p><p>(4) 实战</p><p>商品goods表中 id, name, number 分别代表商品ID，商品名称，商品库存。</p><p>1.开启事务并关闭自动提交</p><p><strong>set autocommit = 0;</strong></p><p>2.查询商品信息</p><p><strong>select id, name, number from goods where id = 1 for update;</strong></p><p>3.用户下单，生成订单</p><p>4.修改商品库存</p><p><strong>update set number = number - 1 where id = 1;</strong></p><p>5.提交事务</p><p><strong>commit;</strong></p><p>说明：select…for update是MySQL提供的实现悲观锁的方式，属于排它锁，在goods表中，id为1的那条数据就被当前事务锁定了，其它的要执行select id,name,number from goods where id=1for update;的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>注意：此时MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住。</p><h2 id="4-共享锁和排它锁"><a href="#4-共享锁和排它锁" class="headerlink" title="4. 共享锁和排它锁"></a>4. 共享锁和排它锁</h2><h3 id="1-共享锁"><a href="#1-共享锁" class="headerlink" title="1. 共享锁"></a>1. 共享锁</h3><p>(1) 概念</p><p>共享锁，又称之为读锁，简称S锁，当事务A对数据加上读锁后，其他事务只能对该数据加读锁，不能做任何修改操作，也就是不能添加写锁。只有当事务A上的读锁被释放后，其他事务才能对其添加写锁。</p><p>(2) 应用场景</p><p>共享锁主要是为了支持并发的读取数据而出现的，读取数据时，不允许其他事务对当前数据进行修改操作，从而避免”不可重读”的问题的出现。</p><p>适合于两张表存在关系时的写操作，拿mysql官方文档的例子来说，一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行select * from parent where c_child_id = 100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child (child_id) values (100)就不会存在这种问题了。</p><p>(3) 实现方式</p><p><strong>select … lock in share mode</strong></p><p>(4) 实战</p><p><img src="https://s2.loli.net/2023/11/27/1VXNKQq5BihUO4A.png" alt="image-1VXNKQq5BihUO4A"></p><p><img src="https://s2.loli.net/2023/11/27/qemDiXHWVF8JvMS.png" alt="image-qemDiXHWVF8JvMS"></p><p>session1持有共享锁，未提交。session2的查询不受影响，但是update操作会被一直阻塞，直到超时。</p><h3 id="2-排它锁"><a href="#2-排它锁" class="headerlink" title="2. 排它锁"></a>2. 排它锁</h3><p>(1) 概念</p><p>排它锁，又称之为写锁，简称X锁，当事务对数据加上写锁后，其他事务既不能对该数据添加读写，也不能对该数据添加写锁，写锁与其他锁都是互斥的。只有当前数据写锁被释放后，其他事务才能对其添加写锁或者是读锁。</p><p>MySQL InnoDB 引擎默认 update, delete, insert 都会自动给涉及到的数据加上排他锁，select语句默认不会加任何锁类型。</p><p>(2) 应用场景</p><p>写锁主要是为了解决在修改数据时，不允许其他事务对当前数据进行修改和读取操作，从而可以有效避免”脏读”问题的产生。</p><p>(3) 实现方式</p><p><strong>select … for update</strong></p><p>(4) 实战</p><p>session1排它锁查询。session2也做排它锁查询会被阻塞。</p><p><img src="https://s2.loli.net/2023/11/27/THf3IDBcmMLga69.png" alt="image-THf3IDBcmMLga69"></p><p><img src="https://s2.loli.net/2023/11/27/aUohk9dGwNMIj1y.png" alt="image-aUohk9dGwNMIj1y"></p><h2 id="5-意向共享锁和意向排它锁"><a href="#5-意向共享锁和意向排它锁" class="headerlink" title="5. 意向共享锁和意向排它锁"></a>5. 意向共享锁和意向排它锁</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。</p><h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2. 作用"></a>2. 作用</h3><p>当有事务A有行锁时，MySQL会自动为该表添加意向锁，事务B如果想申请整个表的写锁，那么不需要遍历每一行判断是否存在行锁，而直接判断是否存在意向锁，增强性能。</p><h3 id="3-意向锁的兼容互斥性"><a href="#3-意向锁的兼容互斥性" class="headerlink" title="3. 意向锁的兼容互斥性"></a>3. 意向锁的兼容互斥性</h3><div class="table-container"><table><thead><tr><th></th><th>意向共享锁（IS）</th><th>意向排它锁（IX）</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>兼容</td><td>互斥</td></tr><tr><td>排它锁（X）</td><td>互斥</td><td>互斥</td></tr></tbody></table></div><p><strong>4. 实战</strong></p><p><strong>注意：这里的排它</strong> <strong>/</strong> <strong>共享锁指的都是表锁！！！意向锁不会与行级的共享</strong> <strong>/</strong> <strong>排它锁互斥！！！</strong></p><p>session1获取了某一行的排他锁，并未提交：</p><p><strong>select * from goods where id = 1 for update;</strong></p><p>此时 goods 表存在两把锁：goods 表上的意向排它锁与 id 为 1 的数据行上的排它锁。</p><p>session2 想要获取 goods 表的共享锁：</p><p><strong>LOCK TABLES goods READ;</strong></p><p>此时session2 检测session1 持有goods 表的意向排他锁，就可以得知session1必然持有该表中某些数据行的排他锁，那么session2 对 goods 表的加锁请求就会被排斥（阻塞），而无需去检测表中的每一行数据是否存在排它锁。</p><p><img src="https://s2.loli.net/2023/11/27/DQK2WjLN45q9wbm.png" alt="image-DQK2WjLN45q9wbm"></p><p><img src="https://s2.loli.net/2023/11/27/uh3vK6XHjMxBrcz.png" alt="image-uh3vK6XHjMxBrcz"></p><h2 id="6-间隙锁、临键锁、记录锁"><a href="#6-间隙锁、临键锁、记录锁" class="headerlink" title="6. 间隙锁、临键锁、记录锁"></a>6. 间隙锁、临键锁、记录锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>记录锁、间隙锁、临键锁都是排它锁，而记录锁的使用方法跟排它锁介绍一致。</p><h3 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h3><p>记录锁是封锁记录，记录锁也叫行锁，例如：</p><p><strong>select</strong> <strong>* from</strong> <strong>goods</strong> <strong>where</strong> <code>**id**</code>= 1 <strong>for</strong> <strong>update</strong>;</p><p>它会在 id = 1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id = 1 这一行。</p><h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</p><p><strong>select * from goods where id between 1 and 10 for update;</strong></p><p>即所有在（1，10）区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1和 10 两条记录行并不会被锁住。</p><p><img src="https://s2.loli.net/2023/11/27/mseE1kVbd5iSyTv.png" alt="image-mseE1kVbd5iSyTv"></p><p><img src="https://s2.loli.net/2023/11/27/ouRx8j9DalnCzXb.png" alt="image-ouRx8j9DalnCzXb"></p><h3 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h3><p>临键锁，是记录锁与间隙锁的组合，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间。临键锁的主要目的，也是为了避免幻读(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。</p><p>每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，InnoDB 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><p><img src="https://s2.loli.net/2023/11/27/B729rGJUMExfoRY.png" alt="image-B729rGJUMExfoRY"></p><p>goods表中隐藏的临键锁有：(-∞, 96],(96, 99],(99, +∞]</p><p><img src="https://s2.loli.net/2023/11/27/MdXEsCmkwVn7IBH.png" alt="image-MdXEsCmkwVn7IBH"></p><p>session1 在对 number 为 96 的列进行 update 操作的同时，也获取了(-∞, 96],(96, 99]这两个区间内的临键锁。</p><p>最终我们就可以得知，在根据非唯一索引对记录行进行 UPDATE \ FOR UPDATE \LOCK IN SHARE MODE 操作时，InnoDB 会获取该记录行的临键锁，公式为：左gap lock + record lock + 右gap lock。</p><p>即session1在执行了上述的 SQL 后，最终被锁住的记录区间为 (-∞, 99)。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/52678870">深入理解数据库行锁与表锁</a></p></li><li><p><a href="https://juejin.cn/post/6931752749545553933">史上最全MySQL各种锁详解</a></p></li><li><a href="https://www.cnblogs.com/keme/p/11065025.html">MySQL全局锁和表锁</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty粘包拆包解决方案</title>
      <link href="/2023/06/cc1e007cc495.html"/>
      <url>/2023/06/cc1e007cc495.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>客户端与服务端进行TCP网络通信时，在发送以及读取数据时可能会出现粘包以及拆包问题，那么作为高性能网络框架的Netty是如何解决粘包以及拆包问题的呢？我们一起来探讨下这个问题。</p><h2 id="什么是粘包、拆包？"><a href="#什么是粘包、拆包？" class="headerlink" title="什么是粘包、拆包？"></a>什么是粘包、拆包？</h2><p>在搞清楚Netty如何解决粘包以及拆包问题之前，我们得先搞清楚到底什么是粘包、拆包。我们都知道TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。 这种基于流的协议是没有明显边界的，TCP这种底层协议是不会理解上层的业务业务含义的，因此在通信过程中，发送数据流的时候，有可能出现一份完整的数据，被TCP拆分为多个数据包进行发送，当然也有可能将多个数据包合并为一个数据包进行发送。从而产生了拆包以及粘包的问题。</p><h3 id="1、粘包"><a href="#1、粘包" class="headerlink" title="1、粘包"></a>1、粘包</h3><p>业务侧理想的是分别发送三个数据包到服务端，服务端根据不同的数据包进行对应的业务处理。但是实际事与愿违，现实很骨感，实际上服务端接收到的是一个数据包，而且是三个数据包揉在一起的。这种现象就是TCP粘包。</p><h3 id="2、拆包"><a href="#2、拆包" class="headerlink" title="2、拆包"></a>2、拆包</h3><p>这种情况下，服务端理想是要接收一个数据包，但是实际收到了拆解后的两个数据包。这种场景就成为拆包。</p><h3 id="出现粘包、拆包现象的根本原因"><a href="#出现粘包、拆包现象的根本原因" class="headerlink" title="出现粘包、拆包现象的根本原因"></a>出现粘包、拆包现象的根本原因</h3><p>1、客户端要发送的数据小于TCP发送缓冲区的大小，TCP为了提升效率，将多个写入缓冲区的数据包一次发送出去，多个数据包粘在一起，造成粘包；2、服务端的应用层没有及时处理接收缓冲区中的数据，再次进行读取时出现粘包问题；3、数据发送过快，数据包堆积导致缓冲区积压多个数据后才一次性发送出去；4、拆包一般由于一次发送的数据包太大，超过MSS的大小，那么这个数据包就会被拆成多个TCP报文分开进行传输。<br>根本原因：TCP 基于字节流的协议，消息无边界。</p><h2 id="常见解决办法"><a href="#常见解决办法" class="headerlink" title="常见解决办法"></a>常见解决办法</h2><p>通过上文我们知道，底层的的TCP协议负责数据传输，它是无法理解上层的业务数据的具体语义的，所以在底层我们没有办法进行解决。那么我们只能通过上层的协议设计来解决粘包、拆包问题，主要有以下几种方法：</p><h3 id="1、消息定长"><a href="#1、消息定长" class="headerlink" title="1、消息定长"></a>1、消息定长</h3><p>可以考虑客户端将每个数据包设定为固定长度（不够的可以通过补特定字符进行填充）的流数据，那么接收端在接收缓冲区中读取到约定固定长度的数据流之后，服务端就可以根据约定的数据长度进行数据包的解析，区分不同的数据包。</p><h3 id="2、明确消息边界"><a href="#2、明确消息边界" class="headerlink" title="2、明确消息边界"></a>2、明确消息边界</h3><p>既然流式协议无法区分消息边界，那我们就约定好消息边界。服务端接收到数据流之后，按照之前的约定通过消息边界进行消息数据分离。比如在数据包尾增加<code>\n</code>进行分割。</p><h3 id="3、将消息分为消息头和消息体"><a href="#3、将消息分为消息头和消息体" class="headerlink" title="3、将消息分为消息头和消息体"></a>3、将消息分为消息头和消息体</h3><p>消息头中包含表示消息总长度（或者消息体长度）的字段，后面跟上对应的消息内容。服务端读取数据后，先解析出消息头中的内容长度大小，再将后面的内容一把读取出来。</p><h2 id="Netty解决粘包、拆包的办法"><a href="#Netty解决粘包、拆包的办法" class="headerlink" title="Netty解决粘包、拆包的办法"></a>Netty解决粘包、拆包的办法</h2><p>Netty作为一款高性能的网络框架，不仅仅是它对NIO进行了深度封装，其在客户端和服务端之间的数据传输也进行了很好的处理。其中粘包、拆包的办法就是它的用武之地。<code>Netty</code>通过预先指定的数据流编解码器，按照预先约定好的规则进行数据的解析，即可解决对应的粘包、拆包问题。<br>下面我们一起看下<code>Netty</code>为我们提供了哪些编解码器吧。<br><code>Netty</code> 中的拆包器大致如下：</p><h3 id="1-对应定长法的解码器-FixedLengthFrameDecoder"><a href="#1-对应定长法的解码器-FixedLengthFrameDecoder" class="headerlink" title="1.对应定长法的解码器 FixedLengthFrameDecoder"></a>1.对应定长法的解码器 FixedLengthFrameDecoder</h3><p><code>Netty</code> 在消息长度固定的场景下，对定长法进行了封装。其中<code>FixedLengthFrameDecoder</code>便是Netty中的固定长度解码器，它的主要作用就是对固定长度的流数据进行解码。定长法中只有解码器，没有编码器。对于编码器来说，<code>Netty</code> 懒得实现了，由用户自己实现，只需要在发送数据时将不足的长度补齐即可，不需要其他额外的操作。解码器使用非常简单，只需要在 <code>childHandler</code> 中添加一个解码器就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">      bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">200</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 将FixedLengthFrameDecoder添加到pipeline中，定长20</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">20</span>));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">           ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      bossGroup.shutdownGracefully();</span><br><span class="line">      workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EchoServer</span>().bind(<span class="number">8080</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对应明确消息边界的分隔符拆包器-DelimiterBasedFrameDecoder"><a href="#2-对应明确消息边界的分隔符拆包器-DelimiterBasedFrameDecoder" class="headerlink" title="2.对应明确消息边界的分隔符拆包器 DelimiterBasedFrameDecoder"></a>2.对应明确消息边界的分隔符拆包器 DelimiterBasedFrameDecoder</h3><p>通过<code>LineBasedFrameDecoder</code> 可以实现自动处理以指定分割符为字节流的消息的解码。 <code>LineBasedFrameDecoder</code>则是实现以<code>\n</code>以及<code>\r\n</code>为分隔符的数据流解码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">      bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">200</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 将FixedLengthFrameDecoder添加到pipeline中，定长20</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">delimiter</span> <span class="operator">=</span> Unpooled.copiedBuffer(“%_%”.getBytes());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(<span class="number">1024</span>， delimiter));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">           ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">EchoServerHandler</span>());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.bind(port).sync();</span><br><span class="line">      future.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      bossGroup.shutdownGracefully();</span><br><span class="line">      workerGroup.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">EchoServer</span>().bind(<span class="number">8080</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-对应消息头消息体的基于数据包长度的解码器-LengthFieldBasedFrameDecoder"><a href="#3-对应消息头消息体的基于数据包长度的解码器-LengthFieldBasedFrameDecoder" class="headerlink" title="3.对应消息头消息体的基于数据包长度的解码器 LengthFieldBasedFrameDecoder"></a>3.对应消息头消息体的基于数据包长度的解码器 LengthFieldBasedFrameDecoder</h3><p><code>LengthFieldBasedFrameDecoder</code> 与 <code>LengthFieldPrepender</code> 这两个需要配合起来使用。实际上就是在编码的时候需要在数据包头部添加数据包长度的字段，具体的数据紧跟在数据包后面。<code>LengthFieldBasedFrameDecoder</code> 便会按照参数指定的数据长度偏移量对接收到的数据包进行解码，进而得到指定的消息体数据。但是 <code>LengthFieldPrepender</code> 则会在响应的数据前面添加指定的字节数据，这个字节数据中保存了当前消息体的整体字节数据长度。</p><h3 id="4、自定义编解码器"><a href="#4、自定义编解码器" class="headerlink" title="4、自定义编解码器"></a>4、自定义编解码器</h3><p>一般来说，上面几种方式可以解决大部分粘包以及拆包问题，但是如果涉及更复杂的编解码，开发者可以自行进行定义实现。<br>（1）编码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CustomDecoder</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（2）解码器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">CustomEncoder</span>&lt;I&gt; extendsChannelOutboundHandlerAdapter &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span><span class="keyword">throws</span> Exception;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.Rust高级进阶</title>
      <link href="/2022/05/4403e2f5fb06.html"/>
      <url>/2022/05/4403e2f5fb06.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-生命周期"><a href="#3-1-生命周期" class="headerlink" title="3.1 生命周期"></a>3.1 生命周期</h2><h3 id="3-1-1-认识生命周期"><a href="#3-1-1-认识生命周期" class="headerlink" title="3.1.1 认识生命周期"></a>3.1.1 认识生命周期</h3><p>生命周期，简而言之就是引用的有效作用域。</p><p>多数情况下编译器可以自动进行推导，用类型来类比下：</p><ul><li>就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期</li><li>在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期</li></ul><h4 id="悬垂指针与生命周期"><a href="#悬垂指针与生命周期" class="headerlink" title="悬垂指针与生命周期"></a>悬垂指针与生命周期</h4><p>生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码有几点值得注意:</p><ul><li><code>let r;</code> 的声明方式貌似存在使用 <code>null</code> 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错</li><li><p><code>r</code> 引用了内部花括号中的 <code>x</code> 变量，但是 <code>x</code> 会在内部花括号 <code>&#125;</code> 处被释放，因此回到外部花括号后，<code>r</code> 会引用一个无效的 <code>x</code></p><p><code>r</code> 就是一个悬垂指针，它引用了提前被释放的变量 <code>x</code></p></li></ul><h4 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h4><p>为保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查我们程序借用的正确性：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let r;                        // ---------+-- &#x27;a</span><br><span class="line">                                      //          |</span><br><span class="line">        &#123;                             //          |</span><br><span class="line">                                      //          |</span><br><span class="line">            let x = 5;                // -+-- &#x27;b  |</span><br><span class="line">            r = &amp;x;                   //  |       |</span><br><span class="line">        &#125;                             // -+       |</span><br><span class="line">                                      //          |</span><br><span class="line">        println!(&quot;r: &#123;&#125;&quot;, r);         //          |</span><br><span class="line">    &#125;                                 // ---------+</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器，Rust 会检查两个变量的生命周期，因为 <code>r</code> 的生命周期 <code>&#39;a</code>  比 <code>x</code> 的生命周期 <code>&#39;b</code> 要大，因此拒绝运行。</p><h4 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h4><p>思考下面的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">22</span>:<span class="number">33</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">   |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br></pre></td></tr></table></figure><p>编译器无法知道该函数的返回值到底引用 <code>x</code> 还是 <code>y</code> ，<strong>因为编译器需要知道这些，来确保函数调用后的引用生命周期分析</strong>。</p><p>在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</p><h4 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h4><blockquote><p>  生命周期标注并不会改变任何引用的实际作用域</p></blockquote><p>语法：以 <code>&#39;</code> 开头，名称往往是一个单独的小写字母。eg: ‘a.</p><p>引用类型参数 -&gt; 生命周期会位于引用符号 <code>&amp;</code> 之后，并用一个空格隔开。 eg: <code>&amp;&#39;a i32</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 具有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 具有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure><h5 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的点如下：</p><ul><li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li><li><code>x</code>、<code>y</code> 和返回值至少活得和 <code>&#39;a</code> 一样久(因为返回值要么是 <code>x</code>，要么是 <code>y</code>)</li></ul><h5 id="深入思考生命周期标注"><a href="#深入思考生命周期标注" class="headerlink" title="深入思考生命周期标注"></a>深入思考生命周期标注</h5><p><strong>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于</strong>：</p><ul><li>函数参数的生命周期</li><li>函数体中某个新建引用的生命周期</li></ul><p>若是后者情况，就是典型的悬垂引用场景：最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者。</p><p>对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。</p><h4 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h4><p>为结构体中每一项引用标注生命周期即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体 <code>ImportantExcerpt</code> 所引用的字符串 <code>str</code> 必须比该结构体活得更久</strong></p><h4 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h4><p>注意：</p><ul><li>消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期</li><li><strong>函数或者方法中，参数的生命周期被称为 <code>输入生命周期</code>，返回值的生命周期被称为 <code>输出生命周期</code></strong></li></ul><h5 id="三条消除规则"><a href="#三条消除规则" class="headerlink" title="三条消除规则"></a>三条消除规则</h5><ol><li><strong>每一个引用参数都会获得独自的生命周期</strong></li><li><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</strong></li><li><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong></li></ol><h4 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h4><p>为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p>Rust 中有一个非常特殊的生命周期，那就是 <code>&#39;static</code>，拥有该生命周期的引用可以和整个程序活得一样久。</p><p>总结如下：</p><ul><li>生命周期 <code>&#39;static</code> 意味着能和程序活得一样久，例如字符串字面量和特征对象</li><li>实在遇到解决不了的生命周期标注问题，可以尝试 <code>T: &#39;static</code>，有时候它会给你奇迹</li></ul><h3 id="3-1-2-深入生命周期-TODO"><a href="#3-1-2-深入生命周期-TODO" class="headerlink" title="3.1.2 深入生命周期[TODO]"></a>3.1.2 深入生命周期[TODO]</h3><h3 id="3-1-3-amp-’static-和-T-‘static"><a href="#3-1-3-amp-’static-和-T-‘static" class="headerlink" title="3.1.3 &amp;’static 和 T: ‘static"></a>3.1.3 &amp;’static 和 T: ‘static</h3><p><code>&#39;static</code> 在 Rust 中是相当常见的，例如字符串字面值就具有 <code>&#39;static</code> 生命周期:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mark_twain</span>: &amp;<span class="type">str</span> = <span class="string">&quot;Samuel Clemens&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_author</span>(mark_twain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_author</span>(author: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&#39;static</code> 的另一种使用场景:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mark_twain</span> = <span class="string">&quot;Samuel Clemens&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;mark_twain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>&lt;T: Display + <span class="symbol">&#x27;static</span>&gt;(message: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="amp-’static"><a href="#amp-’static" class="headerlink" title="&amp;’static"></a>&amp;’static</h4><p><code>&amp;&#39;static</code> 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 <code>&amp;&#39;static</code>。</p><p><strong><code>&amp;&#39;static</code> 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则。</strong></p><h4 id="T-‘static"><a href="#T-‘static" class="headerlink" title="T: ‘static"></a>T: ‘static</h4><h4 id="static-到底针对谁？"><a href="#static-到底针对谁？" class="headerlink" title="static 到底针对谁？"></a>static 到底针对谁？</h4><ul><li><p>是 <code>&amp;&#39;static</code> 这个引用还是该引用指向的数据活得跟程序一样久呢？</p><p><strong>答案是引用指向的数据</strong>，而引用本身是要遵循其作用域范围的</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经验之谈，可以这么来:</p><ul><li>如果你需要添加 <code>&amp;&#39;static</code> 来让代码工作，那很可能是设计上出问题了</li><li>如果你希望满足和取悦编译器，那就使用 <code>T: &#39;static</code>，很多时候它都能解决问题</li></ul><h2 id="3-2-函数式编程：闭包、迭代器"><a href="#3-2-函数式编程：闭包、迭代器" class="headerlink" title="3.2 函数式编程：闭包、迭代器"></a>3.2 函数式编程：闭包、迭代器</h2><h3 id="3-2-1-闭包-Closure"><a href="#3-2-1-闭包-Closure" class="headerlink" title="3.2.1 闭包 Closure"></a>3.2.1 闭包 <code>Closure</code></h3><p>闭包：匿名函数，可以赋值给变量或作为参数传递给其他函数，允许捕获调用者作用域中的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">sum</span> = |y| x + y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">sum</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用闭包简化代码"><a href="#使用闭包简化代码" class="headerlink" title="使用闭包简化代码"></a>使用闭包简化代码</h4><p>通过将函数赋值给某一变量，可以快速调整对此函数的使用。</p><h4 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h4><p>闭包的形式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br><span class="line">or</span><br><span class="line">|param1| 返回表达式</span><br></pre></td></tr></table></figure><h4 id="闭包类型推导"><a href="#闭包类型推导" class="headerlink" title="闭包类型推导"></a>闭包类型推导</h4><p>多数情况下，不需要显式声明类型。</p><p>同一功能的函数与闭包实现形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure><p>闭包的类型推导中，<strong>当编译器推导出一种类型后，它就会一直使用该类型</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">29</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br><span class="line">   |                             ^- help: <span class="keyword">try</span> using a conversion method: `.<span class="title function_ invoke__">to_string</span>()`</span><br><span class="line">   |                             |</span><br><span class="line">   |                             expected <span class="keyword">struct</span> `<span class="type">String</span>`, found integer</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br></pre></td></tr></table></figure><h4 id="结构体中的闭包"><a href="#结构体中的闭包" class="headerlink" title="结构体中的闭包"></a>结构体中的闭包</h4><p>假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：</p><ul><li>一个闭包用于获取值</li><li>一个变量，用于存储该值</li></ul><p>可以使用结构体来代表缓存对象，最终设计如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  Fn 特征不仅仅适用于闭包，还适用于函数</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(query: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            query,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.query)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕获作用域中的值"><a href="#捕获作用域中的值" class="headerlink" title="捕获作用域中的值"></a>捕获作用域中的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>x</code> 并不是闭包 <code>equal_to_x</code> 的参数，但是它依然可以去使用 <code>x</code>，因为 <code>equal_to_x</code> 在 <code>x</code> 的作用域范围内。</p><h5 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h5><p>当闭包从环境中捕获一个值时，会<strong>分配内存</strong>去存储这些值。</p><h4 id="三种-Fn-特征"><a href="#三种-Fn-特征" class="headerlink" title="三种 Fn 特征"></a>三种 <code>Fn</code> 特征</h4><ol><li><p><code>FnOnce</code>，该类型的闭包会拿走被捕获变量的所有权。<code>Once</code> 顾名思义，说明该闭包只能运行一次：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>(|z| z == x.<span class="title function_ invoke__">len</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>仅</strong>实现 <code>FnOnce</code> 特征的闭包在调用时会转移所有权。</p></blockquote></li><li><p><code>FnMut</code>，它以可变借用的方式捕获了环境中的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line">    <span class="title function_ invoke__">update_string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Fn</code> 特征，它以不可变借用的方式捕获环境中的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> =  |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;<span class="symbol">&#x27;a</span>, F: <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>)&gt;(<span class="keyword">mut</span> f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="move-和-Fn"><a href="#move-和-Fn" class="headerlink" title="move 和 Fn"></a><code>move</code> 和 <code>Fn</code></h5><p><strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量</strong></p><h5 id="三种-Fn-的关系"><a href="#三种-Fn-的关系" class="headerlink" title="三种 Fn 的关系"></a>三种 <code>Fn</code> 的关系</h5><p>一个闭包并不仅仅实现某一种 <code>Fn</code> 特征，规则如下：</p><ul><li>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次</li><li>没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征</li><li>不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line">    <span class="title function_ invoke__">exec1</span>(update_string);</span><br><span class="line">    <span class="title function_ invoke__">exec2</span>(update_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec1</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec2</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="闭包作为函数返回值"><a href="#闭包作为函数返回值" class="headerlink" title="闭包作为函数返回值"></a>闭包作为函数返回值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span>&#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + num)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-迭代器-Iterator"><a href="#3-2-2-迭代器-Iterator" class="headerlink" title="3.2.2 迭代器 Iterator"></a>3.2.2 迭代器 <code>Iterator</code></h3><h4 id="For-与迭代器"><a href="#For-与迭代器" class="headerlink" title="For 与迭代器"></a><code>For</code> 与迭代器</h4><p>区别在于是否通过<strong>索引</strong>来访问集合</p><p><code>Rust</code>中数组实现了 <code>IntoIterator</code>特征，通过<code>for</code>语法糖将该特征的数组转换为迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> arr &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>IntoIterator</code> 特征有一个 <code>into_iter</code> 方法，可以显式的把数组转换成迭代器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>Rust中迭代器是惰性的。</p><h4 id="IntoIterator特征"><a href="#IntoIterator特征" class="headerlink" title="IntoIterator特征"></a><code>IntoIterator</code>特征</h4><h5 id="into-iter-iter-iter-mut"><a href="#into-iter-iter-iter-mut" class="headerlink" title="into_iter, iter, iter_mut"></a><code>into_iter</code>, <code>iter</code>, <code>iter_mut</code></h5><ul><li><code>into_iter</code> 会夺走所有权</li><li><code>iter</code> 是借用</li><li><code>iter_mut</code> 是可变借用</li></ul><h5 id="Iterator-和-IntoIterator-的区别"><a href="#Iterator-和-IntoIterator-的区别" class="headerlink" title="Iterator 和 IntoIterator 的区别"></a><code>Iterator</code> 和 <code>IntoIterator</code> 的区别</h5><ul><li><code>Iterator</code> 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 <code>next</code></li><li><code>IntoIterator</code> 强调的是某一个类型如果实现了该特征，它可以通过 <code>into_iter</code>，<code>iter</code> 等方法变成一个迭代器</li></ul><h4 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h4><h5 id="消费者适配器"><a href="#消费者适配器" class="headerlink" title="消费者适配器"></a>消费者适配器</h5><p>迭代器上的某个方法 <code>A</code> 在其内部调用了 <code>next</code> 方法，那么 <code>A</code> 就被称为<strong>消费性适配器</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v1_iter 是借用了 v1，因此 v1 可以照常使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v1_iter);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h5><p>迭代器适配器，顾名思义，会返回一个新的迭代器。</p><p>迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-深入类型"><a href="#3-3-深入类型" class="headerlink" title="3.3 深入类型"></a>3.3 深入类型</h2><h3 id="3-3-1-newtype-和类型别名"><a href="#3-3-1-newtype-和类型别名" class="headerlink" title="3.3.1 newtype 和类型别名"></a>3.3.1 <code>newtype</code> 和类型别名</h3><h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><p>使用<strong>元组结构体</strong>的方式将已有的类型包裹起来：<code>Meters（u32）</code>，<code>Meters</code> 就是一个<code>newtype</code>。</p><p>好处：</p><ul><li>自定义类型可以让我们给出更有意义和可读性的类型名</li><li>对于某些场景，只有 <code>newtype</code> 可以很好地解决</li><li>隐藏内部类型的细节</li></ul><h4 id="为外部类型实现外部特征"><a href="#为外部类型实现外部特征" class="headerlink" title="为外部类型实现外部特征"></a>为外部类型实现外部特征</h4><p>在外部类型上实现外部特征必须使用 <code>newtype</code> 的方式，否则你就得遵循孤儿规则：要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 必须至少有一个在当前的作用范围内。</p><p>使用 <code>newtype</code> 对标注库类型 <code>Vec</code> 实现 <code>Display</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">w = [hello, world]</span><br></pre></td></tr></table></figure><h4 id="隐藏内部细节"><a href="#隐藏内部细节" class="headerlink" title="隐藏内部细节"></a>隐藏内部细节</h4><p>使用 <code>newtype</code> 对外隐藏内部细节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Meters</span>(i);</span><br><span class="line">    <span class="comment">// 下面的代码将报错，因为`Meters`类型上没有`pow`方法</span></span><br><span class="line">    <span class="comment">// assert_eq!(n.pow(2), 4);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>更传统的方式来创建新类型：类型别名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Meters</span> = <span class="type">u32</span></span><br></pre></td></tr></table></figure><p><strong>类型别名并不是一个独立的全新的类型，而是某一个类型的别名</strong>。</p><h3 id="3-3-2-Sized-和不定长类型DST"><a href="#3-3-2-Sized-和不定长类型DST" class="headerlink" title="3.3.2 Sized 和不定长类型DST"></a>3.3.2 <code>Sized</code> 和不定长类型<code>DST</code></h3><ul><li>定长类型( sized )，这些类型的大小在编译时是已知的</li><li>不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST</li></ul><h4 id="动态大小类型-DST"><a href="#动态大小类型-DST" class="headerlink" title="动态大小类型 DST"></a>动态大小类型 <code>DST</code></h4><p><strong>因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译</strong>。</p><p>试图创建动态大小数组:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">my_function</span>(n: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">123</span>; n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片:</p><p><code>str</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">str</span> = <span class="string">&quot;Hello there!&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;How&#x27;s it going?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span>: &amp;<span class="type">str</span> = <span class="string">&quot;on?&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，将动态数据固定化的秘诀就是使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。</p><p>特征对象:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_1</span>(thing: &amp;<span class="keyword">dyn</span> MyThing) &#123;&#125; <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_2</span>(thing: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyThing&gt;) &#123;&#125; <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_3</span>(thing: MyThing) &#123;&#125; <span class="comment">// ERROR!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：只能间接使用的 DST</p><p>Rust 中常见的 <code>DST</code> 类型有: <code>str</code>、<code>[T]</code>、<code>dyn Trait</code>，<strong>它们都无法单独被使用，必须要通过引用或者 <code>Box</code> 来间接使用</strong> 。</p><h4 id="Size-特征"><a href="#Size-特征" class="headerlink" title="Size 特征"></a><code>Size</code> 特征</h4><p>Rust如何保证泛型参数是固定大小类型的？</p><p>编译器自动帮我们加上了 <code>Sized</code> 特征：<strong>所有在编译时就能知道其大小的类型，都会自动实现 <code>Sized</code> 特征</strong>。</p><p><strong>每一个特征都是一个可以通过名称来引用的动态大小类型</strong>。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 <code>&amp;dyn Trait</code> 或者 <code>Box&lt;dyn Trait&gt;</code> (还有 <code>Rc&lt;dyn Trait&gt;</code>)这些引用类型。</p><p>想在泛型函数中使用动态数据类型怎么办？可以使用 <code>?Sized</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?Sized</code> 特征用于表明类型 <code>T</code> 是固定大小的类型，或者动态大小的类型。还有一点要注意的是，函数参数类型从 <code>T</code> 变成了 <code>&amp;T</code>，因为 <code>T</code> 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。</p><h4 id="Box-lt-str-gt"><a href="#Box-lt-str-gt" class="headerlink" title="Box&lt;str&gt;"></a><code>Box&lt;str&gt;</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello there!&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-智能指针"><a href="#3-4-智能指针" class="headerlink" title="3.4 智能指针"></a>3.4 智能指针</h3><p>智能指针：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。</p><h3 id="3-4-1-Box-堆对象分配"><a href="#3-4-1-Box-堆对象分配" class="headerlink" title="3.4.1 Box 堆对象分配"></a>3.4.1 <code>Box</code> 堆对象分配</h3><p> <code>Box&lt;T&gt;</code> 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。</p><h4 id="Rust-中的堆栈"><a href="#Rust-中的堆栈" class="headerlink" title="Rust 中的堆栈"></a><code>Rust</code> 中的堆栈</h4><p>Rust 堆上对象有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">foo</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;Hello, &quot;</span>.<span class="title function_ invoke__">to_string</span>() + x;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Box-使用场景"><a href="#Box-使用场景" class="headerlink" title="Box 使用场景"></a><code>Box</code> 使用场景</h4><p><code>Box</code> 特性：</p><ul><li>特意将数据分配在堆上</li><li>数据较大时，又不想在转移所有权时进行数据拷贝</li><li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li><li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li></ul><h5 id="使用-Box-将数据存储在堆上"><a href="#使用-Box-将数据存储在堆上" class="headerlink" title="使用 Box 将数据存储在堆上"></a>使用 <code>Box</code> 将数据存储在堆上</h5><p>使用 <code>Deref</code> 解引用获取指针所指对象的值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行代码将报错</span></span><br><span class="line">    <span class="comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="避免栈上数据的拷贝"><a href="#避免栈上数据的拷贝" class="headerlink" title="避免栈上数据的拷贝"></a>避免栈上数据的拷贝</h5><p>当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 在栈上创建一个长度为1000的数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">0</span>; <span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> = arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 和 arr1 都拥有各自的栈上数组，因此不会报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0</span>; <span class="number">1000</span>]);</span><br><span class="line">    <span class="comment">// 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝</span></span><br><span class="line">    <span class="comment">// 所有权顺利转移给 arr1，arr 不再拥有所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> = arr;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="comment">// 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr.len());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将动态大小类型变为-Sized-固定大小类型"><a href="#将动态大小类型变为-Sized-固定大小类型" class="headerlink" title="将动态大小类型变为 Sized 固定大小类型"></a>将动态大小类型变为 <code>Sized</code> 固定大小类型</h5><h5 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h5><p>实现不同类型组成的数组只有两个办法：枚举和特征对象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是屏幕上第&#123;&#125;号按钮&quot;</span>, <span class="keyword">self</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这个选择框贼难用&#123;&#125;&quot;</span>, <span class="keyword">self</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elems</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123; id: <span class="number">1</span> &#125;), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Select &#123; id: <span class="number">2</span> &#125;)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> elems &#123;</span><br><span class="line">        e.<span class="title function_ invoke__">draw</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">这是屏幕上第<span class="number">1</span>号按钮</span><br><span class="line">这个选择框贼难用<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="Box-leak"><a href="#Box-leak" class="headerlink" title="Box::leak"></a><code>Box::leak</code></h4><p>它可以消费掉 <code>Box</code> 并且强制目标值从内存中泄漏。</p><p>使用场景：<br>如果你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久，那么就可以使用 <code>Box::leak</code>。</p><h3 id="3-4-2-Deref-解引用"><a href="#3-4-2-Deref-解引用" class="headerlink" title="3.4.2 Deref 解引用"></a>3.4.2 <code>Deref</code> 解引用</h3><h4 id="通过-获取引用背后的值"><a href="#通过-获取引用背后的值" class="headerlink" title="通过 * 获取引用背后的值"></a>通过 <code>*</code> 获取引用背后的值</h4><p>对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="智能指针解引用"><a href="#智能指针解引用" class="headerlink" title="智能指针解引用"></a>智能指针解引用</h4><p>智能指针通过实现 <code>Deref</code> 特征，自定义解引用结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>在 <code>Deref</code> 特征中声明了关联类型 <code>Target</code>，在之前章节中介绍过，关联类型主要是为了提升代码可读性</li><li><code>deref</code> 返回的是一个常规引用，可以被 <code>*</code> 进行解引用</li></ul><h4 id="背后原理"><a href="#背后原理" class="headerlink" title="* 背后原理"></a><code>*</code> 背后原理</h4><p>智能指针 <code>Box</code> 解引用的背后：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure><p>首先调用 <code>deref()</code> 获取常规引用，再通过 <code>*</code> 对常规引用解引用，从而获取目标值。</p><h4 id="函数和方法中的隐式-Deref-转换"><a href="#函数和方法中的隐式-Deref-转换" class="headerlink" title="函数和方法中的隐式 Deref 转换"></a>函数和方法中的隐式 <code>Deref</code> 转换</h4><p>若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 <code>Deref</code> 转换：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码有几点值得注意：</p><ul><li><code>String</code> 实现了 <code>Deref</code> 特征，可以在需要时自动被转换为 <code>&amp;str</code> 类型</li><li><code>&amp;s</code> 是一个 <code>&amp;String</code> 类型，当它被传给 <code>display</code> 函数时，自动通过 <code>Deref</code> 转换成了 <code>&amp;str</code></li><li>必须使用 <code>&amp;s</code> 的方式来触发 <code>Deref</code>(仅引用类型的实参才会触发自动解引用)</li></ul><h5 id="连续的隐式-Deref-转换"><a href="#连续的隐式-Deref-转换" class="headerlink" title="连续的隐式 Deref 转换"></a>连续的隐式 <code>Deref</code> 转换</h5><p><code>Deref</code> 可以支持连续的隐式转换，直到找到适合的形式为止：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deref-规则总结"><a href="#Deref-规则总结" class="headerlink" title="Deref 规则总结"></a><code>Deref</code> 规则总结</h4><h4 id="三种-Deref-转换"><a href="#三种-Deref-转换" class="headerlink" title="三种 Deref 转换"></a>三种 <code>Deref</code> 转换</h4><p>Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：</p><ul><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;T</code> 转换成 <code>&amp;U</code>，也就是我们之前看到的例子</li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;U</code></li></ul><h3 id="3-4-3-Drop-释放资源"><a href="#3-4-3-Drop-释放资源" class="headerlink" title="3.4.3 Drop 释放资源"></a>3.4.3 <code>Drop</code> 释放资源</h3><h4 id="Rust-中资源回收"><a href="#Rust-中资源回收" class="headerlink" title="Rust 中资源回收"></a><code>Rust</code> 中资源回收</h4><p><code>Rust</code> 的自动资源回收依靠 <code>Drop</code> 特征。</p><h4 id="Drop-的顺序"><a href="#Drop-的顺序" class="headerlink" title="Drop 的顺序"></a><code>Drop</code> 的顺序</h4><ul><li><strong>变量级别，按照逆序的方式</strong></li><li><strong>结构体内部，按照顺序的方式</strong></li></ul><h4 id="手动回收"><a href="#手动回收" class="headerlink" title="手动回收"></a>手动回收</h4><p><code>Drop::drop</code> 只是借用了目标值的可变引用，后续代码依旧可以使用目标值。使用 <code>drop()</code> 函数获取目标值所有权，手动释放内存。</p><h4 id="互斥的-Copy-和-Drop"><a href="#互斥的-Copy-和-Drop" class="headerlink" title="互斥的 Copy 和 Drop"></a>互斥的 <code>Copy</code> 和 <code>Drop</code></h4><p>无法为一个类型同时实现 <code>Copy</code> 和 <code>Drop</code> 特征：因为实现了 <code>Copy</code> 的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。</p><h3 id="3-4-4-Rc-与-Arc-实现-1vN-所有权机制"><a href="#3-4-4-Rc-与-Arc-实现-1vN-所有权机制" class="headerlink" title="3.4.4 Rc 与 Arc 实现 1vN 所有权机制"></a>3.4.4 <code>Rc</code> 与 <code>Arc</code> 实现 <code>1vN</code> 所有权机制</h3><p>Rust 所有权机制要求一个值只能有一个所有者，在如下情况中：</p><ul><li>在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li><li>在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用</li></ul><p>唯一所有者带来的限制处理起来就会很麻烦。因此 <code>Rust</code> 引入额外的实现：引用计数，允许一个数据资源在同一时刻拥有多个所有者。</p><p>此种实现机制即为：<code>Rc</code> 与 <code>Arc</code> ，前者使用单线程，后者适用多线程。</p><h4 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h4><p>使用 <code>Rc</code> 解决所有权转移问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Rc-clone"><a href="#Rc-clone" class="headerlink" title="Rc::clone"></a><code>Rc::clone</code></h5><p><code>Rc::clone</code>仅仅复制智能指针并增加引用计数，因此 <code>a</code> 和 <code>b</code> 共享底层数据。</p><h5 id="引用计数的变化"><a href="#引用计数的变化" class="headerlink" title="引用计数的变化"></a>引用计数的变化</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test ref counting&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">count after creating a = <span class="number">1</span></span><br><span class="line">count after creating b = <span class="number">2</span></span><br><span class="line">count after creating c = <span class="number">3</span></span><br><span class="line">count after c goes out of scope = <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h5><p><code>Rc&lt;T&gt;</code> 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul><li><code>Rc/Arc</code> 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 <code>RefCell</code> 或互斥锁 <code>Mutex</code></li><li>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的</li><li><code>Rc</code> 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 <code>Arc</code></li><li><code>Rc&lt;T&gt;</code> 是一个智能指针，实现了 <code>Deref</code> 特征，因此你无需先解开 <code>Rc</code> 指针，再使用里面的 <code>T</code>，而是可以直接使用 <code>T</code></li></ul><h3 id="3-4-5-Cell-和-RefCell-内部可变性"><a href="#3-4-5-Cell-和-RefCell-内部可变性" class="headerlink" title="3.4.5 Cell 和 RefCell 内部可变性"></a>3.4.5 <code>Cell</code> 和 <code>RefCell</code> 内部可变性</h3><p>内部可变性的实现是因为 Rust 使用了 <code>unsafe</code> 来做到这一点。</p><h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a><code>Cell</code></h4><p><code>Cell</code> 和 <code>RefCell</code> 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">one</span> = c.<span class="title function_ invoke__">get</span>();</span><br><span class="line">  c.<span class="title function_ invoke__">set</span>(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">two</span> = c.<span class="title function_ invoke__">get</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, one, two);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">asdf,qwer</span><br></pre></td></tr></table></figure><h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a><code>RefCell</code></h4><div class="table-container"><table><thead><tr><th>Rust 规则</th><th>智能指针带来的额外规则</th></tr></thead><tbody><tr><td>一个数据只有一个所有者</td><td><code>Rc/Arc</code>让一个数据可以拥有多个所有者</td></tr><tr><td>要么多个不可变借用，要么一个可变借用</td><td><code>RefCell</code>实现编译期可变、不可变引用共存</td></tr><tr><td>违背规则导致<strong>编译错误</strong></td><td>违背规则导致<strong>运行时<code>panic</code></strong></td></tr></tbody></table></div><h5 id="RefCell-为何存在"><a href="#RefCell-为何存在" class="headerlink" title="RefCell 为何存在"></a><code>RefCell</code> 为何存在</h5><p><code>RefCell</code> 正是<strong>用于你确信代码是正确的，而编译器却发生了误判时</strong>。</p><h5 id="RefCell-简单总结"><a href="#RefCell-简单总结" class="headerlink" title="RefCell 简单总结"></a><code>RefCell</code> 简单总结</h5><ul><li>与 <code>Cell</code> 用于可 <code>Copy</code> 的值不同，<code>RefCell</code> 用于引用</li><li><code>RefCell</code> 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则</li><li><code>RefCell</code> 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li><li>使用 <code>RefCell</code> 时，违背借用规则会导致运行期的 <code>panic</code></li></ul><h2 id="3-5-循环引用与自引用"><a href="#3-5-循环引用与自引用" class="headerlink" title="3.5 循环引用与自引用"></a>3.5 循环引用与自引用</h2><h3 id="3-5-1-Week-与循环引用"><a href="#3-5-1-Week-与循环引用" class="headerlink" title="3.5.1 Week 与循环引用"></a>3.5.1 <code>Week</code> 与循环引用</h3><h4 id="Week"><a href="#Week" class="headerlink" title="Week"></a><code>Week</code></h4><div class="table-container"><table><thead><tr><th><code>Weak</code></th><th><code>Rc</code></th></tr></thead><tbody><tr><td>不计数</td><td>引用计数</td></tr><tr><td>不拥有所有权</td><td>拥有值的所有权</td></tr><tr><td>不阻止值被释放(drop)</td><td>所有权计数归零，才能 drop</td></tr><tr><td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td><td>引用的值必定存在</td></tr><tr><td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td><td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td></tr></tbody></table></div><p>使用方式简单总结下：<strong>对于父子引用关系，可以让父节点通过 <code>Rc</code> 来引用子节点，然后让子节点通过 <code>Weak</code> 来引用父节点</strong>。</p><h3 id="3-5-2-结构体中的自引用"><a href="#3-5-2-结构体中的自引用" class="headerlink" title="3.5.2 结构体中的自引用"></a>3.5.2 结构体中的自引用</h3><h4 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该引用指向上面的value</span></span><br><span class="line">    pointer_to_value: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-Option"><a href="#使用-Option" class="headerlink" title="使用 Option"></a>使用 <code>Option</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WhatAboutThis</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    nickname: <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tricky</span> = WhatAboutThis &#123;</span><br><span class="line">        name: <span class="string">&quot;Annabelle&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        nickname: <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    tricky.nickname = <span class="title function_ invoke__">Some</span>(&amp;tricky.name[..<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, tricky);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">WhatAboutThis &#123; name: <span class="string">&quot;Annabelle&quot;</span>, nickname: <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Anna&quot;</span>) &#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-实现"><a href="#Unsafe-实现" class="headerlink" title="Unsafe 实现"></a><code>Unsafe</code> 实现</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(txt: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        SelfRef &#123;</span><br><span class="line">            value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(txt),</span><br><span class="line">            pointer_to_value: std::ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">self_ref</span>: *<span class="keyword">const</span> <span class="type">String</span> = &amp;<span class="keyword">self</span>.value;</span><br><span class="line">        <span class="keyword">self</span>.pointer_to_value = self_ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pointer_to_value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            !<span class="keyword">self</span>.pointer_to_value.<span class="title function_ invoke__">is_null</span>(),</span><br><span class="line">            <span class="string">&quot;Test::b called without Test::init being called first&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*(<span class="keyword">self</span>.pointer_to_value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span> = SelfRef::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    t.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="comment">// 打印值和指针地址</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;:p&#125;&quot;</span>, t.<span class="title function_ invoke__">value</span>(), t.<span class="title function_ invoke__">pointer_to_value</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hello, <span class="number">0x7ff7b951b398</span></span><br></pre></td></tr></table></figure><h4 id="无法被移动的-Pin"><a href="#无法被移动的-Pin" class="headerlink" title="无法被移动的 Pin"></a>无法被移动的 <code>Pin</code></h4><p><code>Pin</code> 可以固定住一个值，防止该值在内存中被移动。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomPinned;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::ptr::NonNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一个自引用数据结构体，因为 slice 字段是一个指针，指向了 data 字段</span></span><br><span class="line"><span class="comment">// 我们无法使用普通引用来实现，因为违背了 Rust 的编译规则</span></span><br><span class="line"><span class="comment">// 因此，这里我们使用了一个裸指针，通过 NonNull 来确保它不会为 null</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    slice: NonNull&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    <span class="comment">// 为了确保函数返回时数据的所有权不会被转移，我们将它放在堆上，唯一的访问方式就是通过指针</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(data: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = Unmovable &#123;</span><br><span class="line">            data,</span><br><span class="line">            <span class="comment">// 只有在数据到位时，才创建指针，否则数据会在开始之前就被转移所有权</span></span><br><span class="line">            slice: NonNull::<span class="title function_ invoke__">dangling</span>(),</span><br><span class="line">            _pin: PhantomPinned,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">boxed</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">slice</span> = NonNull::<span class="title function_ invoke__">from</span>(&amp;boxed.data);</span><br><span class="line">        <span class="comment">// 这里其实安全的，因为修改一个字段不会转移整个结构体的所有权</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mut_ref</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt; = Pin::<span class="title function_ invoke__">as_mut</span>(&amp;<span class="keyword">mut</span> boxed);</span><br><span class="line">            Pin::<span class="title function_ invoke__">get_unchecked_mut</span>(mut_ref).slice = slice;</span><br><span class="line">        &#125;</span><br><span class="line">        boxed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unmoved</span> = Unmovable::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="comment">// 只要结构体没有被转移，那指针就应该指向正确的位置，而且我们可以随意移动指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">still_unmoved</span> = unmoved;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(still_unmoved.slice, NonNull::<span class="title function_ invoke__">from</span>(&amp;still_unmoved.data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们的类型没有实现 `Unpin` 特征，下面这段代码将无法编译</span></span><br><span class="line">    <span class="comment">// let mut new_unmoved = Unmovable::new(&quot;world&quot;.to_string());</span></span><br><span class="line">    <span class="comment">// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-多线程并发编程"><a href="#3-6-多线程并发编程" class="headerlink" title="3.6 多线程并发编程"></a>3.6 多线程并发编程</h2><h3 id="3-6-1-并发与并行"><a href="#3-6-1-并发与并行" class="headerlink" title="3.6.1 并发与并行"></a>3.6.1 并发与并行</h3><p>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理。</p><h3 id="3-6-2-使用多线程"><a href="#3-6-2-使用多线程" class="headerlink" title="3.6.2 使用多线程"></a>3.6.2 使用多线程</h3><h4 id="多线程编程的风险"><a href="#多线程编程的风险" class="headerlink" title="多线程编程的风险"></a>多线程编程的风险</h4><ul><li>竞态条件</li><li>死锁</li><li>隐晦的BUG</li></ul><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hi number <span class="number">1</span> from the main thread!</span><br><span class="line">hi number <span class="number">1</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">2</span> from the main thread!</span><br><span class="line">hi number <span class="number">2</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the main thread!</span><br><span class="line">hi number <span class="number">4</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">4</span> from the main thread!</span><br><span class="line">hi number <span class="number">5</span> from the spawned thread!</span><br></pre></td></tr></table></figure><p>:warning: 注意：</p><ul><li>线程内部的代码使用闭包来执行</li><li><code>main</code> 线程一旦结束，程序就立刻结束</li><li><code>thread::sleep</code> 会让当前线程休眠指定的时间，随后其它线程会被调度运行</li></ul><h4 id="等待子线程结束"><a href="#等待子线程结束" class="headerlink" title="等待子线程结束"></a>等待子线程结束</h4><p>通过调用 <code>handle.join</code>，可以让当前线程阻塞，直到它等待的子线程的结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hi number <span class="number">1</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">2</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">4</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">1</span> from the main thread!</span><br><span class="line">hi number <span class="number">2</span> from the main thread!</span><br><span class="line">hi number <span class="number">3</span> from the main thread!</span><br><span class="line">hi number <span class="number">4</span> from the main thread!</span><br></pre></td></tr></table></figure><h4 id="线程闭包中使用-Move"><a href="#线程闭包中使用-Move" class="headerlink" title="线程闭包中使用 Move"></a>线程闭包中使用 <code>Move</code></h4><p>可以使用 <code>move</code> 来将所有权从一个线程转移到另外一个线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码会报错borrow of moved value: `v`</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v);</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Here<span class="symbol">&#x27;s</span> a vector: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h4><p>线程代码执行完成，线程就会自动结束。如果不会执行完：</p><ul><li>IO型的任务，CPU占用比较小，线程大部分处于阻塞状态</li><li>CPU密集型任务，如果没有终止条件，可能会跑满CPU核心，直至 <code>main</code> 线程结束</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程A</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 再创建一个线程B</span></span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;I am a new thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新创建的线程执行完成</span></span><br><span class="line">    new_thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Child thread is finish!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡眠一段时间，看子线程创建的子线程是否还在运行</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程屏障"><a href="#线程屏障" class="headerlink" title="线程屏障"></a>线程屏障</h4><p>使用 <code>Barrier</code> 让多个线程都执行到某个点后，才继续一起往后执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">barrier</span> = Arc::<span class="title function_ invoke__">new</span>(Barrier::<span class="title function_ invoke__">new</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = barrier.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">            b.<span class="title function_ invoke__">wait</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br></pre></td></tr></table></figure><h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line">    <span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line">    thread_local!(<span class="keyword">static</span> FOO: RefCell&lt;<span class="type">u32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">        *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">            *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span></span><br><span class="line">    FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair2</span> = pair.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;changing started&quot;</span>);</span><br><span class="line">        *started = <span class="literal">true</span>;</span><br><span class="line">        cvar.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">while</span> !*started &#123;</span><br><span class="line">        started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;started changed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只被调用一次的函数"><a href="#只被调用一次的函数" class="headerlink" title="只被调用一次的函数"></a>只被调用一次的函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::Once;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> VAL: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle1</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    handle2.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; VAL &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-线程同步：消息传递"><a href="#3-6-3-线程同步：消息传递" class="headerlink" title="3.6.3 线程同步：消息传递"></a>3.6.3 线程同步：消息传递</h3><blockquote><p>  Do not communicate by sharing memory; instead, share memory by communicating</p></blockquote><h4 id="消息通道"><a href="#消息通道" class="headerlink" title="消息通道"></a>消息通道</h4><p><code>Rust</code> 提供消息通道（<code>Channel</code>），支持<strong>多发多收</strong>特性。</p><h4 id="多发单收"><a href="#多发单收" class="headerlink" title="多发单收"></a>多发单收</h4><p>标准库提供了通道<code>std::sync::mpsc</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span></span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span></span><br><span class="line">        <span class="comment">// tx.send(Some(1)).unwrap()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中接收子线程发送的消息并输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">receive <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="不阻塞的-try-recv-方法"><a href="#不阻塞的-try-recv-方法" class="headerlink" title="不阻塞的 try_recv 方法"></a>不阻塞的 <code>try_recv</code> 方法</h4><p>该方法并<strong>不会阻塞线程</strong>，当通道中没有消息时，它会立刻返回一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">try_recv</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">receive <span class="title function_ invoke__">Err</span>(empty)</span><br></pre></td></tr></table></figure><h4 id="具有所有权的数据"><a href="#具有所有权的数据" class="headerlink" title="具有所有权的数据"></a>具有所有权的数据</h4><p>使用通道来传输数据，一样要遵循 Rust 的所有权规则：</p><ul><li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li><li>若值没有实现<code>Copy</code>，则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;我，飞走咯!&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;val is &#123;&#125;&quot;</span>, s); <span class="comment">// value moved here</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环接收数据"><a href="#循环接收数据" class="headerlink" title="循环接收数据"></a>循环接收数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多发送者"><a href="#多发送者" class="headerlink" title="多发送者"></a>多发送者</h4><p>子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from raw tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx1.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from cloned tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><p><code>FIFO</code> 原则</p><h4 id="同步-amp-异步通道"><a href="#同步-amp-异步通道" class="headerlink" title="同步 &amp; 异步通道"></a>同步 &amp; 异步通道</h4><h5 id="异步通道"><a href="#异步通道" class="headerlink" title="异步通道"></a>异步通道</h5><p>无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async channel</span></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之前&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之后&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">睡眠之前</span><br><span class="line">发送之前</span><br><span class="line">发送之后</span><br><span class="line">睡眠之后</span><br><span class="line">receive <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="同步通道"><a href="#同步通道" class="headerlink" title="同步通道"></a>同步通道</h5><p>同步通道<strong>发送消息是阻塞的，只有在消息被接收后才解除阻塞</strong>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之前&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之后&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">睡眠之前</span><br><span class="line">发送之前</span><br><span class="line">睡眠之后</span><br><span class="line">receive <span class="number">1</span></span><br><span class="line">发送之后</span><br></pre></td></tr></table></figure><h5 id="消息缓存"><a href="#消息缓存" class="headerlink" title="消息缓存"></a>消息缓存</h5><p>通过创建通道时传递参数<code>mpsc::sync_channel(N);</code> N，来设置缓存大小。</p><h4 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h4><p><strong>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</strong>。</p><h4 id="传输多种类型"><a href="#传输多种类型" class="headerlink" title="传输多种类型"></a>传输多种类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;<span class="keyword">self</span>, Receiver, Sender&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Apple</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Orange</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx): (Sender&lt;Fruit&gt;, Receiver&lt;Fruit&gt;) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Orange</span>(<span class="string">&quot;sweet&quot;</span>.<span class="title function_ invoke__">to_string</span>())).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Apple</span>(<span class="number">2</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">            Fruit::<span class="title function_ invoke__">Apple</span>(count) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;received &#123;&#125; apples&quot;</span>, count),</span><br><span class="line">            Fruit::<span class="title function_ invoke__">Orange</span>(flavor) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;received &#123;&#125; oranges&quot;</span>, flavor),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">received sweet oranges</span><br><span class="line">received <span class="number">2</span> apples</span><br></pre></td></tr></table></figure><h3 id="3-6-4-线程同步：锁、Condvar、信号量"><a href="#3-6-4-线程同步：锁、Condvar、信号量" class="headerlink" title="3.6.4 线程同步：锁、Condvar、信号量"></a>3.6.4 线程同步：锁、Condvar、信号量</h3><h4 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 <code>Mutex</code></h4><h5 id="单线程中使用-Mutex"><a href="#单线程中使用-Mutex" class="headerlink" title="单线程中使用 Mutex"></a>单线程中使用 <code>Mutex</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取锁，然后deref为`m`的引用</span></span><br><span class="line">        <span class="comment">// lock返回的是Result</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 锁自动被drop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">m = Mutex &#123; data: <span class="number">6</span>, poisoned: <span class="literal">false</span>, .. &#125;</span><br></pre></td></tr></table></figure><h5 id="多线程中使用-Mutex"><a href="#多线程中使用-Mutex" class="headerlink" title="多线程中使用 Mutex"></a>多线程中使用 <code>Mutex</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="type">Result</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure><h5 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h5><p>简单总结下：<code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutext&lt;T&gt;</code>用于多线程内部可变性。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="单线程死锁"><a href="#单线程死锁" class="headerlink" title="单线程死锁"></a>单线程死锁</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d1</span> = data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d2</span> = data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125; <span class="comment">// d1锁在此处释放</span></span><br></pre></td></tr></table></figure><h5 id="多线程死锁"><a href="#多线程死锁" class="headerlink" title="多线程死锁"></a>多线程死锁</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::sleep;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;Mutex, MutexGuard&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MUTEX1: Mutex&lt;<span class="type">i64</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MUTEX2: Mutex&lt;<span class="type">i64</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 存放子线程的句柄</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">children</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i_thread</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span> &#123;</span><br><span class="line">        children.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 线程1</span></span><br><span class="line">                <span class="keyword">if</span> i_thread % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 锁住MUTEX1</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">guard</span>: MutexGuard&lt;<span class="type">i64</span>&gt; = MUTEX1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span></span><br><span class="line">                    <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 去锁MUTEX2</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">guard</span> = MUTEX2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="comment">// 线程2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 锁住MUTEX2</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_guard</span> = MUTEX2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_guard</span> = MUTEX1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等子线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">child</span> <span class="keyword">in</span> children &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = child.<span class="title function_ invoke__">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;死锁没有发生&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a><code>try_lock</code></h5><p> <code>try_lock</code>会<strong>尝试</strong>去获取一次锁，如果无法获取会返回一个错误，因此<strong>不会发生阻塞</strong>。</p><h4 id="读写锁-RwLock"><a href="#读写锁-RwLock" class="headerlink" title="读写锁 RwLock"></a>读写锁 <code>RwLock</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::RwLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间允许多个读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r1, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r2, <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="comment">// 读锁在此处被drop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间只允许一个写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = lock.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *w += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*w, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下代码会panic，因为读和写不允许同时存在</span></span><br><span class="line">        <span class="comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span></span><br><span class="line">        <span class="comment">// let r1 = lock.read();</span></span><br><span class="line">        <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span></span><br><span class="line">    &#125;<span class="comment">// 写锁在此处被drop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单总结下<code>RwLock</code>:</p><ol><li>同时允许多个读，但最多只能有一个写</li><li>读和写不能同时存在</li><li>读可以使用<code>read</code>、<code>try_read</code>，写<code>write</code>、<code>try_write</code>, 在实际项目中，<code>try_xxx</code>会安全的多</li></ol><h4 id="条件变量（Condvar）控制线程同步"><a href="#条件变量（Condvar）控制线程同步" class="headerlink" title="条件变量（Condvar）控制线程同步"></a>条件变量（Condvar）控制线程同步</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc,Mutex,Condvar&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;spawn,sleep&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flag</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cond</span> = Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cflag</span> = flag.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ccond</span> = cond.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hdl</span> = <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = &#123; *cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> !m &#123;</span><br><span class="line">                m = *ccond.<span class="title function_ invoke__">wait</span>(cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                m = <span class="literal">false</span>;</span><br><span class="line">                *cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            counter += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        *flag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() = <span class="literal">true</span>;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter &gt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;outside counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        cond.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    hdl.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">outside counter: <span class="number">1</span></span><br><span class="line">inner counter: <span class="number">1</span></span><br><span class="line">outside counter: <span class="number">2</span></span><br><span class="line">inner counter: <span class="number">2</span></span><br><span class="line">outside counter: <span class="number">3</span></span><br><span class="line">inner counter: <span class="number">3</span></span><br><span class="line">Mutex &#123; data: <span class="literal">true</span>, poisoned: <span class="literal">false</span>, .. &#125;</span><br></pre></td></tr></table></figure><h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 <code>Semaphore</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semaphore</span> = Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">join_handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">permit</span> = semaphore.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">acquire_owned</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        join_handles.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 在这里执行任务...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(permit);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> join_handles &#123;</span><br><span class="line">        handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-5-线程同步：Atomic-原子操作与内存顺序"><a href="#3-6-5-线程同步：Atomic-原子操作与内存顺序" class="headerlink" title="3.6.5 线程同步：Atomic 原子操作与内存顺序"></a>3.6.5 线程同步：<code>Atomic</code> 原子操作与内存顺序</h3><h4 id="使用-Atomic-作为全局变量"><a href="#使用-Atomic-作为全局变量" class="headerlink" title="使用 Atomic 作为全局变量"></a>使用 <code>Atomic</code> 作为全局变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Sub;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N_TIMES: <span class="type">u64</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> N_THREADS: <span class="type">usize</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> R: AtomicU64 = AtomicU64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_n_times</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            R.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">threads</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(N_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..N_THREADS &#123;</span><br><span class="line">        threads.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">add_n_times</span>(N_TIMES));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">thread</span> <span class="keyword">in</span> threads &#123;</span><br><span class="line">        thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(N_TIMES * N_THREADS <span class="keyword">as</span> <span class="type">u64</span>, R.<span class="title function_ invoke__">load</span>(Ordering::Relaxed));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,Instant::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">sub</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p><ul><li>代码中的先后顺序</li><li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li><li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li></ul><h5 id="限定内存顺序的5个规则"><a href="#限定内存顺序的5个规则" class="headerlink" title="限定内存顺序的5个规则"></a>限定内存顺序的5个规则</h5><p><code>Ordering</code> 枚举有 5 个成员:</p><ul><li><strong>Relaxed</strong>， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序</li><li><strong>Release 释放</strong>，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li><li><strong>Acquire 获取</strong>, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和<code>Release</code>在不同线程中联合使用</li><li><strong>AcqRel</strong>, 是 <em>Acquire</em> 和 <em>Release</em> 的结合，同时拥有它们俩提供的保证。比如你要对一个 <code>atomic</code> 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li><li><strong>SeqCst 顺序一致性</strong>， <code>SeqCst</code>就像是<code>AcqRel</code>的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到<code>SeqCst</code>的原子操作，线程中该<code>SeqCst</code>操作前的数据操作绝对不会被重新排在该<code>SeqCst</code>操作之后，且该<code>SeqCst</code>操作后的数据操作也绝对不会被重新排在<code>SeqCst</code>操作前。</li></ul><h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        DATA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    READY.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">producer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            DATA = <span class="number">100</span>; <span class="comment">// A</span></span><br><span class="line">        &#125;</span><br><span class="line">        READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release); <span class="comment">// B: 内存屏障 ↑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">consumer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Ordering::Acquire) &#123;&#125; <span class="comment">// C: 内存屏障 ↓</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">100</span>, <span class="keyword">unsafe</span> &#123; DATA &#125;); <span class="comment">// D</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_producer</span> = <span class="title function_ invoke__">producer</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_consumer</span> = <span class="title function_ invoke__">consumer</span>();</span><br><span class="line"></span><br><span class="line">        t_producer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        t_consumer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程使用-Atomic"><a href="#多线程使用-Atomic" class="headerlink" title="多线程使用 Atomic"></a>多线程使用 <code>Atomic</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::&#123;hint, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;spinlock);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        spinlock_clone.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待其它线程释放锁</span></span><br><span class="line">    <span class="keyword">while</span> spinlock.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="number">0</span> &#123;</span><br><span class="line">        hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(panic) = thread.<span class="title function_ invoke__">join</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-6-基于-Send-和-Sync-的线程安全"><a href="#3-6-6-基于-Send-和-Sync-的线程安全" class="headerlink" title="3.6.6 基于 Send 和 Sync 的线程安全"></a>3.6.6 基于 <code>Send</code> 和 <code>Sync</code> 的线程安全</h3><h4 id="无法用于多线程的-Rc"><a href="#无法用于多线程的-Rc" class="headerlink" title="无法用于多线程的 Rc"></a>无法用于多线程的 <code>Rc</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Rc-和-Arc-源码对比"><a href="#Rc-和-Arc-源码对比" class="headerlink" title="Rc 和 Arc 源码对比"></a><code>Rc</code> 和 <code>Arc</code> 源码对比</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc源码片段</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc源码片段</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p><code>Send</code>和<code>Sync</code>是在线程间安全使用一个值的关键。</p><h4 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a><code>Send</code> 和 <code>Sync</code></h4><p><code>Send</code>和<code>Sync</code>它们只是标记特征(marker trait，该特征未定义任何行为), 它们的作用：</p><ul><li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权</li><li>实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li></ul><h4 id="实现-Send-和-Sync-的类型"><a href="#实现-Send-和-Sync-的类型" class="headerlink" title="实现 Send 和 Sync 的类型"></a>实现 <code>Send</code> 和 <code>Sync</code> 的类型</h4><p>在 Rust 中，几乎所有类型都默认实现了<code>Send</code>和<code>Sync</code>，而且由于这两个特征都是可自动派生的特征(通过<code>derive</code>派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了<code>Send</code>或者<code>Sync</code>，那么它就自动实现了<code>Send</code>或<code>Sync</code>。</p><p>以下情况除外：</p><ul><li>裸指针两者都没实现，因为它本身就没有任何安全保证</li><li><code>UnsafeCell</code>不是<code>Sync</code>，因此<code>Cell</code>和<code>RefCell</code>也不是</li><li><code>Rc</code>两者都没实现(因为内部的引用计数器不是线程安全的)</li></ul><h4 id="裸指针实现-Send"><a href="#裸指针实现-Send" class="headerlink" title="裸指针实现 Send"></a>裸指针实现 <code>Send</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="裸指针实现-Sync"><a href="#裸指针实现-Sync" class="headerlink" title="裸指针实现 Sync"></a>裸指针实现 <code>Sync</code></h4><p><a href="https://course.rs/advance/concurrency-with-threads/send-sync.html#%E4%B8%BA%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0sync">https://course.rs/advance/concurrency-with-threads/send-sync.html#%E4%B8%BA%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0sync</a></p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol><li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权, 实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li><li>绝大部分类型都实现了<code>Send</code>和<code>Sync</code>，常见的未实现的有：裸指针、<code>Cell</code>、<code>RefCell</code>、<code>Rc</code> 等</li><li>可以为自定义类型实现<code>Send</code>和<code>Sync</code>，但是需要<code>unsafe</code>代码块</li><li>可以为部分 Rust 中的类型实现<code>Send</code>、<code>Sync</code>，但是需要使用<code>newtype</code>，例如文中的裸指针例子</li></ol><h2 id="3-7-全局变量"><a href="#3-7-全局变量" class="headerlink" title="3.7 全局变量"></a>3.7 全局变量</h2><h3 id="编译期初始化"><a href="#编译期初始化" class="headerlink" title="编译期初始化"></a>编译期初始化</h3><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_ID: <span class="type">usize</span> =  <span class="type">usize</span>::MAX / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;用户ID允许的最大值是&#123;&#125;&quot;</span>,MAX_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常量与普通变量的区别</strong></p><ul><li>关键字是<code>const</code>而不是<code>let</code></li><li>定义常量必须指明类型（如 i32）不能省略</li><li>定义常量时变量的命名规则一般是全部大写</li><li>常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</li><li>常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</li><li>对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</li></ul><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> REQUEST_RECV: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        REQUEST_RECV += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(REQUEST_RECV, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 要求必须使用<code>unsafe</code>语句块才能访问和修改<code>static</code>变量。</p><p><strong>静态变量和常量的区别</strong></p><ul><li>静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址</li><li>存储在静态变量中的值必须要实现 Sync trait</li></ul><h4 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h4><p>想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">static</span> REQUEST_RECV: AtomicUsize  = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        REQUEST_RECV.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;当前用户请求数&#123;:?&#125;&quot;</span>,REQUEST_RECV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行期初始化"><a href="#运行期初始化" class="headerlink" title="运行期初始化"></a>运行期初始化</h3><p>静态初始化的问题在于：无法利用函数进行静态初始化。</p><h4 id="lazy-static"><a href="#lazy-static" class="headerlink" title="lazy_static"></a><code>lazy_static</code></h4><p><code>lazy_static</code>允许我们在运行期初始化静态变量。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HASHMAP: HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 首次访问`HASHMAP`的同时对其进行初始化</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续的访问仅仅获取值，再不会进行任何初始化操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `1` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Box-leak-1"><a href="#Box-leak-1" class="headerlink" title="Box::leak"></a><code>Box::leak</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        a: <span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        b: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 将`c`从内存中泄漏，变成`&#x27;static`生命周期</span></span><br><span class="line">        CONFIG = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(c));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从函数中返回全局变量"><a href="#从函数中返回全局变量" class="headerlink" title="从函数中返回全局变量"></a>从函数中返回全局变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">init</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Config&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        a: <span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        b: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        CONFIG = <span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准库的-OnceCall"><a href="#标准库的-OnceCall" class="headerlink" title="标准库的 OnceCall"></a>标准库的 <code>OnceCall</code></h3><p><code>Rust</code> 标准库中提供 <code>lazy::OnceCell</code> 和 <code>lazy::SyncOnceCell</code> 两种 <code>Cell</code>，前者用于单线程，后者用于多线程，它们用来存储堆上的信息，并且具有最多只能赋值一次的特性。</p><h2 id="3-8-错误处理"><a href="#3-8-错误处理" class="headerlink" title="3.8 错误处理"></a>3.8 错误处理</h2><h3 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h3><h4 id="or-amp-and"><a href="#or-amp-and" class="headerlink" title="or() &amp; and()"></a><code>or()</code> &amp; <code>and()</code></h4><ul><li><code>or()</code>，表达式按照顺序求值，若任何一个表达式的结果是 <code>Some</code> 或 <code>Ok</code>，则该值会立刻返回</li><li><code>and()</code>，若两个表达式的结果都是 <code>Some</code> 或 <code>Ok</code>，则<strong>第二个表达式中的值被返回</strong>。若任何一个的结果是 <code>None</code> 或 <code>Err</code> ，则立刻返回。</li></ul><h4 id="or-else-amp-and-then"><a href="#or-else-amp-and-then" class="headerlink" title="or_else() &amp; and_then()"></a><code>or_else()</code> &amp; <code>and_then()</code></h4><p>跟 <code>or()</code> 和 <code>and()</code> 类似，唯一的区别在于，它们的第二个表达式是一个闭包。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// or_else with Option</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_some</span> = || <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some2&quot;</span>); <span class="comment">// 类似于: let fn_some = || -&gt; Option&lt;&amp;str&gt; &#123; Some(&quot;some2&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_none</span> = || <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">or_else</span>(fn_some), s1);  <span class="comment">// Some1 or_else Some2 = Some1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">or_else</span>(fn_none), s1);  <span class="comment">// Some or_else None = Some</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">or_else</span>(fn_some), s2);   <span class="comment">// None or_else Some = Some</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">or_else</span>(fn_none), <span class="literal">None</span>); <span class="comment">// None1 or_else None2 = None2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// or_else with Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o1</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o2</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_ok</span> = |_| <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok2&quot;</span>); <span class="comment">// 类似于: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; &#123; Ok(&quot;ok2&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e1</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e2</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_err</span> = |_| <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(o1.<span class="title function_ invoke__">or_else</span>(fn_ok), o1);  <span class="comment">// Ok1 or_else Ok2 = Ok1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(o1.<span class="title function_ invoke__">or_else</span>(fn_err), o1); <span class="comment">// Ok or_else Err = Ok</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(e1.<span class="title function_ invoke__">or_else</span>(fn_ok), o2);  <span class="comment">// Err or_else Ok = Ok</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(e1.<span class="title function_ invoke__">or_else</span>(fn_err), e2); <span class="comment">// Err1 or_else Err2 = Err2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h4><p><code>filter</code> 用于对 <code>Option</code> 进行过滤：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_is_even</span> = |x: &amp;<span class="type">i8</span>| x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">filter</span>(fn_is_even), n);  <span class="comment">// Some(3) -&gt; 3 is not even -&gt; None</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s2.<span class="title function_ invoke__">filter</span>(fn_is_even), s2); <span class="comment">// Some(6) -&gt; 6 is even -&gt; Some(6)</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">filter</span>(fn_is_even), n);   <span class="comment">// None -&gt; no value -&gt; None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map-amp-map-err"><a href="#map-amp-map-err" class="headerlink" title="map() &amp; map_err()"></a><code>map()</code> &amp; <code>map_err()</code></h4><p><code>map</code> 可以将 <code>Some</code> 或 <code>Ok</code> 中的值映射为另一个，<code>map_err()</code>用来将 <code>Err</code> 中的值进行改变。</p><h4 id="map-or-amp-map-or-else"><a href="#map-or-amp-map-or-else" class="headerlink" title="map_or() &amp; map_or_else()"></a><code>map_or()</code> &amp; <code>map_or_else()</code></h4><p><code>map_or</code> 在 <code>map</code> 的基础上提供了一个默认值，<code>map_or_else()</code> 通过一个闭包来提供默认值。</p><h4 id="ok-or-amp-ok-or-else"><a href="#ok-or-amp-ok-or-else" class="headerlink" title="ok_or() &amp; ok_or_else()"></a><code>ok_or()</code> &amp; <code>ok_or_else()</code></h4><p>可以将 <code>Option</code> 类型转换为 <code>Result</code> 类型。其中 <code>ok_or</code> 接收一个默认的 <code>Err</code> 参数，而 <code>ok_or_else</code> 接收一个闭包作为 <code>Err</code> 参数。</p><h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>自定义类型实现 <code>std::error::Error</code> 特征后，该类型就可以作为 <code>Err</code> 来使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    code: <span class="type">usize</span>,</span><br><span class="line">    message: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据错误码显示不同的错误信息</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">err_msg</span> = <span class="keyword">match</span> <span class="keyword">self</span>.code &#123;</span><br><span class="line">            <span class="number">404</span> =&gt; <span class="string">&quot;Sorry, Can not find the Page!&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="string">&quot;Sorry, something is wrong! Please Try Again!&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, err_msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;AppError &#123;&#123; code: &#123;&#125;, message: &#123;&#125; &#125;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.code, <span class="keyword">self</span>.message</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">produce_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(AppError &#123;</span><br><span class="line">        code: <span class="number">404</span>,</span><br><span class="line">        message: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Page not found&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">produce_error</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 抱歉，未找到指定的页面!</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">produce_error</span>()); <span class="comment">// Err(AppError &#123; code: 404, message: Page not found &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, <span class="title function_ invoke__">produce_error</span>());</span><br><span class="line">    <span class="comment">// Err(</span></span><br><span class="line">    <span class="comment">//     AppError &#123; code: 404, message: Page not found &#125;</span></span><br><span class="line">    <span class="comment">// )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="错误转换-From-特征"><a href="#错误转换-From-特征" class="headerlink" title="错误转换 From 特征"></a>错误转换 <code>From</code> 特征</h4><p>将其它的错误类型转换成自定义的错误类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    kind: <span class="type">String</span>,    <span class="comment">// 错误类型</span></span><br><span class="line">    message: <span class="type">String</span>, <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 AppError 实现 std::convert::From 特征，由于 From 包含在 std::prelude 中，因此可以直接简化引入。</span></span><br><span class="line"><span class="comment">// 实现 From&lt;io::Error&gt; 意味着我们可以将 io::Error 错误转换成自定义的 AppError 错误</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;io&quot;</span>),</span><br><span class="line">            message: error.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Error: AppError &#123; kind: <span class="string">&quot;io&quot;</span>, message: <span class="string">&quot;No such file or directory (os error 2)&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="归一化不同错误类型"><a href="#归一化不同错误类型" class="headerlink" title="归一化不同错误类型"></a>归一化不同错误类型</h3><p>要在一个函数中返回不同的错误，要实现这个目的有三种方式:</p><ul><li>使用特征对象 <code>Box&lt;dyn Error&gt;</code></li><li>自定义错误类型</li><li>使用 <code>thiserror</code></li></ul><h4 id="Box-lt-dyn-Error-gt"><a href="#Box-lt-dyn-Error-gt" class="headerlink" title="Box&lt;dyn Error&gt;"></a><code>Box&lt;dyn Error&gt;</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Result</code> 实际上不会限制错误的类型，也就是一个类型就算不实现 <code>Error</code> 特征，它依然可以在 <code>Result&lt;T, E&gt;</code> 中作为 <code>E</code> 来使用，此时这种特征对象的解决方案就无能为力了。</p><h4 id="自定义错误类型-1"><a href="#自定义错误类型-1" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  EnvironmentVariableNotFound,</span><br><span class="line">  <span class="title function_ invoke__">IOError</span>(std::io::Error),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;std::env::VarError&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">from</span>(_: std::env::VarError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span>::EnvironmentVariableNotFound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;std::io::Error&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">from</span>(value: std::io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">IOError</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::error::Error <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      MyError::EnvironmentVariableNotFound =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Environment variable not found&quot;</span>),</span><br><span class="line">      MyError::<span class="title function_ invoke__">IOError</span>(err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO Error: &#123;&#125;&quot;</span>, err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简化错误处理"><a href="#简化错误处理" class="headerlink" title="简化错误处理"></a>简化错误处理</h3><h4 id="thiserror"><a href="#thiserror" class="headerlink" title="thiserror"></a><code>thiserror</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(thiserror::Error, Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="meta">#[error(<span class="string">&quot;Environment variable not found&quot;</span>)]</span></span><br><span class="line">  <span class="title function_ invoke__">EnvironmentVariableNotFound</span>(<span class="meta">#[from]</span> std::env::VarError),</span><br><span class="line">  <span class="meta">#[error(transparent)]</span></span><br><span class="line">  <span class="title function_ invoke__">IOError</span>(<span class="meta">#[from]</span> std::io::Error),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-Unsafe-Rust"><a href="#3-9-Unsafe-Rust" class="headerlink" title="3.9 Unsafe Rust"></a>3.9 <code>Unsafe Rust</code></h2><h3 id="Unsafe-出现的原因"><a href="#Unsafe-出现的原因" class="headerlink" title="Unsafe 出现的原因"></a><code>Unsafe</code> 出现的原因</h3><ul><li>绕过编译器编译检查</li><li>特定任务需要</li></ul><h3 id="Unsafe-的作用"><a href="#Unsafe-的作用" class="headerlink" title="Unsafe 的作用"></a><code>Unsafe</code> 的作用</h3><ul><li>解引用裸指针</li><li>调用一个 <code>unsafe</code> 或外部的函数</li><li>访问或修改一个可变的<a href="https://course.rs/advance/global-variable.html#静态变量">静态变量</a></li><li>实现一个 <code>unsafe</code> 特征</li><li>访问 <code>union</code> 中的字段</li></ul><h3 id="3-9-1-五种作用"><a href="#3-9-1-五种作用" class="headerlink" title="3.9.1 五种作用"></a>3.9.1 五种作用</h3><h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p>我们已经学过三种类似指针的概念：引用、智能指针和裸指针。与前两者不同，裸指针：</p><ul><li>可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</li><li>并不能保证指向合法的内存</li><li>可以是 <code>null</code></li><li>没有实现任何自动的回收 (drop)</li></ul><h5 id="基于引用创建裸指针"><a href="#基于引用创建裸指针" class="headerlink" title="基于引用创建裸指针"></a>基于引用创建裸指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br></pre></td></tr></table></figure><p><strong>创建裸指针是安全的行为，而解引用裸指针才是不安全的行为</strong> :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基于内存地址创建裸指针"><a href="#基于内存地址创建裸指针" class="headerlink" title="基于内存地址创建裸指针"></a>基于内存地址创建裸指针</h5><h5 id="使用-解引用"><a href="#使用-解引用" class="headerlink" title="使用 * 解引用"></a>使用 * 解引用</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;a;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="基于智能指针创建裸指针"><a href="#基于智能指针创建裸指针" class="headerlink" title="基于智能指针创建裸指针"></a>基于智能指针创建裸指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Box</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 需要先解引用a</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;*a;</span><br><span class="line">    <span class="comment">// 使用 into_raw 来创建</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: *<span class="keyword">const</span> <span class="type">i32</span> = <span class="type">Box</span>::<span class="title function_ invoke__">into_raw</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 <code>unsafe</code> 函数或方法</h4><p>它需要使用 <code>unsafe fn</code> 来进行定义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a>FFI</h4><p>可以用来与其它语言进行交互</p><h5 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h5><h4 id="实现-unsafe-特征"><a href="#实现-unsafe-特征" class="headerlink" title="实现 unsafe 特征"></a>实现 <code>unsafe</code> 特征</h4><p>通过 <code>unsafe impl</code> 的使用，我们告诉编译器：相应的正确性由我们自己来保证。</p><h4 id="访问-union-中的字段"><a href="#访问-union-中的字段" class="headerlink" title="访问 union 中的字段"></a>访问 <code>union</code> 中的字段</h4><p><code>union</code> 所有字段共享一个存储空间</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Rust基础入门（二）</title>
      <link href="/2022/03/5fff10cbfe3b.html"/>
      <url>/2022/03/5fff10cbfe3b.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-8-泛型与特征"><a href="#2-8-泛型与特征" class="headerlink" title="2.8 泛型与特征"></a>2.8 泛型与特征</h2><h3 id="2-8-1-泛型-Generics"><a href="#2-8-1-泛型-Generics" class="headerlink" title="2.8.1 泛型 Generics"></a>2.8.1 泛型 <code>Generics</code></h3><h4 id="泛型详解"><a href="#泛型详解" class="headerlink" title="泛型详解"></a>泛型详解</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">2i8</span>, <span class="number">3i8</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(<span class="number">1.23</span>, <span class="number">1.23</span>));</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">add <span class="type">i8</span>: <span class="number">5</span></span><br><span class="line">add <span class="type">i32</span>: <span class="number">50</span></span><br><span class="line">add <span class="type">f64</span>: <span class="number">2.46</span></span><br></pre></td></tr></table></figure><p>代码中 <code>T</code> 就是<strong>泛型参数</strong></p><p>使用泛型参数，必需在使用前对其进行声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解这个函数定义：函数 <code>largest</code> 有泛型类型 <code>T</code>，它有个参数 <code>list</code>，其类型是元素为 <code>T</code> 的数组切片，最后，该函数返回值的类型也是 <code>T</code>。</p><h4 id="结构体中使用泛型"><a href="#结构体中使用泛型" class="headerlink" title="结构体中使用泛型"></a>结构体中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">float</span> = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;integer Point: &#123;:?&#125;&quot;</span>, integer);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;float Point: &#123;:?&#125;&quot;</span>, float);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">integer Point: Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;</span><br><span class="line">float Point: Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;</span><br></pre></td></tr></table></figure><p>有两点需要特别的注意：</p><ul><li><strong>提前声明</strong>，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明 <code>Point&lt;T&gt;</code>，接着就可以在结构体的字段类型中使用 <code>T</code> 来替代具体的类型</li><li><strong>x 和 y 是相同的类型</strong></li></ul><h4 id="枚举中使用泛型"><a href="#枚举中使用泛型" class="headerlink" title="枚举中使用泛型"></a>枚举中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">  <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法中使用泛型"><a href="#方法中使用泛型" class="headerlink" title="方法中使用泛型"></a>方法中使用泛型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">p.x = <span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="为具体的泛型类型实现方法"><a href="#为具体的泛型类型实现方法" class="headerlink" title="为具体的泛型类型实现方法"></a>为具体的泛型类型实现方法</h5><p>对于 <code>Point&lt;T&gt;</code> 类型，还能针对特定的具体类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码意味着 <code>Point&lt;f32&gt;</code> 类型会有一个方法 <code>distance_from_origin</code>，而其他 <code>T</code> 不是 <code>f32</code> 类型的 <code>Point&lt;T&gt;</code>实例则没有定义此方法。</p><h4 id="Const-泛型"><a href="#Const-泛型" class="headerlink" title="Const 泛型"></a><code>Const</code> 泛型</h4><p>在<a href="https://course.rs/basic/compound-type/array.html">数组</a>那节，有提到过很重要的一点：<code>[i32; 2]</code> 和 <code>[i32; 3]</code> 是不同的数组类型。</p><p>Example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: [<span class="type">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">57</span>:<span class="number">19</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">57</span> |     <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">   |                   ^^^ expected an array with a fixed size of <span class="number">3</span> elements, found one with <span class="number">2</span> elements</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `generics-demo` due to previous error</span><br></pre></td></tr></table></figure><p>让我们修改代码，让 <code>display_array</code> 能打印任意长度的 <code>i32</code> 数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>(arr: &amp;[<span class="type">i32</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>;<span class="number">2</span>] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，将 <code>i32</code> 改成所有类型的数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>&gt;(arr: &amp;[T]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>;<span class="number">2</span>] = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(&amp;arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>const</code> 泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">display_array</span>&lt;T: std::fmt::<span class="built_in">Debug</span>, <span class="keyword">const</span> N: <span class="type">usize</span>&gt;(arr: [T; N]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_ invoke__">display_array</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><code>N</code> 就是 const 泛型，定义的语法是 <code>const N: usize</code>，表示 const 泛型 <code>N</code> ，它基于的值类型是 <code>usize</code></p><h4 id="泛型的性能"><a href="#泛型的性能" class="headerlink" title="泛型的性能"></a>泛型的性能</h4><p>在 Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。但是Rust 是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p><h3 id="2-8-2-特征-Trait"><a href="#2-8-2-特征-Trait" class="headerlink" title="2.8.2 特征 Trait"></a>2.8.2 特征 <code>Trait</code></h3><p>特征很类似接口。</p><p>特征定义了<strong>一个可以被共享的行为，只要实现了特征，你就能使用该行为</strong>。</p><h4 id="定义特征"><a href="#定义特征" class="headerlink" title="定义特征"></a>定义特征</h4><p><strong>定义特征</strong>是把一些方法组合在一起，目的是定义一个实现某些目标所必需的行为的集合。</p><p>例如，我们现在有文章 <code>Post</code> 和微博 <code>Weibo</code> 两种内容载体，而我们想对相应的内容进行总结，也就是无论是文章内容，还是微博内容，都可以在某个时间点进行总结，那么总结这个行为就是共享的，因此可以用特征来定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用 <code>trait</code> 关键字来声明一个特征，<code>Summary</code> 是特征名。在大括号中定义了该特征的所有方法，在这个例子中是： <code>fn summarize(&amp;self) -&gt; String</code>。</p><p>特征只定义行为看起来是什么样的，而不定义行为具体是怎么样的。因此，我们只定义特征方法的签名，而不进行实现，此时方法签名结尾是 <code>;</code>，而不是一个 <code>&#123;&#125;</code>。</p><h4 id="为类型实现特征"><a href="#为类型实现特征" class="headerlink" title="为类型实现特征"></a>为类型实现特征</h4><p>特征只定义行为看起来是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,   <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,  <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>, <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="keyword">self</span>.title, <span class="keyword">self</span>.author)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post &#123;</span><br><span class="line">        title: <span class="string">&quot;Rust语言简介&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        author: <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Rust棒极了!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">weibo</span> = Weibo &#123;</span><br><span class="line">        username: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;好像微博没Tweet好用&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">文章Rust语言简介, 作者是Sunface</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure><h5 id="特征定义与实现的位置（孤儿规则）"><a href="#特征定义与实现的位置（孤儿规则）" class="headerlink" title="特征定义与实现的位置（孤儿规则）"></a>特征定义与实现的位置（孤儿规则）</h5><p>将 <code>Summary</code> 定义成了 <code>pub</code> 公开的。这样，如果他人想要使用我们的 <code>Summary</code> 特征，则可以引入到他们的包中，然后再进行实现。</p><p>关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 至少有一个是在当前作用域中定义的！</strong>。</p><p>该规则被称为<strong>孤儿规则</strong>，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。</p><blockquote><p>  例如我们可以为上面的 <code>Post</code> 类型实现标准库中的 <code>Display</code> 特征，这是因为 <code>Post</code> 类型定义在当前的作用域中。同时，我们也可以在当前包中为 <code>String</code> 类型实现 <code>Summary</code> 特征，因为 <code>Summary</code> 定义在当前作用域中。</p></blockquote><h5 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h5><p>在特征中定义具有<strong>默认实现</strong>的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Post</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> title: <span class="type">String</span>,   <span class="comment">// 标题</span></span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,  <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>, <span class="comment">// 内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Post</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">post</span> = Post &#123;</span><br><span class="line">        title: <span class="string">&quot;Rust语言简介&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        author: <span class="string">&quot;Sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;Rust棒极了!&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">weibo</span> = Weibo &#123;</span><br><span class="line">        username: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;好像微博没Tweet好用&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, post.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">(Read more...)</span><br><span class="line">sunface发表了微博好像微博没Tweet好用</span><br></pre></td></tr></table></figure><p>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现。</p><p>调整 <code>summary</code> 特征代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="keyword">self</span>.<span class="title function_ invoke__">summarize_author</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Weibo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize_author</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;@&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">weibo</span> = Weibo &#123;</span><br><span class="line">        username: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        content: <span class="string">&quot;好像微博没Tweet好用&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1 new weibo: &#123;&#125;&quot;</span>, weibo.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">1</span> new weibo: (Read more from @sunface...)</span><br></pre></td></tr></table></figure><h4 id="使用特征作为函数参数"><a href="#使用特征作为函数参数" class="headerlink" title="使用特征作为函数参数"></a>使用特征作为函数参数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何实现了 <code>Summary</code> 特征的类型作为该函数的参数。</p><h4 id="特征约束-trait-bound"><a href="#特征约束-trait-bound" class="headerlink" title="特征约束(trait bound)"></a>特征约束(trait bound)</h4><p>虽然 <code>impl Trait</code> 这种语法非常好理解，但是实际上它只是一个语法糖：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的完整书写形式如上所述，形如 <code>T: Summary</code> 被称为<strong>特征约束</strong>。</p><p> <code>T: Summary</code> 说明了所有参数 <code>T</code> 必须实现 <code>Summary</code> 特征。</p><h5 id="多重约束"><a href="#多重约束" class="headerlink" title="多重约束"></a>多重约束</h5><p>除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现 <code>Summary</code> 特征外，还可以让参数实现 <code>Display</code> 特征以控制它的格式化输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;(<span class="keyword">impl</span> <span class="title class_">Summary</span> + Display)) &#123;</span><br></pre></td></tr></table></figure><p>除了上述的语法糖形式，还能使用特征约束的形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这两个特征，就可以使用 <code>item.summarize</code> 方法，以及通过 <code>println!(&quot;&#123;&#125;&quot;, item)</code> 来格式化输出 <code>item</code>。</p><h5 id="Where-约束"><a href="#Where-约束" class="headerlink" title="Where 约束"></a>Where 约束</h5><p>当特征约束变得很多时，函数的签名将变得很复杂：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br></pre></td></tr></table></figure><p>我们需要对其做一些形式上的改进，通过 <code>where</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><h5 id="使用特征约束有条件地实现方法或特征"><a href="#使用特征约束有条件地实现方法或特征" class="headerlink" title="使用特征约束有条件地实现方法或特征"></a>使用特征约束有条件地实现方法或特征</h5><p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123;</span><br><span class="line">            x,</span><br><span class="line">            y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cmd_display</code> 方法，并不是所有的 <code>Pair&lt;T&gt;</code> 结构体对象都可以拥有，只有 <code>T</code> 同时实现了 <code>Display + PartialOrd</code> 的 <code>Pair&lt;T&gt;</code> 才可以拥有此方法。 该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过<strong>特征约束</strong>进行了约束。</p><p><strong>也可以有条件地实现特征</strong>, 例如，标准库为任何实现了 <code>Display</code> 特征的类型实现了 <code>ToString</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对任何实现了 <code>Display</code> 特征的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="number">3</span>.<span class="title function_ invoke__">to_string</span>();</span><br></pre></td></tr></table></figure><h4 id="函数返回中的-impl-Trait"><a href="#函数返回中的-impl-Trait" class="headerlink" title="函数返回中的 impl Trait"></a>函数返回中的 <code>impl Trait</code></h4><p>可以通过 <code>impl Trait</code> 来说明一个函数返回了一个类型，该类型实现了某个特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Weibo &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;m1 max太厉害了，电脑再也不会卡&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于 <code>returns_summarizable</code> 的调用者而言，他只知道返回了一个实现了 <code>Summary</code> 特征的对象，但是并不知道返回了一个具体的类型。</p><h4 id="通过-derive-派生特征"><a href="#通过-derive-派生特征" class="headerlink" title="通过 derive 派生特征"></a>通过 <code>derive</code> 派生特征</h4><p>在本书中，形如 <code>#[derive(Debug)]</code> 的代码已经出现了很多次，这种是一种特征派生语法，被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p><p>例如 <code>Debug</code> 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 <code>println!(&quot;&#123;:?&#125;&quot;, s)</code> 的形式打印该结构体的对象。</p><p>再如 <code>Copy</code> 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 <code>Copy</code> 特征，进而可以调用 <code>copy</code> 方法，进行自我复制。</p><p>总之，<code>derive</code> 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p><p>详细的 <code>derive</code> 列表参见<a href="https://course.rs/appendix/derive.html">附录-派生特征</a>。</p><h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><p>自定义类型 <code>+</code> 操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Point结构体派生Debug特征，用于格式化输出</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T: Add&lt;T, Output = T&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">//限制类型T必须实现了Add特征，否则无法进行+操作。</span></span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Add&lt;T, Output = T&gt;&gt; Add <span class="keyword">for</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span> = Point&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, p: Point&lt;T&gt;) <span class="punctuation">-&gt;</span> Point&lt;T&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + p.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + p.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>&lt;T: Add&lt;T, Output = T&gt;&gt;(a: T, b: T) <span class="punctuation">-&gt;</span> T &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span> = Point &#123;</span><br><span class="line">        x: <span class="number">1.1f32</span>,</span><br><span class="line">        y: <span class="number">1.1f32</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = Point &#123;</span><br><span class="line">        x: <span class="number">2.1f32</span>,</span><br><span class="line">        y: <span class="number">2.1f32</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(p1, p2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p3</span> = Point &#123; x: <span class="number">1i32</span>, y: <span class="number">1i32</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p4</span> = Point &#123; x: <span class="number">2i32</span>, y: <span class="number">2i32</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">add</span>(p3, p4));</span><br><span class="line">&#125;</span><br><span class="line">ouptut:</span><br><span class="line">Point &#123; x: <span class="number">3.1999998</span>, y: <span class="number">3.1999998</span> &#125;</span><br><span class="line">Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-3-特征对象"><a href="#2-8-3-特征对象" class="headerlink" title="2.8.3 特征对象"></a>2.8.3 特征对象</h3><p>在介绍特征对象之前，先来为之前的 UI 组件定义一个特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要组件实现了 <code>Draw</code> 特征，就可以调用 <code>draw</code> 方法来进行渲染。假设有一个 <code>Button</code> 和 <code>SelectBox</code> 组件实现了 <code>Draw</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> height: <span class="type">u32</span>,</span><br><span class="line">    <span class="keyword">pub</span> label: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 绘制按钮的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">    options: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">SelectBox</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 绘制SelectBox的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，还需要一个动态数组来存储这些 UI 对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>?</code> 吗？它的意思是：我们应该填入什么类型。</p><p>因为 <code>Button</code> 和 <code>SelectBox</code> 都实现了 <code>Draw</code> 特征，那我们是不是可以把 <code>Draw</code> 特征的对象作为类型，填入到数组中呢？答案是肯定的。</p><p><strong>特征对象</strong>指向实现了如 <code>Draw</code> 特征的类型的实例，也就是指向了 <code>Button</code> 或者 <code>SelectBox</code> 的实例，这种映射关系是存储在一张表中，可以在运行时通过特征对象找到具体调用的类型方法。</p><p>可以通过 <code>&amp;</code> 引用或者 <code>Box&lt;T&gt;</code> 智能指针的方式来创建特征对象:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">u8</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;u8: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">f64</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;f64: &#123;&#125;&quot;</span>, *<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw1</span>(x: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">draw2</span>(x: &amp;<span class="keyword">dyn</span> Draw) &#123;</span><br><span class="line">    x.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1.1f64</span>;</span><br><span class="line">    <span class="comment">// do_something(&amp;x);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">8u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(x));</span><br><span class="line">    <span class="title function_ invoke__">draw1</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(y));</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;x);</span><br><span class="line">    <span class="title function_ invoke__">draw2</span>(&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，有几个非常重要的点：</p><ul><li><code>draw1</code> 函数的参数是 <code>Box&lt;dyn Draw&gt;</code> 形式的特征对象，该特征对象是通过 <code>Box::new(x)</code> 的方式创建的</li><li><code>draw2</code> 函数的参数是 <code>&amp;dyn Draw</code> 形式的特征对象，该特征对象是通过 <code>&amp;x</code> 的方式创建的</li><li><code>dyn</code> 关键字只用在特征对象的类型声明上，在创建时无需使用 <code>dyn</code></li></ul><p>因此我们可以完善 <code>Screen</code> 组件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特征对象的动态分发"><a href="#特征对象的动态分发" class="headerlink" title="特征对象的动态分发"></a>特征对象的动态分发</h4><p>泛型是在编译期完成处理的：编译器会为每一个泛型参数对应的具体类型生成一份代码，这种方式是<strong>静态分发(static dispatch)</strong>，对性能无影响。</p><p>直到运行时，才能确定需要调用什么方法。</p><p>下面这张图很好的解释了静态分发 <code>Box&lt;T&gt;</code> 和动态分发 <code>Box&lt;dyn Trait&gt;</code> 的区别：</p><p><img src="https://s2.loli.net/2022/03/25/mkifRjYS7Hu9BnT.jpg" alt="img"></p><ul><li><strong>特征对象大小不固定</strong></li><li><strong>几乎总是使用特征对象的引用方式</strong><ul><li>特征对象引用类型的大小是固定的，它由两个指针组成（<code>ptr</code> 和 <code>vptr</code>）</li><li>一个指针 <code>ptr</code> 指向实现了特征 <code>Draw</code> 的具体类型的实例</li><li>另一个指针 <code>vptr</code> 指向一个虚表 <code>vtable</code>，<code>vtable</code> 中保存了类型 <code>Button</code> 或类型 <code>SelectBox</code> 的实例对于可以调用的实现于特征 <code>Draw</code> 的方法。当调用方法时，直接从 <code>vtable</code> 中找到方法并调用。</li></ul></li></ul><h4 id="Self-与-self"><a href="#Self-与-self" class="headerlink" title="Self 与 self"></a><code>Self</code> 与 <code>self</code></h4><p>在 Rust 中，有两个<code>self</code>，一个指代当前的实例对象，一个指代特征或者方法类型的别名：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="title function_ invoke__">clone</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">button</span> = Button;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">newb</span> = button.<span class="title function_ invoke__">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="特征对象的限制"><a href="#特征对象的限制" class="headerlink" title="特征对象的限制"></a>特征对象的限制</h4><p>所有特征都能拥有特征对象，只有对象安全的特征才行。当一个特征的所有方法都有如下属性时，它的对象才是安全的：</p><ul><li>方法的返回类型不能是 <code>Self</code></li><li>方法没有任何泛型参数</li></ul><h3 id="2-8-4-深入了解特征"><a href="#2-8-4-深入了解特征" class="headerlink" title="2.8.4 深入了解特征"></a>2.8.4 深入了解特征</h3><h4 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h4><p>关联类型是在特征定义的语句中，申明一个自定义类型，以此可以在特征方法签名中使用该类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Item</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">next</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="keyword">Self</span>::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Self</code> 用来指代当前调用者的具体类型，那么 <code>Self::Item</code> 就用来指代该类型实现中定义的 <code>Item</code> 类型</strong>。</p><h4 id="默认泛型类型参数"><a href="#默认泛型类型参数" class="headerlink" title="默认泛型类型参数"></a>默认泛型类型参数</h4><p>当使用泛型类型参数时，可以为其指定一个默认的具体类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Add</span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Output</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add</span>(<span class="keyword">self</span>, rhs: RHS) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它有一个泛型参数 <code>RHS</code>，但是与我们以往的用法不同，这里它给 <code>RHS</code> 一个默认值，也就是当用户不指定 <code>RHS</code> 时，默认使用两个同样类型的值进行相加，然后返回一个关联类型 <code>Output</code>。</p><p>默认类型参数主要用于两个方面：</p><ol><li>减少实现的样板代码</li><li>扩展类型但是无需大幅修改现有的代码</li></ol><h4 id="调用同名方法"><a href="#调用同名方法" class="headerlink" title="调用同名方法"></a>调用同名方法</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Pilot</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Wizard</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Pilot</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;This is your captain speaking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Wizard</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Up!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fly</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*waving arms furiously*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>();</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">*waving arms furiously*</span><br></pre></td></tr></table></figure><blockquote><p>  默认优先调用类型上的同名方法</p></blockquote><h5 id="调用特征上的方法"><a href="#调用特征上的方法" class="headerlink" title="调用特征上的方法"></a>调用特征上的方法</h5><p>可以显式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = Human;</span><br><span class="line">    Pilot::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用Pilot特征上的方法</span></span><br><span class="line">    Wizard::<span class="title function_ invoke__">fly</span>(&amp;person); <span class="comment">// 调用Wizard特征上的方法</span></span><br><span class="line">    person.<span class="title function_ invoke__">fly</span>(); <span class="comment">// 调用Human类型自身的方法</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">This is your captain speaking.</span><br><span class="line">Up!</span><br><span class="line">*waving arms furiously*</span><br></pre></td></tr></table></figure><p>如果方法没有 <code>self</code> 参数，则使用<strong>完全限定语法</strong></p><h5 id="完全限定语法"><a href="#完全限定语法" class="headerlink" title="完全限定语法"></a>完全限定语法</h5><p>完全限定语法定义为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::<span class="title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure><h4 id="特征定义中的特征约束"><a href="#特征定义中的特征约束" class="headerlink" title="特征定义中的特征约束"></a>特征定义中的特征约束</h4><p>让某个特征 A 能使用另一个特征 B 的功能，这种情况下，不仅仅要为类型实现特征 A，还要为类型实现特征 B 才行，这就是 <code>supertrait</code> 。</p><p>Demo:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">OutlinePrint</span>: Display &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">outline_print</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">output</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = output.<span class="title function_ invoke__">len</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;* &#123;&#125; *&quot;</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;*&#123;&#125;*&quot;</span>, <span class="string">&quot; &quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="string">&quot;*&quot;</span>.<span class="title function_ invoke__">repeat</span>(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法: <code>OutlinePrint: Display</code> =&gt; 如果你想要实现 <code>OutlinePrint</code> 特征，首先你需要实现 <code>Display</code> 特征。</p><h4 id="在外部类型上实现外部特征-newtype"><a href="#在外部类型上实现外部特征-newtype" class="headerlink" title="在外部类型上实现外部特征(newtype)"></a>在外部类型上实现外部特征(newtype)</h4><p>为绕开<strong>孤儿规则</strong>，可以使用 <strong><code>newtype</code> 模式</strong>： 就是为一个<a href="https://course.rs/basic/compound-type/struct#元组结构体tuple-struct">元组结构体</a>创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">w = [hello, world]</span><br></pre></td></tr></table></figure><p><code>new type</code> 缺点：</p><p>需要使用 <code>self.0</code> 来获取被包装的类型。like：<code>self.0.join(&quot;, &quot;)</code>。</p><p>Rust 提供了一个特征叫 <a href="https://course.rs/advance/smart-pointer/deref.html"><code>Deref</code></a>，实现该特征后，可以自动做一层类似类型转换的操作，可以将 <code>Wrapper</code> 变成 <code>Vec&lt;String&gt;</code> 来使用。</p><h2 id="2-9-集合类型"><a href="#2-9-集合类型" class="headerlink" title="2.9 集合类型"></a>2.9 集合类型</h2><h3 id="2-9-1-动态数组-Vector"><a href="#2-9-1-动态数组-Vector" class="headerlink" title="2.9.1 动态数组 Vector"></a>2.9.1 动态数组 Vector</h3><p>动态数组类型用 <code>Vec&lt;T&gt;</code> 表示，动态数组允许你存储相同类型的元素。</p><h4 id="创建动态数组"><a href="#创建动态数组" class="headerlink" title="创建动态数组"></a>创建动态数组</h4><h5 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new"></a>Vec::new</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br></pre></td></tr></table></figure><blockquote><p>  如果预先知道要存储的元素个数，可以使用 <code>Vec::with_capacity(capacity)</code> 创建动态数组。</p></blockquote><h5 id="Vec"><a href="#Vec" class="headerlink" title="Vec![]"></a>Vec![]</h5><p>使用宏 <code>vec!</code> 来创建数组，会初始化数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><h4 id="更新-Vector"><a href="#更新-Vector" class="headerlink" title="更新 Vector"></a>更新 Vector</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">v.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="Vector-与其元素共存亡"><a href="#Vector-与其元素共存亡" class="headerlink" title="Vector 与其元素共存亡"></a>Vector 与其元素共存亡</h4><p><code>Vector</code> 类型在超出作用域范围后，会被自动删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let v = vec![1, 2, 3];</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125; // &lt;- v超出作用域并在此处被删除</span><br></pre></td></tr></table></figure><h4 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h4><p>读取指定位置的元素有两种方式可选：</p><ul><li>通过下标索引访问。</li><li>使用 <code>get</code> 方法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">third</span>: &amp;<span class="type">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.<span class="title function_ invoke__">get</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;去你的第三个元素，根本没有！&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">第三个元素是 <span class="number">3</span></span><br><span class="line">第三个元素是 <span class="number">3</span></span><br></pre></td></tr></table></figure><h5 id="下表索引与-get-的区别"><a href="#下表索引与-get-的区别" class="headerlink" title="下表索引与 .get 的区别"></a>下表索引与 <code>.get</code> 的区别</h5><p><code>&amp;v[100]</code> 发生数组越界访问会报错， <code>v.get</code> 在内部做了处理，有值的时候返回 <code>Some(T)</code>，无值的时候返回 <code>None</code>。</p><h4 id="迭代遍历-Vector-中的元素"><a href="#迭代遍历-Vector-中的元素" class="headerlink" title="迭代遍历 Vector 中的元素"></a>迭代遍历 Vector 中的元素</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在迭代过程中，修改 <code>Vector</code> 中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h4 id="存储不同类型元素"><a href="#存储不同类型元素" class="headerlink" title="存储不同类型元素"></a>存储不同类型元素</h4><p>通过使用枚举类型和特征对象来实现不同类型元素的存储。</p><p>枚举：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        IpAddr::<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        <span class="title function_ invoke__">show_addr</span>(ip)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">show_addr</span>(ip: IpAddr) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, ip);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>)</span><br><span class="line"><span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>)</span><br></pre></td></tr></table></figure><p>特征对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V4</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V4</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">V6</span>(<span class="type">String</span>);</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">IpAddr</span> <span class="keyword">for</span> <span class="title class_">V6</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="keyword">self</span>.<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> IpAddr&gt;&gt; = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V4</span>(<span class="string">&quot;127.0.0.1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="title function_ invoke__">V6</span>(<span class="string">&quot;::1&quot;</span>.<span class="title function_ invoke__">to_string</span>())),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ip</span> <span class="keyword">in</span> v &#123;</span><br><span class="line">        ip.<span class="title function_ invoke__">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">ipv4: <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">ipv6: <span class="string">&quot;::1&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-9-2-KV-存储-HashMap"><a href="#2-9-2-KV-存储-HashMap" class="headerlink" title="2.9.2 KV 存储 HashMap"></a>2.9.2 KV 存储 HashMap</h3><h4 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap</h4><p>使用 <code>new</code> 方法来创建 <code>HashMap</code>，通过 <code>insert</code> 方法插入键值对。</p><h5 id="使用-new-创建"><a href="#使用-new-创建" class="headerlink" title="使用 new 创建"></a>使用 new 创建</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个HashMap，用于存储宝石种类和对应的数量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">my_gems</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将宝石类型和对应的数量写入表中</span></span><br><span class="line">    my_gems.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;红宝石&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    my_gems.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;蓝宝石&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    my_gems.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;河边捡的误以为是宝石的破石头&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  跟<code>Vec</code>一样，如果预先知道要存储的 <code>KV</code>对个数，可以使用 <code>HashMap::with_capacity(capacity)</code> 创建指定大小的 <code>HashMap</code>，避免频繁的内存分配和拷贝，提升性能。</p></blockquote><h5 id="使用迭代器和-collect-方法创建"><a href="#使用迭代器和-collect-方法创建" class="headerlink" title="使用迭代器和 collect 方法创建"></a>使用迭代器和 collect 方法创建</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_list</span> = <span class="built_in">vec!</span>[</span><br><span class="line">        (<span class="string">&quot;中国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">100</span>),</span><br><span class="line">        (<span class="string">&quot;美国队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">10</span>),</span><br><span class="line">        (<span class="string">&quot;日本队&quot;</span>.<span class="title function_ invoke__">to_string</span>(), <span class="number">50</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams_map</span>: HashMap&lt;_, _&gt; = teams_list.<span class="title function_ invoke__">into_iter</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, teams_map)</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">&#123;<span class="string">&quot;日本队&quot;</span>: <span class="number">50</span>, <span class="string">&quot;中国队&quot;</span>: <span class="number">100</span>, <span class="string">&quot;美国队&quot;</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h4><p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p><ul><li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li><li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunface&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handsome_boys</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    handsome_boys.<span class="title function_ invoke__">insert</span>(name, age);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;因为过于无耻，&#123;&#125;已经被从帅气男孩名单中除名&quot;</span>, name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;还有，他的真实年龄远远不止&#123;&#125;岁&quot;</span>, age);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0382]: borrow of moved value: `name`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">37</span>:<span class="number">40</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">31</span> |     <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunface&quot;</span>);</span><br><span class="line">   |         ---- <span class="keyword">move</span> occurs because `name` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">...</span><br><span class="line"><span class="number">35</span> |     handsome_boys.<span class="title function_ invoke__">insert</span>(name, age);</span><br><span class="line">   |                          ---- value moved here</span><br><span class="line"><span class="number">36</span> | </span><br><span class="line"><span class="number">37</span> |     <span class="built_in">println!</span>(<span class="string">&quot;因为过于无耻，&#123;&#125;已经被从帅气男孩名单中除名&quot;</span>, name);</span><br><span class="line">   |                                                            ^^^^ value borrowed here after <span class="keyword">move</span></span><br><span class="line">   |</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">error: could not compile `hashmap-demo` due to previous error</span><br></pre></td></tr></table></figure><p>从报错中，我们可以清晰的看到 <code>name</code> 的所有权被转移到 <code>handsome_boys</code> 中。</p><p><strong>使用引用类型放入 HashMap 中</strong>，请确保该引用的生命周期至少跟 <code>HashMap</code> 活得一样久：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Sunface&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">age</span> = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handsome_boys</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    handsome_boys.<span class="title function_ invoke__">insert</span>(&amp;name, age);</span><br><span class="line"></span><br><span class="line">    std::mem::<span class="title function_ invoke__">drop</span>(name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;因为过于无耻，&#123;:?&#125;已经被除名&quot;</span>, handsome_boys);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;还有，他的真实年龄远远不止&#123;&#125;岁&quot;</span>, age);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0505]: cannot <span class="keyword">move</span> out of `name` because it is borrowed</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">50</span>:<span class="number">20</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">48</span> |     handsome_boys.<span class="title function_ invoke__">insert</span>(&amp;name, age);</span><br><span class="line">   |                          ----- borrow of `name` occurs here</span><br><span class="line"><span class="number">49</span> | </span><br><span class="line"><span class="number">50</span> |     std::mem::<span class="title function_ invoke__">drop</span>(name);</span><br><span class="line">   |                    ^^^^ <span class="keyword">move</span> out of `name` occurs here</span><br><span class="line"><span class="number">51</span> |     <span class="built_in">println!</span>(<span class="string">&quot;因为过于无耻，&#123;:?&#125;已经被除名&quot;</span>, handsome_boys);</span><br><span class="line">   |                                              ------------- borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0505`.</span><br><span class="line">error: could not compile `hashmap-demo` due to previous error</span><br></pre></td></tr></table></figure><p>通过 <code>drop</code> 函数手动将 <code>name</code> 字符串从内存中移除，导致引用失效。</p><h4 id="查询-HashMap"><a href="#查询-HashMap" class="headerlink" title="查询 HashMap"></a>查询 <code>HashMap</code></h4><p>通过 <code>get</code> 方法可以获取元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span>: <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, score);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="title function_ invoke__">Some</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ul><li><code>get</code> 方法返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型：当查询不到时，会返回一个 <code>None</code>，查询到时返回 <code>Some(&amp;i32)</code></li><li><code>&amp;i32</code> 是对 <code>HashMap</code> 中值的借用，如果不使用借用，可能会发生所有权的转移</li></ul><p>通过循环的方式依次遍历 <code>KV</code> 对：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Blue: <span class="number">10</span></span><br><span class="line">Yellow: <span class="number">50</span></span><br></pre></td></tr></table></figure><h4 id="更新-HashMap-的值"><a href="#更新-HashMap-的值" class="headerlink" title="更新 HashMap 的值"></a>更新 <code>HashMap</code> 的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖已有的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = scores.<span class="title function_ invoke__">insert</span>(<span class="string">&quot;Blue&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(old, <span class="title function_ invoke__">Some</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询新插入的值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new</span> = scores.<span class="title function_ invoke__">get</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(new, <span class="title function_ invoke__">Some</span>(&amp;<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Yellow对应的值，若不存在则插入新值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Yellow&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*v, <span class="number">5</span>); <span class="comment">// 不存在，插入5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Yellow对应的值，若不存在则插入新值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="string">&quot;Yellow&quot;</span>).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*v, <span class="number">5</span>); <span class="comment">// 已经存在，因此50没有插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>一个类型能否作为 <code>Key</code> 的关键就是是否实现了 <code>std::cmp::Eq</code> 特征。</p><h2 id="2-10-类型转换"><a href="#2-10-类型转换" class="headerlink" title="2.10 类型转换"></a>2.10 类型转换</h2><h4 id="as-转换"><a href="#as-转换" class="headerlink" title="as 转换"></a>as 转换</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.1</span> <span class="keyword">as</span> <span class="type">i8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">100_i8</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;a&#x27;</span> <span class="keyword">as</span> <span class="type">u8</span>; <span class="comment">// 将字符&#x27;a&#x27;转换为整数，97</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>, a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">3</span>,<span class="number">100</span>,<span class="number">97</span></span><br></pre></td></tr></table></figure><h5 id="内存地址转换为指针"><a href="#内存地址转换为指针" class="headerlink" title="内存地址转换为指针"></a>内存地址转换为指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">values</span>: [<span class="type">i32</span>; <span class="number">2</span>] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p1</span>: *<span class="keyword">mut</span> <span class="type">i32</span> = values.<span class="title function_ invoke__">as_mut_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_address</span> = p1 <span class="keyword">as</span> <span class="type">usize</span>; <span class="comment">// 将p1内存地址转换为一个整数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second_address</span> = first_address + <span class="number">4</span>; <span class="comment">// 4 == std::mem::size_of::&lt;i32&gt;()，i32类型占用4个字节，因此将内存地址 + 4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p2</span> = second_address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>; <span class="comment">// 访问该地址指向的下一个整数p2</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *p2 += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(values[<span class="number">1</span>], <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TryInto-转换"><a href="#TryInto-转换" class="headerlink" title="TryInto 转换"></a>TryInto 转换</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::convert::TryInto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">u8</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">u16</span> = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_</span>: <span class="type">u8</span> = b.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> a &lt; b_ &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Ten is less than one hundred.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: <span class="type">i16</span> = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b_</span>: <span class="type">u8</span> = <span class="keyword">match</span> b.<span class="title function_ invoke__">try_into</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(b1) =&gt; b1,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">            <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b_);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="string">&quot;out of range integral type conversion attempted&quot;</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="通用类型转换"><a href="#通用类型转换" class="headerlink" title="通用类型转换"></a>通用类型转换</h4><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>一个类型 <code>T</code> 可以强制转换为 <code>U</code>，不代表 <code>impl T</code> 可以强制转换为 <code>impl U</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Trait</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>&lt;X: Trait&gt;(t: X) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; Trait <span class="keyword">for</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span>: &amp;<span class="keyword">mut</span> <span class="type">i32</span> = &amp;<span class="keyword">mut</span> <span class="number">0</span>;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0277]: the <span class="keyword">trait</span> <span class="title class_">bound</span> `&amp;<span class="keyword">mut</span> <span class="type">i32</span>: Trait` is not satisfied</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">56</span>:<span class="number">9</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">56</span> |     <span class="title function_ invoke__">foo</span>(t);</span><br><span class="line">   |     --- ^ the <span class="keyword">trait</span> `Trait` is not implemented <span class="keyword">for</span> `&amp;<span class="keyword">mut</span> <span class="type">i32</span>`</span><br><span class="line">   |     |</span><br><span class="line">   |     required by a bound introduced by this call</span><br><span class="line">   |</span><br><span class="line">   = help: the following implementations were found:</span><br><span class="line">             &lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span> <span class="keyword">as</span> Trait&gt;</span><br><span class="line">   = note: `Trait` is implemented <span class="keyword">for</span> `&amp;<span class="type">i32</span>`, but not <span class="keyword">for</span> `&amp;<span class="keyword">mut</span> <span class="type">i32</span>`</span><br><span class="line">note: required by a bound <span class="keyword">in</span> `foo`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">50</span>:<span class="number">11</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">50</span> | <span class="keyword">fn</span> <span class="title function_">foo</span>&lt;X: Trait&gt;(t: X) &#123;&#125;</span><br><span class="line">   |           ^^^^^ required by this bound <span class="keyword">in</span> `foo`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0277`.</span><br><span class="line">error: could not compile `converse-demo` due to previous error</span><br></pre></td></tr></table></figure><h5 id="点操作符"><a href="#点操作符" class="headerlink" title="点操作符"></a>点操作符</h5><p>假设有一个方法 <code>foo</code>，它有一个接收器(接收器就是 <code>self</code>、<code>&amp;self</code>、<code>&amp;mut self</code> 参数)。如果调用 <code>value.foo()</code>，编译器在调用 <code>foo</code> 之前，需要决定到底使用哪个 <code>Self</code> 类型来调用。现在假设 <code>value</code> 拥有类型 <code>T</code>。</p><p>再进一步，我们使用<a href="https://course.rs/basic/trait/advance-trait.html#完全限定语法">完全限定语法</a>来进行准确的函数调用:</p><ol><li>首先，编译器检查它是否可以直接调用 <code>T::foo(value)</code>，称之为<strong>值方法调用</strong></li><li>如果上一步调用无法完成(例如方法类型错误或者特征没有针对 <code>Self</code> 进行实现，上文提到过特征不能进行强制转换)，那么编译器会尝试增加自动引用，例如会尝试以下调用： <code>&lt;&amp;T&gt;::foo(value)</code> 和 <code>&lt;&amp;mut T&gt;::foo(value)</code>，称之为<strong>引用方法调用</strong></li><li>若上面两个方法依然不工作，编译器会试着解引用 <code>T</code> ，然后再进行尝试。这里使用了 <code>Deref</code> 特征 —— 若 <code>T: Deref&lt;Target = U&gt;</code> (<code>T</code> 可以被解引用为 <code>U</code>)，那么编译器会使用 <code>U</code> 类型进行尝试，称之为<strong>解引用方法调用</strong></li><li>若 <code>T</code> 不能被解引用，且 <code>T</code> 是一个定长类型(在编译器类型长度是已知的)，那么编译器也会尝试将 <code>T</code> 从定长类型转为不定长类型，例如将 <code>[i32; 2]</code> 转为 <code>[i32]</code></li><li>若还是不行，编译器会报错</li></ol><h2 id="2-11-返回值与错误处理"><a href="#2-11-返回值与错误处理" class="headerlink" title="2.11 返回值与错误处理"></a>2.11 返回值与错误处理</h2><p>Rust 中的错误主要分为两类：</p><ul><li><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li><li><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li></ul><h3 id="2-11-1-panic-解析"><a href="#2-11-1-panic-解析" class="headerlink" title="2.11.1 panic 解析"></a>2.11.1 <code>panic</code> 解析</h3><h4 id="panic-与不可恢复错误"><a href="#panic-与不可恢复错误" class="headerlink" title="panic! 与不可恢复错误"></a><code>panic!</code> 与不可恢复错误</h4><p>只有当不知如何处理时，才去调用 <code>panic!</code></p><h4 id="调用-panic"><a href="#调用-panic" class="headerlink" title="调用 panic!"></a>调用 <code>panic!</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;crash and burn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>crash and burn<span class="string">&#x27;, src/main.rs:2:5</span></span><br><span class="line"><span class="string">stack backtrace:</span></span><br><span class="line"><span class="string">   0: rust_begin_unwind</span></span><br><span class="line"><span class="string">             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5</span></span><br><span class="line"><span class="string">   1: core::panicking::panic_fmt</span></span><br><span class="line"><span class="string">             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14</span></span><br><span class="line"><span class="string">   2: panic_demo::main</span></span><br><span class="line"><span class="string">             at ./src/main.rs:2:5</span></span><br><span class="line"><span class="string">   3: core::ops::function::FnOnce::call_once</span></span><br><span class="line"><span class="string">             at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5</span></span><br><span class="line"><span class="string">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span></span><br></pre></td></tr></table></figure><h4 id="panic-时的两种终止方式"><a href="#panic-时的两种终止方式" class="headerlink" title="panic 时的两种终止方式"></a><code>panic</code> 时的两种终止方式</h4><p>程序提供了两种方式来处理终止流程：<strong>栈展开</strong>和<strong>直接终止</strong>。</p><h4 id="panic-后是否会终止程序"><a href="#panic-后是否会终止程序" class="headerlink" title="panic 后是否会终止程序"></a><code>panic</code> 后是否会终止程序</h4><p>如果是 <code>main</code> 线程，则程序会终止，如果是其它子线程，该线程会终止，但是不会影响 <code>main</code> 线程。</p><h4 id="panic-原理剖析"><a href="#panic-原理剖析" class="headerlink" title="panic 原理剖析"></a><code>panic</code> 原理剖析</h4><p>调用 <code>panic!</code> 宏时，它会</p><ol><li>格式化 <code>panic</code> 信息，然后使用该信息作为参数，调用 <code>std::panic::panic_any()</code> 函数</li><li><code>panic_any</code> 会检查应用是否使用了 <a href="https://doc.rust-lang.org/std/panic/fn.set_hook.html"><code>panic hook</code></a>，如果使用了，该 <code>hook</code> 函数就会被调用（<code>hook</code> 是一个钩子函数，是外部代码设置的，用于在 <code>panic</code> 触发时，执行外部代码所需的功能）</li><li>当 <code>hook</code> 函数返回后，当前的线程就开始进行栈展开：从 <code>panic_any</code> 开始，如果寄存器或者栈因为某些原因信息错乱了，那很可能该展开会发生异常，最终线程会直接停止，展开也无法继续进行</li><li>展开的过程是一帧一帧的去回溯整个栈，每个帧的数据都会随之被丢弃，但是在展开过程中，你可能会遇到被用户标记为 <code>catching</code> 的帧（通过 <code>std::panic::catch_unwind()</code> 函数标记），此时用户提供的 <code>catch</code> 函数会被调用，展开也随之停止：当然，如果 <code>catch</code> 选择在内部调用 <code>std::panic::resume_unwind()</code> 函数，则展开还会继续。</li></ol><p>还有一种情况，在展开过程中，如果展开本身 <code>panic</code> 了，那展开线程会终止，展开也随之停止。</p><p>一旦线程展开被终止或者完成，最终的输出结果是取决于哪个线程 <code>panic</code>：对于 <code>main</code> 线程，操作系统提供的终止功能 <code>core::intrinsics::abort()</code> 会被调用，最终结束当前的 <code>panic</code> 进程；如果是其它子线程，那么子线程就会简单的终止，同时信息会在稍后通过 <code>std::thread::join()</code> 进行收集。</p><h3 id="2-11-2-可恢复的错误Result"><a href="#2-11-2-可恢复的错误Result" class="headerlink" title="2.11.2 可恢复的错误Result"></a>2.11.2 可恢复的错误<code>Result</code></h3><p>一种更温和的错误处理方式：<code>Result&lt;T,E&gt;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="失败就-panic-unwrap-和-expect"><a href="#失败就-panic-unwrap-和-expect" class="headerlink" title="失败就 panic: unwrap 和 expect"></a>失败就 panic: unwrap 和 expect</h4><p><code>expect</code> 相比 <code>unwrap</code> 能提供更精确的错误信息：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fs::File;</span><br><span class="line">    <span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">        <span class="comment">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">            <span class="comment">// 打开文件成功，将file句柄赋值给f</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">            <span class="comment">// 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建动态字符串s</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="comment">// 从f文件句柄读取数据并写入s中</span></span><br><span class="line">        <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">            <span class="comment">// 读取成功，返回Ok封装的字符串</span></span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">            <span class="comment">// 将错误向上传播</span></span><br><span class="line">            <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传播"><a href="#传播" class="headerlink" title="? 传播"></a><code>?</code> 传播</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::fs::File;</span><br><span class="line">    <span class="keyword">use</span> std::io;</span><br><span class="line">    <span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>?</code> 的作用等价于：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">    <span class="comment">// 打开文件成功，将file句柄赋值给f</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">    <span class="comment">// 打开文件失败，将错误返回(向上传播)</span></span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="用于-Option-的返回"><a href="#用于-Option-的返回" class="headerlink" title="? 用于 Option 的返回"></a><code>?</code> 用于 <code>Option</code> 的返回</h4><p><code>Option</code> 可以通过<code>？</code> 返回 <code>None</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">first</span>(arr: &amp;[<span class="type">i32</span>]) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">v</span> = arr.<span class="title function_ invoke__">get</span>(<span class="number">0</span>)?;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-12-包和模块"><a href="#2-12-包和模块" class="headerlink" title="2.12 包和模块"></a>2.12 包和模块</h2><h3 id="2-12-1-包和Package"><a href="#2-12-1-包和Package" class="headerlink" title="2.12.1 包和Package"></a>2.12.1 包和<code>Package</code></h3><ul><li><strong>项目(Package)</strong>：可以用来构建、测试和分享包</li><li><strong>工作空间(WorkSpace)</strong>：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li><li><strong>包(Crate)</strong>：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li><li><strong>模块(Module)</strong>：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="包-Crate"><a href="#包-Crate" class="headerlink" title="包 Crate"></a>包 <code>Crate</code></h5><p>包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p><p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。</p><p>同一个包中不能有同名的类型，但是在不同包中就可以。</p><h4 id="项目-Package"><a href="#项目-Package" class="headerlink" title="项目 Package"></a>项目 <code>Package</code></h4><p>一个 <code>Package</code> 只能包含<strong>一个</strong>库(library)类型的包，但是可以包含<strong>多个</strong>二进制可执行类型的包。</p><h5 id="二进制-Package"><a href="#二进制-Package" class="headerlink" title="二进制 Package"></a>二进制 <code>Package</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-project</span><br><span class="line">     Created binary (application) `my-project` package</span><br><span class="line">$ <span class="built_in">ls</span> my-project</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ <span class="built_in">ls</span> my-project/src</span><br><span class="line">main.rs</span><br></pre></td></tr></table></figure><p>Cargo 有一个惯例：<strong><code>src/main.rs</code> 是二进制包的根文件，该二进制包的包名跟所属 <code>Package</code> 相同，在这里都是 <code>my-project</code></strong>，所有的代码执行都从该文件中的 <code>fn main()</code> 函数开始。</p><h5 id="库-Package"><a href="#库-Package" class="headerlink" title="库 Package"></a>库 <code>Package</code></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new my-lib --lib</span><br><span class="line">     Created library `my-lib` package</span><br><span class="line">$ <span class="built_in">ls</span> my-lib</span><br><span class="line">Cargo.toml</span><br><span class="line">src</span><br><span class="line">$ <span class="built_in">ls</span> my-lib/src</span><br><span class="line">lib.rs</span><br></pre></td></tr></table></figure><p>如果直接运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run         </span><br><span class="line">error: a bin target must be available <span class="keyword">for</span> `cargo run`</span><br></pre></td></tr></table></figure><h5 id="典型-Package-结构"><a href="#典型-Package-结构" class="headerlink" title="典型 Package 结构"></a>典型 <code>Package</code> 结构</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure><ul><li>唯一库包：<code>src/lib.rs</code></li><li>默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与 <code>Package</code> 同名</li><li>其余二进制包：<code>src/bin/main1.rs</code> 和 <code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件</li><li>集成测试文件：<code>tests</code> 目录下</li><li>基准性能测试 <code>benchmark</code> 文件：<code>benches</code> 目录下</li><li>项目示例：<code>examples</code> 目录下</li></ul><h3 id="2-12-2-模块-Module"><a href="#2-12-2-模块-Module" class="headerlink" title="2.12.2 模块 Module"></a>2.12.2 模块 <code>Module</code></h3><h4 id="创建嵌套模块"><a href="#创建嵌套模块" class="headerlink" title="创建嵌套模块"></a>创建嵌套模块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码创建了三个模块，有几点需要注意的：</p><ul><li>使用 <code>mod</code> 关键字来创建新模块，后面紧跟着模块名称</li><li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li><li>模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等</li><li>所有模块均定义在同一个文件中</li></ul><h4 id="模块树"><a href="#模块树" class="headerlink" title="模块树"></a>模块树</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure><h4 id="用路径引用模块"><a href="#用路径引用模块" class="headerlink" title="用路径引用模块"></a>用路径引用模块</h4><p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：</p><ul><li><strong>绝对路径</strong>，从包根开始，路径名以包名或者 <code>crate</code> 作为开头</li><li><strong>相对路径</strong>，从当前模块开始，以 <code>self</code>，<code>super</code> 或当前模块的标识符作为开头</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码可见性"><a href="#代码可见性" class="headerlink" title="代码可见性"></a>代码可见性</h4><p>使用 <code>pub</code> 关键字，控制模块和模块中指定项的可见性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-super-引用模块"><a href="#使用-super-引用模块" class="headerlink" title="使用 super 引用模块"></a>使用 <code>super</code> 引用模块</h4><p><code>super</code> 代表的是父模块为开始的引用方式。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 厨房模块</span></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-self-引用模块"><a href="#使用-self-引用模块" class="headerlink" title="使用 self 引用模块"></a>使用 <code>self</code> 引用模块</h4><p><code>self</code> 其实就是引用自身模块中的项。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;</span><br><span class="line">    self::back_of_house::<span class="title function_ invoke__">cook_order</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        crate::<span class="title function_ invoke__">serve_order</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体和枚举的可见性"><a href="#结构体和枚举的可见性" class="headerlink" title="结构体和枚举的可见性"></a>结构体和枚举的可见性</h4><p>成员字段拥有完全不同的可见性：</p><ul><li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的</li><li>将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li></ul><h3 id="2-12-3-使用-use-及受限可见性"><a href="#2-12-3-使用-use-及受限可见性" class="headerlink" title="2.12.3 使用 use 及受限可见性"></a>2.12.3 使用 use 及受限可见性</h3><h4 id="基本引入方式"><a href="#基本引入方式" class="headerlink" title="基本引入方式"></a>基本引入方式</h4><p>引入模块中的项有两种方式：绝对路径和相对路径</p><h5 id="绝对路径引入模块"><a href="#绝对路径引入模块" class="headerlink" title="绝对路径引入模块"></a>绝对路径引入模块</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">  hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">  hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">  hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="相对路径引入模块"><a href="#相对路径引入模块" class="headerlink" title="相对路径引入模块"></a>相对路径引入模块</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting::add_to_waitlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    <span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="引入模块还是函数"><a href="#引入模块还是函数" class="headerlink" title="引入模块还是函数"></a>引入模块还是函数</h5><p>建议：<strong>优先使用最细粒度(引入函数、结构体等)的引用方式，如果引起了某种麻烦(例如前面两种情况)，再使用引入模块的方式</strong>。</p><h4 id="避免同名引用"><a href="#避免同名引用" class="headerlink" title="避免同名引用"></a>避免同名引用</h4><h5 id="模块-函数"><a href="#模块-函数" class="headerlink" title="模块::函数"></a>模块::函数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> io::<span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="as-别名引用"><a href="#as-别名引用" class="headerlink" title="as 别名引用"></a><code>as</code> 别名引用</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function1</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function2</span>() <span class="punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入项再导出"><a href="#引入项再导出" class="headerlink" title="引入项再导出"></a><a href="https://course.rs/basic/crate-module/use.html#引入项再导出">引入项再导出</a></h4><h4 id="使用第三方包"><a href="#使用第三方包" class="headerlink" title="使用第三方包"></a>使用第三方包</h4><p>修改 <code>Cargo.toml</code> 文件，在 <code>[dependencies]</code> 区域添加引入的包</p><p>eg:<code>rand = &quot;0.8.3&quot;</code></p><h4 id="使用-简化引入方式"><a href="#使用-简化引入方式" class="headerlink" title="使用 {} 简化引入方式"></a>使用 <code>&#123;&#125;</code> 简化引入方式</h4><p>同时引入模块和模块中的项：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Write;</span><br><span class="line"></span><br><span class="line">|</span><br><span class="line">|<span class="punctuation">-&gt;</span> <span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br></pre></td></tr></table></figure><h4 id="使用-引入模块下所有项"><a href="#使用-引入模块下所有项" class="headerlink" title="使用*引入模块下所有项"></a>使用*引入模块下所有项</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::*;</span><br></pre></td></tr></table></figure><h4 id="受限的可见性"><a href="#受限的可见性" class="headerlink" title="受限的可见性"></a><a href="https://course.rs/basic/crate-module/use.html#受限的可见性">受限的可见性</a></h4><h3 id="2-14-格式化输出"><a href="#2-14-格式化输出" class="headerlink" title="2.14 格式化输出"></a>2.14 格式化输出</h3><h4 id="初印象"><a href="#初印象" class="headerlink" title="初印象"></a>初印象</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello&quot;</span>);                     <span class="comment">// =&gt; &quot;Hello&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="string">&quot;world&quot;</span>);       <span class="comment">// =&gt; &quot;Hello, world!&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The number is &#123;&#125;&quot;</span>, <span class="number">1</span>);       <span class="comment">// =&gt; &quot;The number is 1&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, (<span class="number">3</span>, <span class="number">4</span>));              <span class="comment">// =&gt; &quot;(3, 4)&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;value&#125;&quot;</span>, value = <span class="number">4</span>);        <span class="comment">// =&gt; &quot;4&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);               <span class="comment">// =&gt; &quot;1 2&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:04&#125;&quot;</span>, <span class="number">42</span>);                 <span class="comment">// =&gt; &quot;0042&quot; with leading zeros</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Rust 中用来格式化输出的三大金刚，用途如下：</p><ul><li><code>print!</code> 将格式化文本输出到标准输出，不带换行符</li><li><code>println!</code> 同上，但是在行的末尾添加换行符</li><li><code>format!</code> 将格式化文本输出到 <code>String</code> 字符串</li></ul><p>错误输出：<code>eprint!</code>, <code>eprintln!</code> 类似 <code>print!</code>，<code>println!</code> </p><h4 id="与"><a href="#与" class="headerlink" title="{} 与{:?}"></a><code>&#123;&#125;</code> 与<code>&#123;:?&#125;</code></h4><ul><li><p>都是占位符</p></li><li><p><code>&#123;&#125;</code> 适用于实现了 <code>std::fmt::Display</code> 特征的类型，用来以更优雅、更友好的方式格式化文本</p></li><li><code>&#123;:?&#125;</code> 适用于实现了 <code>std::fmt::Debug</code> 特征的类型，用于调试场景</li></ul><h5 id="Debug特征"><a href="#Debug特征" class="headerlink" title="Debug特征"></a><code>Debug</code>特征</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    age: <span class="type">u8</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Person &#123;</span><br><span class="line">        name: <span class="string">&quot;sunface&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;</span>, i, s, v, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体类型需要派生Debug特征，才能输出。</p><h5 id="Display特征"><a href="#Display特征" class="headerlink" title="Display特征"></a><code>Display</code>特征</h5><p>未明确格式化方式的对象：</p><ul><li>使用 <code>&#123;:?&#125;</code> 或 <code>&#123;:#?&#125;</code></li><li>为自定义类型实现 <code>Display</code> 特征</li><li>使用 <code>newtype</code> 为外部类型实现 <code>Display</code> 特征</li></ul><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>可以使用索引指定位置的参数替换该占位符</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt;&quot;12&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;1&#125;&#123;0&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt;&quot;21&quot;</span></span><br><span class="line">                              <span class="comment">// =&gt; Alice, this is Bob. Bob, this is Alice</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;1&#125;&#123;&#125;&#123;0&#125;&#123;&#125;&quot;</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// =&gt; 2112</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具名参数"><a href="#具名参数" class="headerlink" title="具名参数"></a>具名参数</h4><p>也可以为参数指定名称</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;argument&#125;&quot;</span>, argument = <span class="string">&quot;test&quot;</span>); <span class="comment">// =&gt; &quot;test&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;name&#125; &#123;&#125;&quot;</span>, <span class="number">1</span>, name = <span class="number">2</span>); <span class="comment">// =&gt; &quot;2 1&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;</span>, a = <span class="string">&quot;a&quot;</span>, b = <span class="string">&#x27;b&#x27;</span>, c = <span class="number">3</span>); <span class="comment">// =&gt; &quot;a 3 b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  带名称的参数必须在非具名化参数的后面</p></blockquote><h4 id="格式化参数"><a href="#格式化参数" class="headerlink" title="格式化参数"></a>格式化参数</h4><h5 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h5><p>指示输出目标的长度，如果长度不够，则进行填充和对齐：</p><h4 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">//-----------------------------------</span></span><br><span class="line">    <span class="comment">// 以下全部输出 &quot;Hello x    !&quot;</span></span><br><span class="line">    <span class="comment">// 为&quot;x&quot;后面填充空格，补齐宽度5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用参数5来指定宽度</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:1$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 使用x作为占位符输出内容，同时使用5作为宽度</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;1:0$&#125;!&quot;</span>, <span class="number">5</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="comment">// 使用有名称的参数作为宽度</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:width$&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>, width = <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//-----------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用参数5为参数x指定宽度，同时在结尾输出参数5 =&gt; Hello x    !5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:1$&#125;!&#123;&#125;&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hello x    !</span><br><span class="line">Hello x    !</span><br><span class="line">Hello x    !</span><br><span class="line">Hello x    !</span><br><span class="line">Hello x    !<span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="数字填充：符号和0"><a href="#数字填充：符号和0" class="headerlink" title="数字填充：符号和0"></a>数字填充：符号和0</h4><p>数字格式化默认也是使用空格进行填充，但与字符串左对齐不同的是，数字是右对齐。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 宽度是5 =&gt; Hello     5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:5&#125;!&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 显式的输出正号 =&gt; Hello +5!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:+&#125;!&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 宽度5，使用0进行填充 =&gt; Hello 00005!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 负号也要占用一位宽度 =&gt; Hello -0005!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:05&#125;!&quot;</span>, -<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">Hello     <span class="number">5</span>!</span><br><span class="line">Hello +<span class="number">5</span>!</span><br><span class="line">Hello <span class="number">00005</span>!</span><br><span class="line">Hello -<span class="number">0005</span>!</span><br></pre></td></tr></table></figure><h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下全部都会补齐5个字符的长度</span></span><br><span class="line">    <span class="comment">// 左对齐 =&gt; Hello x    !</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="comment">// 右对齐 =&gt; Hello     x</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:&gt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">    <span class="comment">// 居中对齐 =&gt; Hello   x  !</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:^5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对齐并使用指定符号填充 =&gt; Hello x&amp;&amp;&amp;&amp;!</span></span><br><span class="line">    <span class="comment">// 指定符号填充的前提条件是必须有对齐字符</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;</span>, <span class="string">&quot;x&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hello x    !</span><br><span class="line">Hello     x!</span><br><span class="line">Hello   x  !</span><br><span class="line">Hello x&amp;&amp;&amp;&amp;!</span><br></pre></td></tr></table></figure><h5 id="精度"><a href="#精度" class="headerlink" title="精度"></a>精度</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="number">3.1415926</span>;</span><br><span class="line">    <span class="comment">// 保留小数点后两位 =&gt; 3.14</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, v);</span><br><span class="line">    <span class="comment">// 带符号保留小数点后两位 =&gt; +3.14</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:+.2&#125;&quot;</span>, v);</span><br><span class="line">    <span class="comment">// 不带小数 =&gt; 3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.0&#125;&quot;</span>, v);</span><br><span class="line">    <span class="comment">// 通过参数来设定精度 =&gt; 3.1416，相当于&#123;:.4&#125;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.1$&#125;&quot;</span>, v, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hi我是Sunface孙飞&quot;</span>;</span><br><span class="line">    <span class="comment">// 保留字符串前三个字符 =&gt; hi我</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:.3&#125;&quot;</span>, s);</span><br><span class="line">    <span class="comment">// &#123;:.*&#125;接收两个参数，第一个是精度，第二个是被格式化的值 =&gt; Hello abc!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;:.*&#125;!&quot;</span>, <span class="number">3</span>, <span class="string">&quot;abcdefg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">+<span class="number">3.14</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">hi我</span><br><span class="line">Hello abc!</span><br></pre></td></tr></table></figure><h5 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h5><p>可以使用 <code>#</code> 号来控制数字的进制输出：</p><ul><li><code>#b</code>, 二进制</li><li><code>#o</code>, 八进制</li><li><code>#x</code>, 小写十六进制</li><li><code>#X</code>, 大写十六进制</li><li><code>x</code>, 不带前缀的小写十六进制</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 二进制 =&gt; 0b11011!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#b&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="comment">// 八进制 =&gt; 0o33!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#o&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="comment">// 十进制 =&gt; 27!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="comment">// 小写十六进制 =&gt; 0x1b!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#x&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line">    <span class="comment">// 大写十六进制 =&gt; 0x1B!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#X&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不带前缀的十六进制 =&gt; 1b!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用0填充二进制，宽度为10 =&gt; 0b00011011!</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#010b&#125;!&quot;</span>, <span class="number">27</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">0b11011</span>!</span><br><span class="line"><span class="number">0o33</span>!</span><br><span class="line"><span class="number">27</span>!</span><br><span class="line"><span class="number">0x1b</span>!</span><br><span class="line"><span class="number">0x1B</span>!</span><br><span class="line"><span class="number">1</span>b!</span><br><span class="line"><span class="number">0b00011011</span>!</span><br></pre></td></tr></table></figure><h5 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2e&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1e9</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:2E&#125;&quot;</span>, <span class="number">1000000000</span>); <span class="comment">// =&gt; 1E9</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">1e9</span></span><br><span class="line"><span class="number">1E9</span></span><br></pre></td></tr></table></figure><h5 id="指针地址"><a href="#指针地址" class="headerlink" title="指针地址"></a>指针地址</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, v.<span class="title function_ invoke__">as_ptr</span>()) <span class="comment">// =&gt; 0x600002324050</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">0x6000003f4050</span></span><br></pre></td></tr></table></figure><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// &#123;使用&#123;转义，&#125;使用&#125; =&gt; Hello &#123;&#125;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello &#123;&#123;&#125;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码会报错，因为占位符&#123;&#125;只有一个右括号&#125;，左括号被转义成字符串的内容</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#123; Hello &#125;&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hello &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="输出函数返回值"><a href="#输出函数返回值" class="headerlink" title="输出函数返回值"></a>输出函数返回值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_person</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;sunface&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">person</span> = <span class="title function_ invoke__">get_person</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;person&#125;!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hello, sunface!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java CompletableFuture详解</title>
      <link href="/2022/03/6e17fed87e32.html"/>
      <url>/2022/03/6e17fed87e32.html</url>
      
        <content type="html"><![CDATA[<p>Source:<a href="https://colobu.com/2016/02/29/Java-CompletableFuture/">Java CompletableFuture 详解</a></p><p><code>Future</code>是Java 5添加的类，用来描述一个异步计算的结果。你可以使用<code>isDone</code>方法检查计算是否完成，或者使用<code>get</code>阻塞住调用线程，直到计算完成返回结果，你也可以使用<code>cancel</code>方法停止任务的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicFuture</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">es</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Future&lt;Integer&gt; f = es.submit(() -&gt;&#123;</span><br><span class="line">                <span class="comment">// 长时间的异步计算</span></span><br><span class="line">                <span class="comment">// ……</span></span><br><span class="line">                <span class="comment">// 然后返回结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="comment">//        while(!f.isDone())</span></span><br><span class="line"><span class="comment">//            ;</span></span><br><span class="line">        f.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>Future</code>以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？</p><p>很多语言，比如Node.js，采用回调的方式实现异步编程。Java的一些框架，比如Netty，自己扩展了Java的 <code>Future</code>接口，提供了<code>addListener</code>等多个扩展方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(host, port));</span><br><span class="line">      future.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>()</span><br><span class="line">      &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                      <span class="comment">// SUCCESS</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span> &#123;</span><br><span class="line">                      <span class="comment">// FAILURE</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>Google guava也提供了通用的扩展Future:<a href="http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/ListenableFuture.html">ListenableFuture</a>、<a href="http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/SettableFuture.html">SettableFuture</a> 以及辅助类<a href="http://google.github.io/guava/releases/19.0/api/docs/com/google/common/util/concurrent/Futures.html">Futures</a>等,方便异步编程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ...;</span><br><span class="line">inFlight.add(name);</span><br><span class="line">ListenableFuture&lt;Result&gt; future = service.query(name);</span><br><span class="line">future.addListener(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    processedCount.incrementAndGet();</span><br><span class="line">    inFlight.remove(name);</span><br><span class="line">    lastProcessed.set(name);</span><br><span class="line">    logger.info(<span class="string">&quot;Done with &#123;0&#125;&quot;</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, executor);</span><br></pre></td></tr></table></figure><p>Scala也提供了简单易用且功能强大的Future/Promise<a href="http://docs.scala-lang.org/overviews/core/futures.html">异步编程模式</a>。</p><p>作为正统的Java类库，是不是应该做点什么，加强一下自身库的功能呢？</p><p>在Java 8中, 新增加了一个包含50个方法左右的类: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture</a>，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。</p><p>下面我们就看一看它的功能吧。</p><h2 id="主动完成计算"><a href="#主动完成计算" class="headerlink" title="主动完成计算"></a>主动完成计算</h2><p>CompletableFuture类实现了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html">CompletionStage</a>和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a>接口，所以你还是可以像以前一样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">join</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p><code>getNow</code>有点特殊，如果结果已经计算完则返回结果或者抛出异常，否则返回给定的<code>valueIfAbsent</code>值。<br><code>join</code>返回计算的结果或者抛出一个unchecked异常(CompletionException)，它和<code>get</code>对抛出的异常的处理有些细微的区别，你可以运行下面的代码进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//future.join();</span></span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure><p>尽管Future可以代表在另外的线程中执行的一段异步代码，但是你还是可以在本身线程中执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中<code>future</code>没有关联任何的<code>Callback</code>、线程池、异步任务等，如果客户端调用<code>future.get</code>就会一致傻等下去。你可以通过下面的代码完成一个计算，触发客户端的等待：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.complete(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>当然你也可以抛出一个异常，而不是一个成功的计算结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.completeExceptionally(<span class="keyword">new</span> <span class="title class_">Exception</span>());</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; f = compute();</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Client</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">            CompletableFuture&lt;Integer&gt; f;</span><br><span class="line">            Client(String threadName, CompletableFuture&lt;Integer&gt; f) &#123;</span><br><span class="line">                <span class="built_in">super</span>(threadName);</span><br><span class="line">                <span class="built_in">this</span>.f = f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;: &quot;</span> + f.get());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Client</span>(<span class="string">&quot;Client1&quot;</span>, f).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Client</span>(<span class="string">&quot;Client2&quot;</span>, f).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting&quot;</span>);</span><br><span class="line">        f.complete(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//f.completeExceptionally(new Exception());</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们并没有把<code>f.complete(100);</code>放在另外的线程中去执行，但是在大部分情况下我们可能会用一个线程池去执行这些异步任务。<code>CompletableFuture.complete()</code>、<code>CompletableFuture.completeExceptionally</code>只能被调用一次。但是我们有两个后门方法可以重设这个值:<code>obtrudeValue</code>、<code>obtrudeException</code>，但是使用的时候要小心，因为<code>complete</code>已经触发了客户端，有可能导致客户端会得到不期望的结果。</p><h2 id="创建CompletableFuture对象。"><a href="#创建CompletableFuture对象。" class="headerlink" title="创建CompletableFuture对象。"></a>创建CompletableFuture对象。</h2><p><code>CompletableFuture.completedFuture</code>是一个静态辅助方法，用来返回一个已经计算好的<code>CompletableFuture</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">completedFuture</span><span class="params">(U value)</span></span><br></pre></td></tr></table></figure><p>而以下四个静态方法用来为一段异步执行的代码创建<code>CompletableFuture</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure><p>以<code>Async</code>结尾并且没有指定<code>Executor</code>的方法会使用<code>ForkJoinPool.commonPool()</code>作为它的线程池执行异步代码。</p><p><code>runAsync</code>方法也好理解，它以<code>Runnable</code>函数式接口类型为参数，所以<code>CompletableFuture</code>的计算结果为空。</p><p><code>supplyAsync</code>方法以<code>Supplier&lt;U&gt;</code>函数式接口类型为参数,<code>CompletableFuture</code>的计算结果类型为<code>U</code>。</p><p>因为方法的参数类型都是函数式接口，所以可以使用lambda表达式实现异步任务，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//长时间的计算任务</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;·00&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="计算结果完成时的处理"><a href="#计算结果完成时的处理" class="headerlink" title="计算结果完成时的处理"></a>计算结果完成时的处理</h2><p>当<code>CompletableFuture</code>的计算结果完成，或者抛出异常的时候，我们可以执行特定的<code>Action</code>。主要是下面的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt;     <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span><br></pre></td></tr></table></figure><p>可以看到<code>Action</code>的类型是<code>BiConsumer&lt;? super T,? super Throwable&gt;</code>，它可以处理正常的计算结果，或者异常情况。<br>方法不以<code>Async</code>结尾，意味着<code>Action</code>使用相同的线程执行，而<code>Async</code>可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</p><p>注意这几个方法都会返回<code>CompletableFuture</code>，当<code>Action</code>执行完毕后它的结果返回原始的<code>CompletableFuture</code>的计算结果或者返回异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMoreData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin to start compute&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end to start compute. passed &quot;</span> + (System.currentTimeMillis() - t)/<span class="number">1000</span> + <span class="string">&quot; seconds&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(Main::getMoreData);</span><br><span class="line">        Future&lt;Integer&gt; f = future.whenComplete((v, e) -&gt; &#123;</span><br><span class="line">            System.out.println(v);</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(f.get());</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exceptionally</code>方法返回一个新的CompletableFuture，当原始的CompletableFuture抛出异常的时候，就会触发这个CompletableFuture的计算，调用function计算值，否则如果原始的CompletableFuture正常计算完后，这个新的CompletableFuture也计算完成，它的值和原始的CompletableFuture的计算的值相同。也就是这个<code>exceptionally</code>方法用来处理异常的情况。</p><p>下面一组方法虽然也返回CompletableFuture对象，但是对象的值和原来的CompletableFuture计算的值不同。当原先的CompletableFuture的值计算完成或者抛出异常的时候，会触发这个CompletableFuture对象的计算，结果由<code>BiFunction</code>参数计算而得。因此这组方法兼有<code>whenComplete</code>和转换的两个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p>同样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。</p><h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><p><code>CompletableFuture</code>可以作为monad(单子)和functor。由于回调风格的实现，我们不必因为等待一个计算完成而阻塞着调用线程，而是告诉<code>CompletableFuture</code>当计算完成的时候请执行某个<code>function</code>。而且我们还可以将这些操作串联起来，或者将<code>CompletableFuture</code>组合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApplyAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p>这一组函数的功能是当原来的CompletableFuture计算完后，将结果传递给函数<code>fn</code>，将<code>fn</code>的结果作为新的<code>CompletableFuture</code>计算结果。因此它的功能相当于将<code>CompletableFuture&lt;T&gt;</code>转换成<code>CompletableFuture&lt;U&gt;</code>。</p><p>这三个函数的区别和上面介绍的一样，不以<code>Async</code>结尾的方法由原来的线程计算，以<code>Async</code>结尾的方法由默认的线程池<code>ForkJoinPool.commonPool()</code>或者指定的线程池<code>executor</code>运行。Java的CompletableFuture类总是遵循这样的原则，下面就不一一赘述了。</p><p>使用例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; f =  future.thenApplyAsync(i -&gt; i * <span class="number">10</span>).thenApply(i -&gt; i.toString());</span><br><span class="line">System.out.println(f.get()); <span class="comment">//&quot;1000&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这些转换并不是马上执行的，也不会阻塞，而是在前一个stage完成后继续执行。</p><p>它们与<code>handle</code>方法的区别在于<code>handle</code>方法会处理正常计算值和异常，因此它可以屏蔽异常，避免异常继续抛出。而<code>thenApply</code>方法只是用来处理正常值，因此一旦有异常就会抛出。</p><h2 id="纯消费-执行Action"><a href="#纯消费-执行Action" class="headerlink" title="纯消费(执行Action)"></a>纯消费(执行Action)</h2><p>上面的方法是当计算完成的时候，会生成新的计算结果(<code>thenApply</code>, <code>handle</code>)，或者返回同样的计算结果<code>whenComplete</code>，<code>CompletableFuture</code>还提供了一种处理结果的方法，只对结果执行<code>Action</code>,而不返回新的计算值，因此计算值为<code>Void</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAccept</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span></span><br></pre></td></tr></table></figure><p>看它的参数类型也就明白了，它们是函数式接口<code>Consumer</code>，这个接口只有输入，没有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Void&gt; f =  future.thenAccept(System.out::println);</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure><p><code>thenAcceptBoth</code>以及相关方法提供了类似的功能，当两个CompletionStage都正常完成计算的时候，就会执行提供的<code>action</code>，它用来组合另外一个异步的结果。<br><code>runAfterBoth</code>是当两个CompletionStage都正常完成计算的时候,执行一个Runnable，这个Runnable并不使用计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title function_">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U&gt; action, Executor executor)</span></span><br><span class="line"><span class="keyword">public</span>     CompletableFuture&lt;Void&gt; <span class="title function_">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,  Runnable action)</span></span><br></pre></td></tr></table></figure><p>例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Void&gt; f =  future.thenAcceptBoth(CompletableFuture.completedFuture(<span class="number">10</span>), (x, y) -&gt; System.out.println(x * y));</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure><p>更彻底地，下面一组方法当计算完成的时候会执行一个Runnable,与<code>thenAccept</code>不同，Runnable并不使用CompletableFuture计算的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRun</span><span class="params">(Runnable action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span><br></pre></td></tr></table></figure><p>因此先前的CompletableFuture计算的结果被忽略了,这个方法返回<code>CompletableFuture&lt;Void&gt;</code>类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Void&gt; f =  future.thenRun(() -&gt; System.out.println(<span class="string">&quot;finished&quot;</span>));</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure><blockquote><p>  因此，你可以根据方法的参数的类型来加速你的记忆。<code>Runnable</code>类型的参数会忽略计算的结果，<code>Consumer</code>是纯消费计算结果，<code>BiConsumer</code>会组合另外一个<code>CompletionStage</code>纯消费，<code>Function</code>会对计算结果做转换，<code>BiFunction</code>会组合另外一个<code>CompletionStage</code>的计算结果做转换。</p></blockquote><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenComposeAsync</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p>这一组方法接受一个Function作为参数，这个Function的输入是当前的CompletableFuture的计算值，返回结果将是一个新的CompletableFuture，这个新的CompletableFuture会组合原来的CompletableFuture和函数返回的CompletableFuture。因此它的功能类似:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A +--&gt; B +---&gt; C</span><br></pre></td></tr></table></figure><p>记住，<code>thenCompose</code>返回的对象并不一是函数<code>fn</code>返回的对象，如果原来的<code>CompletableFuture</code>还没有计算出来，它就会生成一个新的组合后的CompletableFuture。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; f =  future.thenCompose( i -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> (i * <span class="number">10</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(f.get()); <span class="comment">//1000</span></span><br></pre></td></tr></table></figure><p>而下面的一组方法<code>thenCombine</code>用来复合另外一个CompletionStage的结果。它的功能类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A +</span><br><span class="line">  |</span><br><span class="line">  +------&gt; C</span><br><span class="line">  +------^</span><br><span class="line">B +</span><br></pre></td></tr></table></figure><p>两个CompletionStage是并行执行的，它们之间并没有先后依赖顺序，<code>other</code>并不会等待先前的<code>CompletableFuture</code>执行完毕后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="title function_">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> U,? extends V&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><p>其实从功能上来讲,它们的功能更类似<code>thenAcceptBoth</code>，只不过<code>thenAcceptBoth</code>是纯消费，它的函数参数没有返回值，而<code>thenCombine</code>的函数参数<code>fn</code>有返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; f =  future.thenCombine(future2, (x,y) -&gt; y + <span class="string">&quot;-&quot;</span> + x);</span><br><span class="line">System.out.println(f.get()); <span class="comment">//abc-100</span></span><br></pre></td></tr></table></figure><h2 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h2><p><code>thenAcceptBoth</code>和<code>runAfterBoth</code>是当两个CompletableFuture都计算完成，而我们下面要了解的方法是当任意一个CompletableFuture计算完成的时候就会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="built_in">super</span> T&gt; action, Executor executor)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T,U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T,U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="built_in">super</span> T,U&gt; fn, Executor executor)</span></span><br><span class="line">acceptEither`方法是当任意一个CompletionStage完成的时候，`action`这个消费者就会被执行。这个方法返回`CompletableFuture&lt;Void&gt;</span><br></pre></td></tr></table></figure><p><code>applyToEither</code>方法是当任意一个CompletionStage完成的时候，<code>fn</code>会被执行，它的返回值会当作新的<code>CompletableFuture&lt;U&gt;</code>的计算结果。</p><p>下面这个例子有时会输出<code>100</code>,有时候会输出<code>200</code>,哪个Future先完成就会根据它的结果计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; f =  future.applyToEither(future2,i -&gt; i.toString());</span><br></pre></td></tr></table></figure><h2 id="辅助方法-allOf-和-anyOf"><a href="#辅助方法-allOf-和-anyOf" class="headerlink" title="辅助方法 allOf 和 anyOf"></a>辅助方法 <code>allOf</code> 和 <code>anyOf</code></h2><p>前面我们已经介绍了几个静态方法：<code>completedFuture</code>、<code>runAsync</code>、<code>supplyAsync</code>,下面介绍的这两个方法用来组合多个CompletableFuture。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt;     <span class="title function_">allOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title function_">anyOf</span><span class="params">(CompletableFuture&lt;?&gt;... cfs)</span></span><br></pre></td></tr></table></figure><p><code>allOf</code>方法是当所有的<code>CompletableFuture</code>都执行完后执行计算。</p><p><code>anyOf</code>方法是当任意一个<code>CompletableFuture</code>执行完后就会执行计算，计算的结果相同。</p><p>下面的代码运行结果有时是100,有时是”abc”。但是<code>anyOf</code>和<code>applyToEither</code>不同。<code>anyOf</code>接受任意多的CompletableFuture但是<code>applyToEither</code>只是判断两个CompletableFuture,<code>anyOf</code>返回值的计算结果是参数中其中一个CompletableFuture的计算结果，<code>applyToEither</code>返回值的计算结果却是要经过<code>fn</code>处理的。当然还有静态方法的区别，线程池的选择等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span> + rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//CompletableFuture&lt;Void&gt; f =  CompletableFuture.allOf(future1,future2);</span></span><br><span class="line">CompletableFuture&lt;Object&gt; f =  CompletableFuture.anyOf(future1,future2);</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure><p>我想通过上面的介绍，应该把CompletableFuture的方法和功能介绍完了(<code>cancel</code>、<code>isCompletedExceptionally()</code>、<code>isDone()</code>以及继承于Object的方法无需介绍了， <code>toCompletableFuture()</code>返回CompletableFuture本身)，希望你能全面了解CompletableFuture强大的功能，并将它应用到Java的异步编程中。如果你有使用它的开源项目，可以留言分享一下。</p><h2 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h2><p>如果你用过Guava的Future类，你就会知道它的<code>Futures</code>辅助类提供了很多便利方法，用来处理多个Future，而不像Java的CompletableFuture，只提供了<code>allOf</code>、<code>anyOf</code>两个方法。 比如有这样一个需求，将多个CompletableFuture组合成一个CompletableFuture，这个组合后的CompletableFuture的计算结果是个List,它包含前面所有的CompletableFuture的计算结果，guava的<code>Futures.allAsList</code>可以实现这样的功能，但是对于java CompletableFuture，我们需要一些辅助方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;List&lt;T&gt;&gt; <span class="title function_">sequence</span><span class="params">(List&lt;CompletableFuture&lt;T&gt;&gt; futures)</span> &#123;</span><br><span class="line">  CompletableFuture&lt;Void&gt; allDoneFuture = CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[futures.size()]));</span><br><span class="line">  <span class="keyword">return</span> allDoneFuture.thenApply(v -&gt; futures.stream().map(CompletableFuture::join).collect(Collectors.&lt;T&gt;toList()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;Stream&lt;T&gt;&gt; <span class="title function_">sequence</span><span class="params">(Stream&lt;CompletableFuture&lt;T&gt;&gt; futures)</span> &#123;</span><br><span class="line">  List&lt;CompletableFuture&lt;T&gt;&gt; futureList = futures.filter(f -&gt; f != <span class="literal">null</span>).collect(Collectors.toList());</span><br><span class="line">  <span class="keyword">return</span> sequence(futureList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者Java Future转CompletableFuture:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; CompletableFuture&lt;T&gt; <span class="title function_">toCompletable</span><span class="params">(Future&lt;T&gt; future, Executor executor)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>github有多个项目可以实现Java CompletableFuture与其它Future (如Guava ListenableFuture)之间的转换，如<a href="https://github.com/spotify/futures-extra">spotify/futures-extra</a>、<a href="https://github.com/lukas-krecan/future-converter">future-converter</a>、<a href="https://github.com/scala/scala-java8-compat/blob/master/src/main/scala/scala/compat/java8/FutureConverters.scala">scala/scala-java8-compat </a>等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Rust基础入门（一）</title>
      <link href="/2022/03/8d1e485b5f22.html"/>
      <url>/2022/03/8d1e485b5f22.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-变量绑定与解构"><a href="#2-1-变量绑定与解构" class="headerlink" title="2.1 变量绑定与解构"></a>2.1 变量绑定与解构</h2><h3 id="为何-Rust-选择了手动设定变量的可变性"><a href="#为何-Rust-选择了手动设定变量的可变性" class="headerlink" title="为何 Rust 选择了手动设定变量的可变性"></a>为何 <code>Rust</code> 选择了手动设定变量的可变性</h3><p>一般来说，变量一旦创建，要么可变（灵活）或者不可变（安全），而 <code>Rust</code> 的变量两者都具有。</p><h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;akira&quot;</span></span><br></pre></td></tr></table></figure><h3 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h3><p><code>Rust</code> 的变量在默认情况下是<strong><em>不可变的</em></strong>，可以通过 <code>mut</code> 关键字让变量变为<strong><em>可变的</em></strong></p><p>编写代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run          </span><br><span class="line">   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"> --&gt; src/main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> x = 5;</span><br><span class="line">  |         -</span><br><span class="line">  |         |</span><br><span class="line">  |         first assignment to `x`</span><br><span class="line">  |         <span class="built_in">help</span>: consider making this binding mutable: `mut x`</span><br><span class="line">3 |     println!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br><span class="line">error: could not compile `variables` due to previous error</span><br></pre></td></tr></table></figure><p>具体的错误原因是 <code>cannot assign twice to immutable variable x</code></p><p>修改代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>再次运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.39s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><p>可变还是不可变，更多的还是取决于你的使用场景：灵活与安全之间的抉择。可变变量最大的好处就是使用上的灵活性和性能上的提升。</p><h3 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h3><p><code>let</code> 表达式用于变量的绑定，也可以进行复杂变量的解构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (a, <span class="keyword">mut</span> b): (<span class="type">bool</span>,<span class="type">bool</span>) = (<span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// a = true,不可变; b = false，可变</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;:?&#125;, b = &#123;:?&#125;&quot;</span>, a, b);</span><br><span class="line"></span><br><span class="line">    b = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构式赋值"><a href="#解构式赋值" class="headerlink" title="解构式赋值"></a>解构式赋值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (a, b, c, d, e);</span><br><span class="line"></span><br><span class="line">    (a, b) = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    [c, .., d, _] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    Struct &#123; e, .. &#125; = Struct &#123; e: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [a, b, c, d, e]);</span><br></pre></td></tr></table></figure><blockquote><p>  这种使用方式跟之前的 <code>let</code> 保持了一致性，但是 <code>let</code> 会重新绑定，而这里仅仅是对之前绑定的变量进行再赋值。</p><p>  使用 <code>+=</code> 的赋值语句还不支持解构式赋值</p></blockquote><h3 id="变量与常量之间的差异"><a href="#变量与常量之间的差异" class="headerlink" title="变量与常量之间的差异"></a>变量与常量之间的差异</h3><ul><li>常量不允许使用 <code>mut</code>。<strong>常量不仅仅默认不可变，而且自始至终不可变</strong>，因为常量在编译完成后，已经确定它的值。</li><li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明，并且值的类型<strong>必须</strong>标注。</li></ul><h3 id="变量遮蔽-shadowing"><a href="#变量遮蔽-shadowing" class="headerlink" title="变量遮蔽(shadowing)"></a>变量遮蔽(shadowing)</h3><p><code>Rust</code> 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 在main函数的作用域内对之前的x进行遮蔽</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling variables v0.1.0 (/Users/akira/rustCode/learnRust/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.28s</span><br><span class="line">     Running `./variables`</span><br><span class="line">var shadowing</span><br><span class="line">The value of x <span class="keyword">in</span> the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure><blockquote><p>  多次的<code>let</code>声明了多个同名变量，使用更多内存</p><p>  <code>mut</code>只是修改同一内存地址上的值，不会发生内存对象的再分配，性能要更好</p></blockquote><p>变量遮蔽的作用：<br>如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），可以重复的使用变量名字</p><h2 id="2-2-基本类型"><a href="#2-2-基本类型" class="headerlink" title="2.2 基本类型"></a>2.2 基本类型</h2><ul><li>数值类型: 有符号整数 (<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>isize</code>)、 无符号整数 (<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>usize</code>) 、浮点数 (<code>f32</code>, <code>f64</code>)、以及有理数、复数</li><li>字符串：字符串字面量和字符串切片 <code>&amp;str</code></li><li>布尔类型： <code>true</code>和<code>false</code></li><li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li><li>单元类型: 即 <code>()</code> ，其唯一的值也是 <code>()</code></li></ul><p><code>Rust</code> 是一门<strong>静态类型</strong>语言，也就是编译器必须在编译期知道我们所有变量的类型，但这不意味着你需要为每个变量指定类型，因为 <strong>Rust 编译器很聪明，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型</strong></p><h3 id="2-2-1-数值类型"><a href="#2-2-1-数值类型" class="headerlink" title="2.2.1 数值类型"></a>2.2.1 数值类型</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>类型定义的形式统一为：<code>有无符号 + 类型大小(位数)</code></p><p> eg: </p><p>有符号类型：i8，i16，i32（默认类型），i64，i128，isize（视架构而定）</p><p>无符号类型：u8，u16，u32，u64，u128，usize（视架构而定）</p><blockquote><p>整型溢出：</p><p>debug 模式下会检测数值溢出，造成编译失败（<code>panic</code>）</p><p>—release 模式下不会检测溢出，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理</p><p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p><ul><li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li><li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li><li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li><li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li></ul></blockquote><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>两种基本类型： <code>f32</code> 和 <code>f64</code>（默认）</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>对于数学上未定义的结果，使用<code>NaN</code>来处理</p><p>可以使用 <code>is_nan()</code> 等方法，可以用来判断一个数值是否是 <code>NaN</code> </p><h4 id="序列（Range）"><a href="#序列（Range）" class="headerlink" title="序列（Range）"></a>序列（<code>Range</code>）</h4><p>序列只允许用于数字或字符类型，原因是：它们可以连续。</p><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">output: </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>Rust 拥有相当多的数值类型</strong>. 熟悉类型占用的字节数与范围</li><li><strong>类型转换必须是显式的</strong></li><li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code></li></ul><h3 id="2-2-2-字符、布尔、单元类型"><a href="#2-2-2-字符、布尔、单元类型" class="headerlink" title="2.2.2 字符、布尔、单元类型"></a>2.2.2 字符、布尔、单元类型</h3><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><p>Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">z</span> = <span class="string">&#x27;ℤ&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">g</span> = <span class="string">&#x27;国&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart_eyed_cat</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  Rust 的字符只能用 <code>&#39;&#39;</code> 来表示， <code>&quot;&quot;</code> 是留给字符串的</p></blockquote><h4 id="布尔（bool）"><a href="#布尔（bool）" class="headerlink" title="布尔（bool）"></a>布尔（bool）</h4><p>布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>，大小为 <code>1</code> 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>; <span class="comment">// 使用类型标注,显式指定f的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> f &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是段毫无意义的代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h4><p>单元类型就是 <code>()</code>，唯一的值也是 <code>()</code> 。</p><p><code>main</code> 函数就返回这个单元类型 <code>()</code></p><p>没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数</code></p><h3 id="2-2-3-语句和表达式"><a href="#2-2-3-语句和表达式" class="headerlink" title="2.2.3 语句和表达式"></a>2.2.3 语句和表达式</h3><p>Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add_with_extra</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = y + <span class="number">5</span>; <span class="comment">// 语句</span></span><br><span class="line">    x + y <span class="comment">// 表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式会在求值后返回一个值</p><h3 id="2-2-4-函数"><a href="#2-2-4-函数" class="headerlink" title="2.2.4 函数"></a>2.2.4 函数</h3><p><img src="https://s2.loli.net/2022/03/10/nD7mvPi43Xpe9Of.png" alt="img"></p><h4 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h4><ul><li>函数名和变量名使用 <code>snake case</code> 例如 <code>fn add_two() -&gt; &#123;&#125;</code></li><li>函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可</li><li>每个函数参数都需要标注类型</li></ul><h4 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h4><p>函数的返回值就是函数体最后一条表达式的返回值，也可以使用 <code>return</code> 提前返回。</p><h4 id="Rust-中特殊的返回类型"><a href="#Rust-中特殊的返回类型" class="headerlink" title="Rust 中特殊的返回类型"></a><code>Rust</code> 中特殊的返回类型</h4><h5 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值 ()"></a>无返回值 <code>()</code></h5><p>单元类型 <code>()</code>，是一个零长度的元组。它没啥作用，但是可以用来表达一个函数没有返回值：</p><ul><li>函数没有返回值，那么返回一个 <code>()</code></li><li>通过 <code>;</code> 结尾的表达式返回一个 <code>()</code></li></ul><h5 id="永不返回的函数"><a href="#永不返回的函数" class="headerlink" title="永不返回的函数 !"></a>永不返回的函数 <code>!</code></h5><p>用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回</p><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">forever</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">  <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-所有权与借用⭐️"><a href="#2-3-所有权与借用⭐️" class="headerlink" title="2.3 所有权与借用⭐️"></a>2.3 所有权与借用⭐️</h2><h3 id="2-3-1-所有权"><a href="#2-3-1-所有权" class="headerlink" title="2.3.1 所有权"></a>2.3.1 所有权</h3><p>如何管理系统内存：</p><ul><li><strong>垃圾回收机制(GC)</strong>，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go</li><li><strong>手动管理内存的分配和释放</strong>, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++</li><li><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查</li></ul><p>通过所有权来管理内存检查只发生在编译期，运行期不会有性能损耗</p><h4 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h4><ol><li>Rust 中每一个值都 <code>有且只有</code> 一个所有者(变量)</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li></ol><p>对于简单类型的变量：栈上直接将数据拷贝，赋值给新变量</p><p>对于复杂类型的变量：复杂对象的指针赋值给新的变量会导致旧的指针变量失效 =&gt; 对此复杂对象的所有权转移</p><blockquote><p>  以 <code>String</code> 为例思考：</p><p>  <code>String</code> 类型指向了一个堆上的空间，存储着它的真实数据, 对于代码中的 <code>let s2 = s1</code> 分成两种情况讨论：</p><ol><li>拷贝 <code>String</code> 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 <code>String</code> 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</li><li>只拷贝 <code>String</code> 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 <code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计 24 字节，但是带来了新的问题，根据所有权规则，其中一条：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：<code>s1</code> 和 <code>s2</code>。假定一个值可以拥有两个所有者，就会导致 <strong>二次释放（double free）</strong> 的错误。</li></ol></blockquote><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0382]: <span class="keyword">use</span> of moved value: `s1`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">5</span>:<span class="number">28</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">  |         -- value moved here</span><br><span class="line"><span class="number">4</span> |</span><br><span class="line"><span class="number">5</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br><span class="line">  |                            ^^ value used here after <span class="keyword">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: <span class="keyword">move</span> occurs because `s1` has <span class="keyword">type</span> `std::string::<span class="type">String</span>`, which does</span><br><span class="line">  not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br></pre></td></tr></table></figure><p>❗️此时再思考 <strong>变量绑定</strong> 与 <strong>变量赋值</strong> 语义上的区别</p><h4 id="克隆（深拷贝）"><a href="#克隆（深拷贝）" class="headerlink" title="克隆（深拷贝）"></a>克隆（深拷贝）</h4><p><strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>  =&gt; 任何<strong>自动</strong>的复制都不是深拷贝</p><p> 使用 <code>clone()</code> 进行深拷贝</p><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">s1 = hello, s2 = hello</span><br></pre></td></tr></table></figure><h4 id="拷贝（浅拷贝）"><a href="#拷贝（浅拷贝）" class="headerlink" title="拷贝（浅拷贝）"></a>拷贝（浅拷贝）</h4><p>浅拷贝只发生在栈</p><p>Rust 有一个叫做 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 <code>Copy</code> 特征，一个旧的变量在被赋值给其他变量后仍然可用。</p><p> <strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code>。</li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code>。</li><li>所有浮点数类型，比如 <code>f64</code>。</li><li>字符类型，<code>char</code>。</li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是。</li><li>引用类型</li></ul><h4 id="函数传值与返回"><a href="#函数传值与返回" class="headerlink" title="函数传值与返回"></a>函数传值与返回</h4><p>将值传递给函数，一样会发生 <code>移动</code> 或者 <code>复制</code>，就跟 <code>let</code> 语句一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// s 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s);             <span class="comment">// s 的值移动到函数里 ...</span></span><br><span class="line">                                    <span class="comment">// ... 所以到这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// some_integer 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 这里，some_integer 移出作用域。不会有特殊操作</span></span><br></pre></td></tr></table></figure><p>同样的，函数返回值也有所有权，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();         <span class="comment">// gives_ownership 将返回值</span></span><br><span class="line">                                        <span class="comment">// 移给 s1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// s2 进入作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="comment">// s2 被移动到</span></span><br><span class="line">                                        <span class="comment">// takes_and_gives_back 中,</span></span><br><span class="line">                                        <span class="comment">// 它也将返回值移给 s3</span></span><br><span class="line">&#125; <span class="comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">// gives_ownership 将返回值移动给</span></span><br><span class="line">                                             <span class="comment">// 调用它的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line"></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将传入字符串并返回该值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-引用与借用"><a href="#2-3-2-引用与借用" class="headerlink" title="2.3.2 引用与借用"></a>2.3.2 引用与借用</h3><p>如果仅仅使用变量的指针或者引用，而非获得所有权，可以通过 <code>借用(Borrowing)</code> ，<strong>获取变量的引用，称之为借用(borrowing)</strong>。</p><h4 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x; <span class="comment">// 获取指向x的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y); <span class="comment">// 通过 `*` 解引用，得到y所指向的数据 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h4><p>下面的代码，我们用 <code>s1</code> 的引用作为参数传递给 <code>calculate_length</code> 函数，而不是把 <code>s1</code> 的所有权转移给该函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">The length of <span class="symbol">&#x27;hell</span>o<span class="string">&#x27; is 5.</span></span><br></pre></td></tr></table></figure><p>变化过程：</p><p><img src="https://s2.loli.net/2022/03/13/bnqGQHhCDvy2pF7.jpg" alt="&amp;String s pointing at String s1"></p><h4 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h4><p>通过 <code>mut</code> 关键字，可以操作引用所指向的数据</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s is :&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">s is :hello, world</span><br></pre></td></tr></table></figure><p>它有一个很大的限制： <strong>同一作用域，特定数据只能有一个可变引用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0499]: cannot borrow `s` <span class="keyword">as</span> mutable more than once at a time</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">10</span>:<span class="number">14</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">9</span>  |     <span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">   |              ------ first mutable borrow occurs here</span><br><span class="line"><span class="number">10</span> |     <span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">   |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line"><span class="number">11</span> | </span><br><span class="line"><span class="number">12</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">   |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0499`.</span><br><span class="line">error: could not compile `hello_world` due to previous error</span><br></pre></td></tr></table></figure><h5 id="可变引用与不可变引用不能同时存在"><a href="#可变引用与不可变引用不能同时存在" class="headerlink" title="可变引用与不可变引用不能同时存在"></a>可变引用与不可变引用不能同时存在</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r2</span> = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r3</span> = &amp;<span class="keyword">mut</span> s; <span class="comment">// 大问题</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="悬垂引用-Dangling-References"><a href="#悬垂引用-Dangling-References" class="headerlink" title="悬垂引用(Dangling References)"></a>悬垂引用(Dangling References)</h4><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">11</span>:<span class="number">16</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">   |                ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but there is no value <span class="keyword">for</span> <span class="title class_">it</span> to be borrowed from</span><br><span class="line">help: consider using the `<span class="symbol">&#x27;static</span>` lifetime</span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="type">String</span> &#123;</span><br><span class="line">   |                ~~~~~~~~</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br><span class="line">error: could not compile `hello_world` due to previous error</span><br></pre></td></tr></table></figure><h4 id="借用规则总结"><a href="#借用规则总结" class="headerlink" title="借用规则总结"></a>借用规则总结</h4><p>总的来说，借用规则如下：</p><ul><li>同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用</li><li>引用必须总是有效的</li></ul><h2 id="2-4-复合类型"><a href="#2-4-复合类型" class="headerlink" title="2.4 复合类型"></a>2.4 复合类型</h2><p>复合类型是由其它类型组合而成的，最典型的就是结构体 <code>struct</code> 和枚举 <code>enum</code>。</p><h3 id="2-4-1-字符串和切片"><a href="#2-4-1-字符串和切片" class="headerlink" title="2.4.1 字符串和切片"></a>2.4.1 字符串和切片</h3><p>Will it be success?</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_name</span> = <span class="string">&quot;Akira&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">greet</span>(my_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">3</span>:<span class="number">11</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     <span class="title function_ invoke__">greet</span>(my_name);</span><br><span class="line">  |           ^^^^^^^- help: <span class="keyword">try</span> using a conversion method: `.<span class="title function_ invoke__">to_string</span>()`</span><br><span class="line">  |           |</span><br><span class="line">  |           expected <span class="keyword">struct</span> `<span class="type">String</span>`, found `&amp;<span class="type">str</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `string` due to previous error</span><br></pre></td></tr></table></figure><h4 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h4><p>切片允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p><p>创建切片的语法，使用方括号包括的一个序列: <strong>[开始索引..终止索引]</strong>，是这是一个 <code>左闭右开区间</code>。</p><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, hello, world);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>切片解析：</p><p><img src="https://s2.loli.net/2022/03/14/nhHQXYtfuUKOdsA.jpg" alt="img" style="zoom:20%;" /></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取前两个字节数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>]; </span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取完整字节数据</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">0</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure><blockquote><p>  对字符串进行切片，需要注意字符串的编码，否则导致程序会直接崩溃退出<br>  eg:</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;中国人&quot;</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">a</span> = &amp;s[<span class="number">0</span>..<span class="number">2</span>];</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">thread <span class="symbol">&#x27;mai</span>n<span class="string">&#x27; panicked at &#x27;</span>byte index <span class="number">2</span> is not a <span class="type">char</span> boundary; it is inside <span class="string">&#x27;中&#x27;</span> (bytes <span class="number">0</span>..<span class="number">3</span>) of `中国人`<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h4><p>字符串变量的类型是 <code>&amp;str</code></p><p>eg:<code>let s: &amp;str = &quot;Hello, world!&quot;;</code></p><h4 id="什么是字符串？"><a href="#什么是字符串？" class="headerlink" title="什么是字符串？"></a>什么是字符串？</h4><p><strong><code>Rust</code> 中字符串 <code>UTF-8</code> 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)</strong>。</p><p><code>String</code> 是一个可增长、可改变且具有所有权的 UTF-8 编码字符串</p><p><strong>当 Rust 用户提到字符串时，往往指的就是 <code>String</code> 类型和 <code>&amp;str</code> 字符串切片类型，这两个类型都是 UTF-8 编码</strong>。</p><h5 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个空String</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 将&amp;str类型的&quot;hello,world&quot;添加到s中</span></span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    <span class="comment">// 将字符&#x27;!&#x27;推入s中</span></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 最后s的内容是&quot;hello,world!&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s,<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从现有的&amp;str切片创建String类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="string">&quot;hello,world&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">    <span class="comment">// 将字符&#x27;!&#x27;推入s中</span></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 最后s的内容是&quot;hello,world!&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s,<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从现有的&amp;str切片创建String类型</span></span><br><span class="line">    <span class="comment">// String与&amp;str都是UTF-8编码，因此支持中文</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;你好,世界&quot;</span>);</span><br><span class="line">    <span class="comment">// 将字符&#x27;!&#x27;推入s中</span></span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    <span class="comment">// 最后s的内容是&quot;你好,世界!&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s,<span class="string">&quot;你好,世界!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 在下句中，s1的所有权被转移走了，因此后面不能再使用s1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s3,<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="comment">// 下面的语句如果去掉注释，就会报错</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;&#125;&quot;,s1);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="String-与-amp-str-的转换"><a href="#String-与-amp-str-的转换" class="headerlink" title="String 与 &amp;str 的转换"></a>String 与 &amp;str 的转换</h5><ol><li><p><code>&amp;str</code> 类型生成 <code>String</code> 类型</p><ul><li><code>String::from(&quot;hello,world&quot;)</code></li><li><code>&quot;hello,world&quot;.to_string()</code></li></ul></li><li><p><code>String</code> 类型转为 <code>&amp;str</code> 类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h5><p>字符串的底层是[ <code>u8</code> ]，一个字节数组。对于不同类型字符的字符串，索引下的字符可能无意义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0277]: the <span class="keyword">type</span> `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">63</span>:<span class="number">13</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">63</span> |     <span class="keyword">let</span> <span class="variable">h</span> = s1[<span class="number">0</span>];</span><br><span class="line">   |             ^^^^^ `<span class="type">String</span>` cannot be indexed by `&#123;integer&#125;`</span><br><span class="line">   |</span><br><span class="line">   = help: the <span class="keyword">trait</span> `Index&lt;&#123;integer&#125;&gt;` is not implemented <span class="keyword">for</span> `<span class="type">String</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0277`.</span><br><span class="line">error: could not compile `string` due to previous error</span><br></pre></td></tr></table></figure><blockquote><p>  另一个原因导致了 Rust 不允许去索引字符串：因为索引操作，我们总是期望它的性能表现是 O(1)，然而对于 <code>String</code> 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符。</p></blockquote><h5 id="操作-UTF8-字符串"><a href="#操作-UTF8-字符串" class="headerlink" title="操作 UTF8 字符串"></a>操作 <code>UTF8</code> 字符串</h5><p>以 Unicode 字符的方式遍历字符串，最好的办法是使用 <code>chars</code> 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">中</span><br><span class="line">国</span><br><span class="line">人</span><br></pre></td></tr></table></figure><p>返回字符串的底层字节数组表现形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">b</span> <span class="keyword">in</span> <span class="string">&quot;中国人&quot;</span>.<span class="title function_ invoke__">bytes</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">228</span></span><br><span class="line"><span class="number">184</span></span><br><span class="line"><span class="number">173</span></span><br><span class="line"><span class="number">229</span></span><br><span class="line"><span class="number">155</span></span><br><span class="line"><span class="number">189</span></span><br><span class="line"><span class="number">228</span></span><br><span class="line"><span class="number">186</span></span><br><span class="line"><span class="number">186</span></span><br></pre></td></tr></table></figure><h5 id="字符串深度剖析"><a href="#字符串深度剖析" class="headerlink" title="字符串深度剖析"></a>字符串深度剖析</h5><p>为啥 <code>String</code> 可变，而字符串字面值 <code>str</code> 却不可以？</p><p>字符串字面值在编译时直接硬编码进可执行文件中，快速且高效。</p><p><code>String</code> 类型的存在为了支持一个可变的文本串，需要在堆上分配未知大小的内存来存放。</p><p>在程序运行时：</p><ul><li>首先向操作系统请求内存来存放 <code>String</code> 对象</li><li>在使用完成后，将内存释放，归还给操作系统</li></ul><h3 id="2-4-2-元组"><a href="#2-4-2-元组" class="headerlink" title="2.4.2 元组"></a>2.4.2 元组</h3><p>元组是由多种类型组合到一起形成的，长度固定，顺序固定。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>使用模式匹配或者 <code>.</code> 操作符来获取元组中的值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span> = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">five_hundred</span> = x.<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">six_point_four</span> = x.<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">one</span> = x.<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-结构体"><a href="#2-4-3-结构体" class="headerlink" title="2.4.3 结构体"></a>2.4.3 结构体</h3><p>一个结构体有几部分组成：</p><ul><li>通过关键字 <code>struct</code> 定义</li><li>一个清晰明确的结构体 <code>名称</code></li><li>几个有名字的结构体 <code>字段</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">    username: <span class="type">String</span>,</span><br><span class="line">    email: <span class="type">String</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>❗️注意</p><ol><li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li><li>初始化时的字段顺序<strong>不需要</strong>和结构体定义时的顺序一致</li></ol><p>通过 <code>.</code> 操作符即可操作结构体实例内部的字段值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure><p>❗️注意</p><p>只有结构体实例声明为可变的，才能修改其中的字段，不支持结构体内部字段可变</p><h4 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">eg1:</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">eg2:</span><br><span class="line"><span class="comment">// 当函数参数和结构体字段同名时，可以直接使用缩略</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h4><p>根据已有的结构体实例，创建新的结构体实例:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Method1：</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        active: user1.active,</span><br><span class="line">        username: user1.username,</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        sign_in_count: user1.sign_in_count,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">Method2：</span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">        email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">  <span class="comment">// .. 语法表明凡是我们没有显示声明的字段全部从 user1 中自动获取</span></span><br><span class="line">  <span class="comment">// ..user1 必须在结构体的尾部使用</span></span><br><span class="line">        ..user1</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>  结构体更新语法跟赋值语句 <code>=</code> 非常相像，因此在上面代码中，<code>user1</code> 的部分字段所有权被转移到 <code>user2</code> 中：<code>username</code> 字段发生了所有权转移，作为结果，<code>user1</code> 无法再被使用。但是并不代表 <code>user1</code> 内部的其它字段不能被继续使用，例如：</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">       email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">       username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">       active: <span class="literal">true</span>,</span><br><span class="line">       sign_in_count: <span class="number">1</span>,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">       active: user1.active,</span><br><span class="line">       username: user1.username,</span><br><span class="line">       email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">       sign_in_count: user1.sign_in_count,</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, user1.active);</span><br><span class="line">   <span class="comment">// 下面这行会报错</span></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, user1);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0382]: borrow of partially moved value: `user1`</span><br><span class="line"> -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">68</span>:<span class="number">22</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">62</span> |         username: user1.username,</span><br><span class="line">  |                   -------------- value partially moved here</span><br><span class="line">...</span><br><span class="line"><span class="number">68</span> |     <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, user1);</span><br><span class="line">  |                      ^^^^^ value borrowed here after partial <span class="keyword">move</span></span><br><span class="line">  |</span><br><span class="line">  = note: partial <span class="keyword">move</span> occurs because `user1.username` has <span class="keyword">type</span> `<span class="type">String</span>`, which does not implement the `<span class="built_in">Copy</span>` <span class="keyword">trait</span></span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the <span class="keyword">macro</span> `$crate::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z <span class="keyword">macro</span>-backtrace <span class="keyword">for</span> <span class="variable">more</span> <span class="keyword">in</span>fo)</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0382`.</span><br><span class="line">warning: `<span class="keyword">struct</span>-demo` (bin <span class="string">&quot;struct-demo&quot;</span>) generated <span class="number">1</span> warning</span><br><span class="line">error: could not compile `<span class="keyword">struct</span>-demo` due to previous error; <span class="number">1</span> warning emitted</span><br></pre></td></tr></table></figure></blockquote><h4 id="结构体的内存排列"><a href="#结构体的内存排列" class="headerlink" title="结构体的内存排列"></a>结构体的内存排列</h4><p>code example：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">   name: <span class="type">String</span>,</span><br><span class="line">   data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">f1</span> = File &#123;</span><br><span class="line">     name: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;f1.txt&quot;</span>),</span><br><span class="line">     data: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> <span class="variable">f1_name</span> = &amp;f1.name;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">f1_length</span> = &amp;f1.data.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, f1);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125; bytes long&quot;</span>, f1_name, f1_length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>内存排列如图：</p><p><img src="https://s2.loli.net/2022/03/15/coq7TkyLaYuJVfW.png" alt="image-20220315133114763"></p><h4 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h4><p>结构体的字段可以没有名称：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a>单元结构体</h4><p>如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用 <code>单元结构体</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">subject</span> = AlwaysEqual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">SomeTrait</span> <span class="keyword">for</span> <span class="title class_">AlwaysEqual</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h4><p>如果想让结构体从其它对象借用数据，就必须加入<strong>生命周期</strong> ，保证结构体的作用范围小于借用数据的作用范围。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username: &amp;<span class="type">str</span>,</span><br><span class="line">    email: &amp;<span class="type">str</span>,</span><br><span class="line">    sign_in_count: <span class="type">u64</span>,</span><br><span class="line">    active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">        email: <span class="string">&quot;someone@example.com&quot;</span>,</span><br><span class="line">        username: <span class="string">&quot;someusername123&quot;</span>,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-枚举"><a href="#2-4-4-枚举" class="headerlink" title="2.4.4 枚举"></a>2.4.4 枚举</h3><p>枚举(<code>enum</code> 或 <code>enumeration</code>)允许你通过列举可能的成员来定义一个<strong>枚举类型</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扑克花色</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerSuit</span> &#123;</span><br><span class="line">  Clubs,</span><br><span class="line">  Spades,</span><br><span class="line">  Diamonds,</span><br><span class="line">  Hearts,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h4><p>创建 <code>PokerSuit</code> 枚举类型的两个成员实例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">heart</span> = PokerSuit::Hearts;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">diamond</span> = PokerSuit::Diamonds;</span><br></pre></td></tr></table></figure><p>所以你可以这样使用它：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">heart</span> = PokerSuit::Hearts;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">diamond</span> = PokerSuit::Diamonds;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">print_suit</span>(heart);</span><br><span class="line">    <span class="title function_ invoke__">print_suit</span>(diamond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_suit</span>(card: PokerSuit) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,card);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hearts</span><br><span class="line">Diamonds</span><br></pre></td></tr></table></figure><p>为了让枚举更加使用， 我们可以这样定义枚举类型，直接将数据信息关联到枚举成员上：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">PokerCard</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Clubs</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Spades</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Diamonds</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Hearts</span>(<span class="type">u8</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c1</span> = PokerCard::<span class="title function_ invoke__">Spades</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c2</span> = PokerCard::<span class="title function_ invoke__">Diamonds</span>(<span class="number">13</span>);</span><br><span class="line">    <span class="title function_ invoke__">print_card</span>(c1);</span><br><span class="line">    <span class="title function_ invoke__">print_card</span>(c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_card</span>(card: PokerCard) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, card);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="title function_ invoke__">Spades</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_ invoke__">Diamonds</span>(<span class="number">13</span>)</span><br></pre></td></tr></table></figure><h4 id="Option-枚举处理空值"><a href="#Option-枚举处理空值" class="headerlink" title="Option 枚举处理空值"></a>Option 枚举处理空值</h4><p><code>Rust</code> 抛弃 <code>null</code> ，使用 <code>Option</code> 枚举变量来表述这种结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-5-数组"><a href="#2-4-5-数组" class="headerlink" title="2.4.5 数组"></a>2.4.5 数组</h3><p>在 Rust 中，最常用的数组有两种，第一种是速度很快但是长度固定的 <code>array</code>，第二种是可动态增长的但是有性能损耗的 <code>Vector</code>。</p><p>数组的三要素：</p><ul><li>长度固定</li><li>元素必须有相同的类型</li><li>依次线性排列</li></ul><h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个值重复出现 N 次的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span> ; <span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>数组存储在栈上，动态数组存储在堆上。</p><h4 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h4><p>数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>]; <span class="comment">// 获取a数组第一个元素</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">second</span> = a[<span class="number">1</span>]; <span class="comment">// 获取第二个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Please enter an array index.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="comment">// 读取控制台的输出</span></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">        .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">parse</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Index entered was not a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">element</span> = a[index];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The value of the element at index &#123;&#125; is: &#123;&#125;&quot;</span>,</span><br><span class="line">        index, element</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span>: &amp;[<span class="type">i32</span>] = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(slice, &amp;[<span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 编译器自动推导出one的类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">one</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 显式类型标注</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">two</span>: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">blank1</span> = [<span class="number">0</span>; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">blank2</span>: [<span class="type">u8</span>; <span class="number">3</span>] = [<span class="number">0</span>; <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arrays</span>: [[<span class="type">u8</span>; <span class="number">3</span>]; <span class="number">4</span>] = [one, two, blank1, blank2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 借用arrays的元素用作循环中</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">a</span> <span class="keyword">in</span> &amp;arrays &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;:?&#125;: &quot;</span>, a);</span><br><span class="line">        <span class="comment">// 将a变成一个迭代器，用于循环</span></span><br><span class="line">        <span class="comment">// 你也可以直接用for n in a &#123;&#125;来进行循环</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">n</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;</span>, n, n + <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;</span>, a, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:      <span class="number">1</span> + <span class="number">10</span> = <span class="number">11</span>     <span class="number">2</span> + <span class="number">10</span> = <span class="number">12</span>     <span class="number">3</span> + <span class="number">10</span> = <span class="number">13</span>     ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = <span class="number">6</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:      <span class="number">1</span> + <span class="number">10</span> = <span class="number">11</span>     <span class="number">2</span> + <span class="number">10</span> = <span class="number">12</span>     <span class="number">3</span> + <span class="number">10</span> = <span class="number">13</span>     ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] = <span class="number">6</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]:      <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] = <span class="number">0</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]:      <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     <span class="number">0</span> + <span class="number">10</span> = <span class="number">10</span>     ([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="2-5-流程控制"><a href="#2-5-流程控制" class="headerlink" title="2.5 流程控制"></a>2.5 流程控制</h2><h3 id="if分支控制"><a href="#if分支控制" class="headerlink" title="if分支控制"></a><code>if</code>分支控制</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition == <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="comment">// A...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// B...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">The value of number is: <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p> Rust 语言中有三种循环方式：<code>for</code>、<code>while</code> 和 <code>loop</code></p><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for</code> 循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 元素 <span class="keyword">in</span> 集合 &#123;</span><br><span class="line">  <span class="comment">// 使用元素干一些你懂我不懂的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><div class="table-container"><table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody><tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr><tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr><tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr></tbody></table></div><h4 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a><code>While</code> 循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> n &lt;= <span class="number">5</span>  &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">        n = n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;我出来了！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">0</span>!</span><br><span class="line"><span class="number">1</span>!</span><br><span class="line"><span class="number">2</span>!</span><br><span class="line"><span class="number">3</span>!</span><br><span class="line"><span class="number">4</span>!</span><br><span class="line"><span class="number">5</span>!</span><br><span class="line">我出来了！</span><br></pre></td></tr></table></figure><h4 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a><code>loop</code> 循环</h4><p> <code>loop</code> 是一个简单的无限循环，你可以在内部实现逻辑通过 <code>break</code> 关键字来控制循环何时结束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">The result is <span class="number">20</span></span><br></pre></td></tr></table></figure><p>这里有几点值得注意：</p><ul><li><strong>break 可以单独使用，也可以带一个返回值</strong>，有些类似 <code>return</code></li><li><strong>loop 是一个表达式</strong>，因此可以返回一个值</li></ul><h2 id="2-6-模式匹配"><a href="#2-6-模式匹配" class="headerlink" title="2.6 模式匹配"></a>2.6 模式匹配</h2><h3 id="2-6-1-match-和-if-let"><a href="#2-6-1-match-和-if-let" class="headerlink" title="2.6.1 match 和 if let"></a>2.6.1 <code>match</code> 和 <code>if let</code></h3><p>在 Rust 中，模式匹配最常用的就是 <code>match</code> 和 <code>if let</code></p><p><code>match</code> 类似其他语言中的 <code>switch</code></p><h3 id="match形式"><a href="#match形式" class="headerlink" title="match形式"></a><code>match</code>形式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> target &#123;</span><br><span class="line">    模式<span class="number">1</span> =&gt; 表达式<span class="number">1</span>,</span><br><span class="line">    模式<span class="number">2</span> =&gt; &#123;</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        表达式<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    _ =&gt; 表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg :</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    East,</span><br><span class="line">    West,</span><br><span class="line">    North,</span><br><span class="line">    South,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">dire</span> = Direction::South;</span><br><span class="line">    <span class="keyword">match</span> dire &#123;</span><br><span class="line">        Direction::East =&gt; <span class="built_in">println!</span>(<span class="string">&quot;East&quot;</span>),</span><br><span class="line">        Direction::North | Direction::South =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;South or North&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;West&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">output: </span><br><span class="line">South or North</span><br></pre></td></tr></table></figure><p>以下几点值得注意：</p><ul><li><code>match</code> 的匹配必须要穷举出所有可能，因此这里用 <code>_</code> 来代表未列出的所有可能性</li><li><code>match</code> 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li><li><strong>X | Y</strong>，类似逻辑运算符 <code>或</code>，代表该分支可以匹配 <code>X</code> 也可以匹配 <code>Y</code>，只要满足一个即可</li></ul><blockquote><p>  <code>_</code> 类似于 <code>switch</code> 中的 <code>default</code></p></blockquote><h4 id="使用-match-表达式赋值"><a href="#使用-match-表达式赋值" class="headerlink" title="使用 match 表达式赋值"></a>使用 <code>match</code> 表达式赋值</h4><p><code>match</code> 本身也是一个表达式，因此可以用它来赋值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">   Ipv4,</span><br><span class="line">   Ipv6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// let d_panic = Direction::South;</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip1</span> = IpAddr::Ipv6;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ip_str</span> = <span class="keyword">match</span> ip1 &#123;</span><br><span class="line">        IpAddr::Ipv4 =&gt; <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;::1&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, ip_str);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">::<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="模式绑定"><a href="#模式绑定" class="headerlink" title="模式绑定"></a>模式绑定</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Say</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">MoveTo</span>(<span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColorRGB</span>(<span class="type">u16</span>, <span class="type">u16</span>, <span class="type">u16</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">actions</span> = [</span><br><span class="line">        Action::<span class="title function_ invoke__">Say</span>(<span class="string">&quot;Hello Rust&quot;</span>.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">        Action::<span class="title function_ invoke__">MoveTo</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">        Action::<span class="title function_ invoke__">ChangeColorRGB</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">action</span> <span class="keyword">in</span> actions &#123;</span><br><span class="line">        <span class="keyword">match</span> action &#123;</span><br><span class="line">            Action::<span class="title function_ invoke__">Say</span>(s) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">MoveTo</span>(x, y) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;point from (0, 0) move to (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);</span><br><span class="line">            &#125;,</span><br><span class="line">            Action::<span class="title function_ invoke__">ChangeColorRGB</span>(r, g, _) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;change color into &#x27;(r:&#123;&#125;, g:&#123;&#125;, b:0)&#x27;, &#x27;b&#x27; has been ignored&quot;</span>,</span><br><span class="line">                    r, g,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Hello Rust</span><br><span class="line">point <span class="title function_ invoke__">from</span> (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">move</span> <span class="title function_ invoke__">to</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">change color into <span class="string">&#x27;(r:255, g:255, b:0)&#x27;</span>, <span class="string">&#x27;b&#x27;</span> has been ignored</span><br></pre></td></tr></table></figure><h4 id="if-let-匹配"><a href="#if-let-匹配" class="headerlink" title="if let 匹配"></a><code>if let</code> 匹配</h4><p>对于只有一个模式的值需要被处理，其它值直接忽略的场景。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3u8</span>);</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="matches-宏"><a href="#matches-宏" class="headerlink" title="matches!宏"></a><code>matches!</code>宏</h4><p>它可以将一个表达式跟模式进行匹配，然后返回匹配的结果 <code>true</code> or <code>false</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];</span><br><span class="line">    v.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|x| matches!(x, MyEnum::Foo))</span><br><span class="line">        .for_each(|x| <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x));</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Foo</span><br><span class="line">Foo</span><br></pre></td></tr></table></figure><h4 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">age</span> = <span class="title function_ invoke__">Some</span>(<span class="number">30</span>);</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;在匹配前，age是&#123;:?&#125;&quot;</span>,age);</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(age) = age &#123;</span><br><span class="line">       <span class="built_in">println!</span>(<span class="string">&quot;匹配出来的age是&#123;&#125;&quot;</span>,age);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;在匹配后，age是&#123;:?&#125;&quot;</span>,age);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">在匹配前，age是<span class="title function_ invoke__">Some</span>(<span class="number">30</span>)</span><br><span class="line">匹配出来的age是<span class="number">30</span></span><br><span class="line">在匹配后，age是<span class="title function_ invoke__">Some</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>可以看出在 <code>if let</code> 中，<code>=</code> 右边 <code>Some(i32)</code> 类型的 <code>age</code> 被左边 <code>i32</code> 类型的新 <code>age</code> 覆盖了，该覆盖一直持续到 <code>if let</code> 语句块的结束。因此第三个 <code>println!</code> 输出的 <code>age</code> 依然是 <code>Some(i32)</code> 类型。</p><h3 id="2-6-2-解构-option"><a href="#2-6-2-解构-option" class="headerlink" title="2.6.2 解构 option"></a>2.6.2 解构 <code>option</code></h3><p><code>Option</code> 枚举，用来解决 Rust 中变量是否有值的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释就是：<strong>一个变量要么有值：<code>Some(T)</code>, 要么为空：<code>None</code></strong>。</p><h4 id="匹配-Option-lt-T-gt"><a href="#匹配-Option-lt-T-gt" class="headerlink" title="匹配 Option&lt;T&gt;"></a>匹配 <code>Option&lt;T&gt;</code></h4><p>使用 <code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">plus_one</span>(x: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> x &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(i) =&gt; <span class="title function_ invoke__">Some</span>(i + <span class="number">1</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">five</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">six</span> = <span class="title function_ invoke__">plus_one</span>(five);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">none</span> = <span class="title function_ invoke__">plus_one</span>(<span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, five);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, six);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, none);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="title function_ invoke__">Some</span>(<span class="number">5</span>)</span><br><span class="line"><span class="title function_ invoke__">Some</span>(<span class="number">6</span>)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2-6-3-模式适用场景"><a href="#2-6-3-模式适用场景" class="headerlink" title="2.6.3 模式适用场景"></a>2.6.3 模式适用场景</h3><p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 <code>match</code> 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p><ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul><h4 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a><code>match</code> 分支</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> VALUE &#123;</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    PATTERN =&gt; EXPRESSION,</span><br><span class="line">    _ =&gt; EXPRESSION,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-let-分支"><a href="#if-let-分支" class="headerlink" title="if let 分支"></a><code>if let</code> 分支</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">PATTERN</span> = SOME_VALUE &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="while-let-分支"><a href="#while-let-分支" class="headerlink" title="while let 分支"></a><code>while let</code> 分支</h4><p>一个与 <code>if let</code> 类似的结构是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。</p><p>eg:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// Vec是动态数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stack</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数组尾部插入元素</span></span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br><span class="line">    stack.<span class="title function_ invoke__">push</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack.pop从数组尾部弹出元素</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(top) = stack.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p><h4 id="for-循环-1"><a href="#for-循环-1" class="headerlink" title="for 循环"></a><code>for</code> 循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">a is at index <span class="number">0</span></span><br><span class="line">b is at index <span class="number">1</span></span><br><span class="line">c is at index <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个 <code>(索引，值)</code> 形式的元组，然后用 <code>(index,value)</code> 来匹配。</p><h4 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a><code>let</code> 语句</h4><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h3 id="2-6-4-全模式匹配"><a href="#2-6-4-全模式匹配" class="headerlink" title="2.6.4 全模式匹配"></a>2.6.4 全模式匹配</h3><h4 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">one</span><br></pre></td></tr></table></figure><h4 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Got 50&quot;</span>),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Matched, y = <span class="number">5</span></span><br><span class="line">at the end: x = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>), y = <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="单分支多模式"><a href="#单分支多模式" class="headerlink" title="单分支多模式"></a>单分支多模式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one or two&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;anything&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">one or two</span><br></pre></td></tr></table></figure><h4 id="通过序列-匹配值的范围"><a href="#通过序列-匹配值的范围" class="headerlink" title="通过序列 ..= 匹配值的范围"></a>通过序列 <code>..=</code> 匹配值的范围</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;one through five&quot;</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;something else&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">one through five</span><br></pre></td></tr></table></figure><h4 id="解构并分解值"><a href="#解构并分解值" class="headerlink" title="解构并分解值"></a>解构并分解值</h4><p>可以使用模式来解构结构体、枚举、元组和引用</p><h5 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">Point</span> &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">On the y axis at <span class="number">7</span></span><br></pre></td></tr></table></figure><h5 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Quit =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The Quit variant has no data to destructure.&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Move &#123; x, y &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">Write</span>(text) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Text message: &#123;&#125;&quot;</span>, text),</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>, r, g, b)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Change the color to red <span class="number">0</span>, green <span class="number">160</span>, and blue <span class="number">255</span></span><br></pre></td></tr></table></figure><h5 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(Color),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(<span class="number">0</span>, <span class="number">160</span>, <span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>, r, g, b)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::<span class="title function_ invoke__">ChangeColor</span>(Color::<span class="title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,</span><br><span class="line">                h, s, v</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Change the color to hue <span class="number">0</span>, saturation <span class="number">160</span>, and value <span class="number">255</span></span><br></pre></td></tr></table></figure><h5 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        x: <span class="type">i32</span>,</span><br><span class="line">        y: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ((feet, inches), Point &#123; x, y &#125;) = ((<span class="number">3</span>, <span class="number">10</span>), Point &#123; x: <span class="number">3</span>, y: -<span class="number">10</span> &#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;feet =&gt; &#123;:?&#125;, inches =&gt; &#123;:?&#125;&quot;</span>, feet, inches);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;point.x =&gt; &#123;:?&#125;, point.y =&gt; &#123;:?&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">feet =&gt; <span class="number">3</span>, inches =&gt; <span class="number">10</span></span><br><span class="line">point.x =&gt; <span class="number">3</span>, point.y =&gt; -<span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h4><h5 id="使用-忽略整个值"><a href="#使用-忽略整个值" class="headerlink" title="使用 _ 忽略整个值"></a>使用 <code>_</code> 忽略整个值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(_: <span class="type">i32</span>, y: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This code only uses the y parameter: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">foo</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">This code only uses the y parameter: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>使用嵌套的 <code>_</code> 忽略部分值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_setting_value</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> (setting_value, new_setting_value) &#123;</span><br><span class="line">        (<span class="title function_ invoke__">Some</span>(_), <span class="title function_ invoke__">Some</span>(_)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            setting_value = new_setting_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Can<span class="symbol">&#x27;t</span> overwrite an existing customized value</span><br><span class="line">setting is <span class="title function_ invoke__">Some</span>(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h5 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">Some</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello!&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(_s) = s &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;found a string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <strong><code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定</strong>。</p><h5 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值"></a>用 <code>..</code> 忽略剩余值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        x: <span class="type">i32</span>,</span><br><span class="line">        y: <span class="type">i32</span>,</span><br><span class="line">        z: <span class="type">i32</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">&quot;x is &#123;&#125;&quot;</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">x is <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="匹配守卫提供的额外条件"><a href="#匹配守卫提供的额外条件" class="headerlink" title="匹配守卫提供的额外条件"></a>匹配守卫提供的额外条件</h4><p><strong>匹配守卫</strong>（<em>match guard</em>）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// let num = Some(4);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="title function_ invoke__">Some</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;less than five: &#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h4><p><code>@</code>运算符允许为一个字段绑定另外一个变量。</p><p>当你既想要限定分支范围，又想要使用分支的变量时，就可以用 <code>@</code> 来绑定到一个新的变量上，实现想要的功能。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        Hello &#123; id: <span class="type">i32</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = Message::Hello &#123; id: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> msg &#123;</span><br><span class="line">        Message::Hello &#123;</span><br><span class="line">            id: id_variable @ <span class="number">3</span>..=<span class="number">7</span>,</span><br><span class="line">        &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id: <span class="number">10</span>..=<span class="number">12</span> &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found an id in another range&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Message::Hello &#123; id &#125; =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Found an id <span class="keyword">in</span> range: <span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="前绑定后解构-Rust-1-56-新增"><a href="#前绑定后解构-Rust-1-56-新增" class="headerlink" title="@前绑定后解构(Rust 1.56 新增)"></a>@前绑定后解构(Rust 1.56 新增)</h5><p>使用 <code>@</code> 还可以在绑定新变量的同时，对目标进行解构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x: <span class="type">i32</span>,</span><br><span class="line">    y: <span class="type">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> @ Point &#123; x: px, y: py &#125; = Point &#123; x: <span class="number">10</span>, y: <span class="number">23</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, px, py);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">point</span> = Point &#123; x: <span class="number">10</span>, y: <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">p</span> @ Point &#123; x: <span class="number">10</span>, y &#125; = point &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x is 10 and y is &#123;&#125; in &#123;:?&#125;&quot;</span>, y, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x was not 10 :(&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">x: <span class="number">10</span>, y: <span class="number">23</span></span><br><span class="line">Point &#123; x: <span class="number">10</span>, y: <span class="number">23</span> &#125;</span><br><span class="line">x is <span class="number">10</span> and y is <span class="number">5</span> <span class="keyword">in</span> Point &#123; x: <span class="number">10</span>, y: <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-方法-Method"><a href="#2-7-方法-Method" class="headerlink" title="2.7 方法 Method"></a>2.7 方法 <code>Method</code></h2><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><p>Rust 使用 <code>impl</code> 来定义方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    x: <span class="type">f64</span>,</span><br><span class="line">    y: <span class="type">f64</span>,</span><br><span class="line">    radius: <span class="type">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="comment">// new是Circle的关联函数，因为它的第一个参数不是self</span></span><br><span class="line">    <span class="comment">// 这种方法往往用于初始化当前结构体的实例</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: <span class="type">f64</span>, y: <span class="type">f64</span>, radius: <span class="type">f64</span>) <span class="punctuation">-&gt;</span> Circle &#123;</span><br><span class="line">        Circle &#123;</span><br><span class="line">            x: x,</span><br><span class="line">            y: y,</span><br><span class="line">            radius: radius,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span> &#123;</span><br><span class="line">        std::<span class="type">f64</span>::consts::PI * (<span class="keyword">self</span>.radius * <span class="keyword">self</span>.radius)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：</p><p><img src="https://s2.loli.net/2022/03/20/F2crosu63i1HZXy.png" alt="img" align="left" /></p><p>其它语言中所有定义都在 <code>class</code> 中，但是 Rust 的对象定义和方法定义是分离的。</p><p>Another dmeo:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,</span><br><span class="line">        rect1.<span class="title function_ invoke__">area</span>()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">The area of the rectangle is <span class="number">1500</span> square pixels.</span><br></pre></td></tr></table></figure><p><code>impl Rectangle &#123;&#125;</code> 表示为 <code>Rectangle</code> 实现方法(<code>impl</code> 是实现 <em>implementation</em> 的缩写)，这样的写法表明 <code>impl</code> 语句块中的一切都是跟 <code>Rectangle</code> 相关联的。</p><h3 id="self、-amp-self-和-amp-mut-self"><a href="#self、-amp-self-和-amp-mut-self" class="headerlink" title="self、&amp;self 和 &amp;mut self"></a>self、&amp;self 和 &amp;mut self</h3><p>使用 <code>&amp;self</code> 替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 其实是 <code>self: &amp;Self</code> 的简写（注意大小写）。</p><p>在一个 <code>impl</code> 块内，<code>Self</code> 指代被实现方法的结构体类型，<code>self</code> 指代此类型的实例。</p><p><code>self</code> 依然有所有权的概念：</p><ul><li><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</li><li><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</li><li><code>&amp;mut self</code> 表示可变借用</li></ul><p>简单总结下，使用方法代替函数有以下好处：</p><ul><li>不用在函数签名中重复书写 <code>self</code> 对应的类型</li><li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li></ul><h3 id="方法名与结构体字段名相同"><a href="#方法名与结构体字段名相同" class="headerlink" title="方法名与结构体字段名相同"></a>方法名与结构体字段名相同</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rect1.<span class="title function_ invoke__">width</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">The rectangle has a nonzero width; it is <span class="number">30</span></span><br></pre></td></tr></table></figure><p>一般来说，方法跟字段同名，往往适用于实现 <code>getter</code> 访问器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">width</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带多个参数的方法"><a href="#带多个参数的方法" class="headerlink" title="带多个参数的方法"></a>带多个参数的方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect2</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect3</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect2));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="title function_ invoke__">can_hold</span>(&amp;rect3));</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Can rect1 hold rect2? <span class="literal">true</span></span><br><span class="line">Can rect1 hold rect3? <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h3><p>定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong></p><p>因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用<code>::</code>来调用，例如 <code>let sq = Rectangle::new(3,3);</code>。</p><h3 id="多个-impl-定义"><a href="#多个-impl-定义" class="headerlink" title="多个 impl 定义"></a>多个 <code>impl</code> 定义</h3><p>Rust 允许我们为一个结构体定义多个 <code>impl</code> 块：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">can_hold</span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为枚举实现方法"><a href="#为枚举实现方法" class="headerlink" title="为枚举实现方法"></a>为枚举实现方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: <span class="type">i32</span>, y: <span class="type">i32</span> &#125;,</span><br><span class="line">        <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">        <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">            <span class="comment">// 在这里定义方法体</span></span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;this is a method of Messsage::Write&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Message::<span class="title function_ invoke__">Write</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.<span class="title function_ invoke__">call</span>();</span><br><span class="line">&#125;</span><br><span class="line">ouptut:</span><br><span class="line">this is a method of Messsage::Write</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Rust安装与初览</title>
      <link href="/2022/03/6562e4ff8b6f.html"/>
      <url>/2022/03/6562e4ff8b6f.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-牛刀小试"><a href="#1-牛刀小试" class="headerlink" title="1. 牛刀小试"></a>1. 牛刀小试</h2><h3 id="1-1-安装Rust环境"><a href="#1-1-安装Rust环境" class="headerlink" title="1.1 安装Rust环境"></a>1.1 安装<code>Rust</code>环境</h3><h4 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装<code>Rust</code></h4><p><code>rustup</code> 是 Rust 的安装程序，也是它的版本管理程序。</p><h4 id="Linux或macOS上安装rustup"><a href="#Linux或macOS上安装rustup" class="headerlink" title="Linux或macOS上安装rustup"></a><code>Linux</code>或<code>macOS</code>上安装<code>rustup</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><p>中间会经历一些配置选择，只需默认回车即可</p><p>如果安装成功，终端会出现如下字样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rust is installed now. Great!</span><br></pre></td></tr></table></figure><h4 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a>检查是否安装成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rustc -V</span><br><span class="line">rustc 1.59.0 (9d1b2106e 2022-02-23)</span><br><span class="line"></span><br><span class="line">cargo -V</span><br><span class="line">cargo 1.59.0 (49d8809dc 2022-02-10)</span><br></pre></td></tr></table></figure><h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>要卸载 <code>Rust</code> 和 <code>rustup</code>，在终端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup self uninstall</span><br></pre></td></tr></table></figure><h4 id="本地文档"><a href="#本地文档" class="headerlink" title="本地文档"></a>本地文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup doc</span><br></pre></td></tr></table></figure><h3 id="1-2-VSCode"><a href="#1-2-VSCode" class="headerlink" title="1.2 VSCode"></a>1.2 <code>VSCode</code></h3><p>插件推荐：</p><ol><li><code>rust-analyzer</code>，社区推荐</li><li><code>Better TOML</code>，用于更好的展示 .toml 文件</li><li><code>Error Lens</code>, 更好的获得错误展示</li><li><code>CodeLLDB</code>, Debugger 程序</li></ol><h3 id="1-3-认识Cargo"><a href="#1-3-认识Cargo" class="headerlink" title="1.3 认识Cargo"></a>1.3 认识<code>Cargo</code></h3><p>包管理工具，类似<code>npm</code></p><p><code>cargo</code>命令：</p><ul><li>cargo new xxx 创建xxx项目</li><li>cargo run [—release] xxx 编译并运行项目</li><li>cargo build [—release] 编译项目</li><li>cargo check 检查代码是否能够通过编译</li></ul><blockquote><p>  <code>--release</code>可以带来更高性能</p></blockquote><h4 id="Cargo-toml和Cargo-lock"><a href="#Cargo-toml和Cargo-lock" class="headerlink" title="Cargo.toml和Cargo.lock"></a><code>Cargo.toml</code>和<code>Cargo.lock</code></h4><p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件</p><ul><li><p><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p></li><li><p><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong></p></li></ul><blockquote><p>  当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，添加到 <code>.gitignore</code> </p></blockquote><h5 id="package配置"><a href="#package配置" class="headerlink" title="package配置"></a><code>package</code>配置</h5><p><code>package</code> 中记录了项目的描述信息：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;world_hello&quot;</span>  <span class="comment">#项目名称</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span> <span class="comment">#当前版本</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span> <span class="comment">#Rust的大版本</span></span><br></pre></td></tr></table></figure><h5 id="定义项目依赖"><a href="#定义项目依赖" class="headerlink" title="定义项目依赖"></a>定义项目依赖</h5><p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p><ul><li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li><li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li><li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li></ul><p><code>eg</code>:</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.3&quot;</span></span><br><span class="line"><span class="attr">hammer</span> = &#123; version = <span class="string">&quot;0.5.0&quot;</span>&#125;</span><br><span class="line"><span class="attr">color</span> = &#123; git = <span class="string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;</span><br><span class="line"><span class="attr">geometry</span> = &#123; path = <span class="string">&quot;crates/geometry&quot;</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2021/10/41ba87453dc6.html"/>
      <url>/2021/10/41ba87453dc6.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>核心类变成了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，具体实现细节由子类决定。</p><h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/10/09/yqiwz7R5s8XJLgk.png" alt="image-20211009133405966"></p><h4 id="Code-Demo"><a href="#Code-Demo" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。</p><p>抽象导出（ExportFile）角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p><p>具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。</p><p>ExportFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExportFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ExportFile <span class="title function_">factory</span><span class="params">(String type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExportHtmlFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportHtmlFactory</span> <span class="keyword">implements</span> <span class="title class_">ExportFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExportFile <span class="title function_">factory</span><span class="params">(String type)</span> &#123;      </span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;standard&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportStandardHtmlFile</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;financial&quot;</span>.equals(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportFinancialHtmlFile</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有找到对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExportPdfFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportPdfFactory</span> <span class="keyword">implements</span> <span class="title class_">ExportFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ExportFile <span class="title function_">factory</span><span class="params">(String type)</span> &#123;      </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;standard&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportStandardPdfFile</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;financial&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExportFinancialPdfFile</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有找到对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExportFile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ExportFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExportFinancialHtmlFile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportFinancialHtmlFile</span> <span class="keyword">implements</span> <span class="title class_">ExportFile</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;导出财务版HTML文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExportFinancialPdfFile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExportFinancialPdfFile</span> <span class="keyword">implements</span> <span class="title class_">ExportFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">export</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;导出财务版PDF文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html">Java与模式-工厂方法模式</a></li></ul><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h4 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h4><p>适配器模式（<code>Adapter Pattern</code>）是一种结构型设计模式， 使接口不兼容的对象能够相互合作。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>确保至少有两个类的接口不兼容</li><li>声明客户端接口，描述客户端如何与服务交互</li><li>创建适配器类</li><li>在适配器类中添加一个成员变量用于保存服务对象的引用</li><li>实现适配器类客户端接口所有方法，将工作委派给服务对象工作</li><li>客户端必须使用客户端接口使用适配器</li></ul><h4 id="UML类图-1"><a href="#UML类图-1" class="headerlink" title="UML类图"></a>UML类图</h4><p>类适配器</p><p><img src="https://i.loli.net/2021/07/06/xRmF8eSUDtYkKqc.png" alt="image-20210706223542693"></p><p>对象适配器</p><p><img src="https://i.loli.net/2021/07/06/JO9kUmg2uxpTFDC.png" alt="image-20210706223705728"></p><h4 id="Code-Demo-1"><a href="#Code-Demo-1" class="headerlink" title="Code Demo"></a>Code Demo</h4><p><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a></p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>希望使用的某个类，接口与其他代码不兼容时</li></ul><h4 id="Ref-1"><a href="#Ref-1" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/adapter">适配器模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">Java与模式-适配器模式</a></li></ul><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><h4 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h4><p>桥接模式（<code>Bridge Pattern</code>）是将一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>抽象化<ul><li>抽取出共同的、本质性的特征，舍弃其非本质的特征</li></ul></li><li>实现化<ul><li>给出抽象的具体实现</li></ul></li><li>解耦<ul><li>解除实体间的强关联（编译时期就已经确定的，无法在运行时期动态改变的关联）</li></ul></li></ul><h4 id="UML类图-2"><a href="#UML类图-2" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/07/25/srR3XFkKhzqwgST.png" alt="image-20210725142739115"></p><h4 id="Code-Demo-2"><a href="#Code-Demo-2" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>Abstraction</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> Implementor impl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Abstraction</span><span class="params">(Implementor impl)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//示例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        impl.operationImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RefinedAbstraction</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title class_">Abstraction</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefinedAbstraction</span><span class="params">(Implementor impl)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他的操作方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">otherOperation</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implementor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 示例方法，实现抽象部分需要的某些具体功能 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreteImplementorA </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementorA</span> <span class="keyword">extends</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//具体操作      </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcreateImplementorB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteImplementorB</span> <span class="keyword">extends</span> <span class="title class_">Implementor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationImpl</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>拆分、重组具有多个功能的庞杂类</li><li>多重维度扩展类</li><li>运行时态切换不同方法</li></ul><h4 id="Ref-2"><a href="#Ref-2" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html">Java与模式-桥接模式</a></li><li><a href="https://refactoringguru.cn/design-patterns/bridge">桥接设计模式</a></li></ul><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><h4 id="意图-3"><a href="#意图-3" class="headerlink" title="意图"></a>意图</h4><p>组合模式（<code>Composite Pattern</code>）将对象组合成树状结构， 并且能像使用独立对象一样使用</p><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>确保应用的核心模型能够以树状结构表示，并能够将其分解为简单元素和容器</li><li>声明接口及对简单和复杂元素都有意义的组件方法</li><li>创建一个叶节点类表示简单元素</li><li>创建一个容器类表示复杂元素</li><li>在容器中定义添加和删除子元素的方法</li></ul><h4 id="UML类图-3"><a href="#UML类图-3" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/07/27/hU7z8orKEqcfRTs.png" alt="image-20210727093155923"></p><h4 id="Code-Demo-3"><a href="#Code-Demo-3" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>Component</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 输出组建自身的名称 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStruct</span><span class="params">(String preStr)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Composite</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Composite</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用来存储组合对象中包含的子组件对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; childComponents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Component&gt;();</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 组合对象的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造方法，传入组合对象的名字     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name    组合对象的名字 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Composite</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 聚集管理方法，增加一个子构件对象     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child 子构件对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Component child)</span> &#123;</span><br><span class="line">        childComponents.add(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 聚集管理方法，删除一个子构件对象     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 子构件对象的下标 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        childComponents.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 聚集管理方法，返回所有子构件对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Component&gt; <span class="title function_">getChild</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> childComponents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 输出对象的自身结构     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preStr 前缀，主要是按照层级拼接空格，实现向后缩进</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStruct</span><span class="params">(String preStr)</span> &#123;</span><br><span class="line">        <span class="comment">// 先把自己输出</span></span><br><span class="line">        System.out.println(preStr + <span class="string">&quot;+&quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        <span class="comment">//如果还包含有子组件，那么就输出这些子组件对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.childComponents != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//添加两个空格，表示向后缩进两个空格</span></span><br><span class="line">            preStr += <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            <span class="comment">//输出当前对象的子对象</span></span><br><span class="line">            <span class="keyword">for</span> (Component c : childComponents) &#123;</span><br><span class="line">                <span class="comment">//递归输出每个子对象</span></span><br><span class="line">                c.printStruct(preStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leaf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 叶子对象的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造方法，传入叶子对象的名称     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 叶子对象的名字 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preStr 前缀，主要是按照层级拼接的空格，实现向后缩进 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printStruct</span><span class="params">(String preStr)</span> &#123;</span><br><span class="line">        System.out.println(preStr + <span class="string">&quot;-&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Composite</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;服装&quot;</span>);</span><br><span class="line">        <span class="type">Composite</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;男装&quot;</span>);</span><br><span class="line">        <span class="type">Composite</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Composite</span>(<span class="string">&quot;女装&quot;</span>);</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">leaf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;衬衫&quot;</span>);</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">leaf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;夹克&quot;</span>);</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">leaf3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;裙子&quot;</span>);</span><br><span class="line">        <span class="type">Leaf</span> <span class="variable">leaf4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Leaf</span>(<span class="string">&quot;套装&quot;</span>);</span><br><span class="line">        root.addChild(c1);</span><br><span class="line">        root.addChild(c2);</span><br><span class="line">        c1.addChild(leaf1);</span><br><span class="line">        c1.addChild(leaf2);</span><br><span class="line">        c2.addChild(leaf3);</span><br><span class="line">        c2.addChild(leaf4);</span><br><span class="line">        root.printStruct(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需要实现树状对象结构</li><li>希望客户端代码以相同方式处理简单和复杂元素</li></ul><h4 id="Ref-3"><a href="#Ref-3" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/composite">组合模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html">JAVA与模式-合成模式</a></li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><h4 id="意图-4"><a href="#意图-4" class="headerlink" title="意图"></a>意图</h4><p>装饰器模式（<code>Decorator Pattern</code>）以客户端透明的方式扩展对象的功能</p><h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li><li>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</li><li>创建一个具体组件类， 并定义其基础行为。</li><li>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</li><li>确保所有类实现组件接口。</li><li>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</li><li>客户端代码负责创建装饰并将其组合成客户端所需的形式。</li></ul><h4 id="UML类图-4"><a href="#UML类图-4" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/07/31/zgHxTCYXOutLGIw.png" alt="image-20210731224242122"></p><h4 id="Code-Demo-4"><a href="#Code-Demo-4" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>抽象构建角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sampleOperation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构建角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sampleOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写相关的业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sampleOperation</span><span class="params">()</span> &#123;        </span><br><span class="line"><span class="comment">// 委派给构件</span></span><br><span class="line">        component.sampleOperation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sampleOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.sampleOperation();</span><br><span class="line">        <span class="comment">// 写相关的业务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorB</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sampleOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.sampleOperation();</span><br><span class="line"><span class="comment">// 写相关的业务代码 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>在无需修改代码的情况下即可使用对象，且希望在运行时为对象新增额外的行为，可以使用装饰模式</li></ul><h4 id="Ref-4"><a href="#Ref-4" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/decorator">装饰器模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html">Java与模式-装饰器模式</a></li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><h4 id="意图-5"><a href="#意图-5" class="headerlink" title="意图"></a>意图</h4><p>享元模式（<code>Flyweight Pattern</code>）以共享的方式高效地支持大量的细粒度对象</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>将需要改写为享元的类成员变量拆分为两个部分<ul><li>内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</li><li>外在状态： 包含每个对象各自不同的情景数据的成员变量</li></ul></li><li>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改</li></ul><h4 id="UML类图-5"><a href="#UML类图-5" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/08/02/SUsPml2aDMeNL5d.png" alt="image-20210802113908558"></p><h4 id="Code-Demo-5"><a href="#Code-Demo-5" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>抽象享元角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="comment">//一个示意性方法，参数state是外蕴状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String state)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体享元角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Character</span> <span class="variable">intrinsicState</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造函数，内蕴状态作为参数传入     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(Character state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intrinsicState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 外蕴状态作为参数传入方法中，改变方法的行为，     </span></span><br><span class="line"><span class="comment">     * 但是并不改变对象的内蕴状态。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Intrinsic State = &quot;</span> + <span class="built_in">this</span>.intrinsicState);</span><br><span class="line">        System.out.println(<span class="string">&quot;Extrinsic State = &quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>享元工厂角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, Flyweight&gt; files = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Flyweight&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Flyweight <span class="title function_">factory</span><span class="params">(Character state)</span> &#123;</span><br><span class="line">        <span class="comment">//先从缓存中查找对象 </span></span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">fly</span> <span class="operator">=</span> files.get(state);</span><br><span class="line">        <span class="keyword">if</span> (fly == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果对象不存在则创建一个新的Flyweight对象</span></span><br><span class="line">            fly = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(state);</span><br><span class="line">            files.put(state, fly);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fly;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FlyweightFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FlyweightFactory</span>();</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">fly</span> <span class="operator">=</span> factory.factory(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        fly.operation(<span class="string">&quot;First Call&quot;</span>);</span><br><span class="line">        fly = factory.factory(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">        fly.operation(<span class="string">&quot;Second Call&quot;</span>);</span><br><span class="line">        fly = factory.factory(<span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        fly.operation(<span class="string">&quot;Third Call&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>程序必须支持大量对象且没有足够的内存容量时</li></ul><h4 id="Ref-5"><a href="#Ref-5" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/flyweight">享元模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html">Java与模式-享元模式</a></li></ul><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="意图-6"><a href="#意图-6" class="headerlink" title="意图"></a>意图</h4><p>命令模式（<code>Command Pattern</code>） 是将请求或简单操作转换为一个对象。此转换根据不同的请求将方法参数化，可以延迟执行、远程执行、放入队列、撤销等。</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>将<code>Client</code>与<code>Receiver</code>解耦合，通过中间者<code>Invoker</code>来接收、执行命令，解除<code>Client</code>与<code>Receiver</code>的强依赖</li><li>命令与<code>Receiver</code>内聚，由<code>Receiver</code>来具体执行命令</li></ol><h4 id="UML类图-6"><a href="#UML类图-6" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/05/30/5DhpMVrBW7sacG4.png" alt="image-20210530130850877.png"></p><h4 id="Code-Demo-6"><a href="#Code-Demo-6" class="headerlink" title="Code Demo"></a>Code Demo</h4><p><strong>Receiver</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 真正执行命令相应的操作 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Command</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 执行方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConcreteCommand</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 持有相应的接收者对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造方法     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//通常会转调接收者的形影方法，让接收者来真正执行功能 </span></span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Invoker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 持有命令对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造方法     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(Command command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 行动方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//1.创建接收者                </span></span><br><span class="line">        <span class="type">Receiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Receiver</span>();        </span><br><span class="line">        <span class="comment">//2.创建命令对象，设定其接收者                </span></span><br><span class="line">        <span class="type">Command</span> <span class="variable">command</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(receiver);        </span><br><span class="line">        <span class="comment">//3.创建请求者，把命令对象设置进去               </span></span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(command);        </span><br><span class="line">        <span class="comment">//4.执行方法               </span></span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>通过操作来参数化对象</li><li>将操作放置于队列中、操作的执行、远程执行操作</li><li>操作回滚功能</li></ul><h4 id="Ref-6"><a href="#Ref-6" class="headerlink" title="Ref"></a>Ref</h4><ul><li><p><a href="https://refactoringguru.cn/design-patterns/command">命令模式</a></p></li><li><p><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html">Java与模式 - 命令模式</a></p></li></ul><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><h4 id="意图-7"><a href="#意图-7" class="headerlink" title="意图"></a>意图</h4><p>责任链模式（<code>Chain of Responsibility Pattern</code>）是将请求沿着处理者链进行发送，每个处理者都可以对请求进行处理，或传递给下一个处理者。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>将处理者（<code>handler</code>）组成一条处理链，每个处理者可以处理请求或移交给下一个处理者或者直接将处理流程终止</li></ol><h4 id="UML类图-7"><a href="#UML类图-7" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/05/30/KyBgCIe9URVvQ72.png" alt="image-20210530155335237.png"></p><h4 id="Code-Demo-7"><a href="#Code-Demo-7" class="headerlink" title="Code Demo"></a>Code Demo</h4><p><strong>Handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 持有后继的责任对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Handler successor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 示意处理请求的方法，虽然这个示意方法是没有传入参数的     </span></span><br><span class="line"><span class="comment">     * 但实际是可以传入参数的，根据具体需要来选择是否传递参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 取值方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Handler <span class="title function_">getSuccessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 赋值方法，设置后继的责任对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ConcreteHandler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 处理方法，调用此方法处理请求 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">/**         </span></span><br><span class="line"><span class="comment">         * 判断是否有后继的责任对象                 </span></span><br><span class="line"><span class="comment">         * 如果有，就转发请求给后继的责任对象                 </span></span><br><span class="line"><span class="comment">         * 如果没有，则处理请求                  </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (getSuccessor() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;放过请求&quot;</span>);</span><br><span class="line">            getSuccessor().handleRequest();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;处理请求&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//组装责任链           </span></span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();</span><br><span class="line">        <span class="type">Handler</span> <span class="variable">handler2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteHandler</span>();</span><br><span class="line">        handler1.setSuccessor(handler2);        </span><br><span class="line">        <span class="comment">//提交请求                </span></span><br><span class="line">        handler1.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>程序需要使用不同方式处理不同类型的请求，且对请求类型和处理的顺序未知</li><li>程序需要按照顺序执行多个处理者</li><li>所需处理者及其顺序必须在运行时进行改变</li></ul><h4 id="Ref-7"><a href="#Ref-7" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility">责任链模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html">Java与模式 - 责任链模式</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319474561057">责任链-廖雪峰</a></li></ul><h3 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h3><h4 id="意图-8"><a href="#意图-8" class="headerlink" title="意图"></a>意图</h4><p>中介模式（<code>Mediator Pattern</code>）通过限制对象间的直接依赖交互，迫使它们通过中介者来进行合作</p><h4 id="解决方案-8"><a href="#解决方案-8" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>停止组件之间的直接交流，使其相互独立</li><li>组件之间必须通过中介者对象，重定向调用行为，以间接方式进行合作</li></ul><h4 id="UML类图-8"><a href="#UML类图-8" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/06/3IRDgTwMJ4eHknu.png" alt="image-20210606194828652"></p><h4 id="Code-Demo-8"><a href="#Code-Demo-8" class="headerlink" title="Code Demo"></a>Code Demo</h4><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319541669922#0">多选框Demo</a></p><h4 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>对象间耦合严重，难以修改时</li><li>组件因依赖其他组件而无法复用时</li><li>因复用基本行为，而被迫创建大量子类时</li></ul><h4 id="Ref-8"><a href="#Ref-8" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319541669922">中介者模式-廖雪峰</a></li><li><a href="https://refactoringguru.cn/design-patterns/mediator">中介者设计模式</a></li></ul><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h4 id="意图-9"><a href="#意图-9" class="headerlink" title="意图"></a>意图</h4><p>备忘录模式（<code>Memento Pattern</code>）在不破坏封装性的前提下，捕获对象的内部状态，用于以后恢复。</p><h4 id="解决方案-9"><a href="#解决方案-9" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>Memonto：存储的内部状态</li><li>Originator：创建一个备忘录并设置其状态</li><li>Caretaker：负责保存备忘录</li></ul><h4 id="UML类图-9"><a href="#UML类图-9" class="headerlink" title="UML类图"></a>UML类图</h4><p><a href="https://refactoringguru.cn/design-patterns/memento">https://refactoringguru.cn/design-patterns/memento</a></p><h4 id="Code-Demo-9"><a href="#Code-Demo-9" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>Memento</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Memento</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Originator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Originator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 工厂方法，返回一个新的备忘录对象     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">createMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Memento</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 将发起人的状态恢复到备忘录对象所记录的状态      </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memento</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = memento.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前状态：&quot;</span> + <span class="built_in">this</span>.state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Caretaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 备忘录的取值方法    </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">retrieveMenento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 备忘录的赋值方法     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> memento </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clinet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Originator</span> <span class="variable">originator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Originator</span>();</span><br><span class="line">        <span class="type">Caretaker</span> <span class="variable">caretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Caretaker</span>();        </span><br><span class="line">        <span class="comment">//改变发起人对象的状态        </span></span><br><span class="line">        originator.setState(<span class="string">&quot;On&quot;</span>);       </span><br><span class="line">        <span class="comment">//创建备忘录对象，并将发起人对象的状态存储起来        </span></span><br><span class="line">        caretaker.saveMemento(originator.createMemento());        </span><br><span class="line">        <span class="comment">//修改发起人对象的状态         </span></span><br><span class="line">        originator.setState(<span class="string">&quot;Off&quot;</span>);        </span><br><span class="line">        <span class="comment">//恢复发起人对象的状态        </span></span><br><span class="line">        originator.restoreMemento(caretaker.retrieveMenento());        </span><br><span class="line">        <span class="comment">//发起人对象的状态        </span></span><br><span class="line">        System.out.println(<span class="string">&quot;发起人对象的当前状态为：&quot;</span> + originator.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需要恢复对象先前状态</li><li>直接访问对象的属性与方法破坏其封装性</li></ul><h4 id="Ref-9"><a href="#Ref-9" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319562641441">备忘录模式-廖雪峰</a></li><li><a href="https://refactoringguru.cn/design-patterns/memento">备忘录设计模式</a></li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h4 id="意图-10"><a href="#意图-10" class="headerlink" title="意图"></a>意图</h4><p>观察者模式（<code>Observer Pattern</code>）是一种发布/订阅机制，解耦消息发送方与消息订阅方</p><h4 id="解决方案-10"><a href="#解决方案-10" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li><p>需要将自身状态的变化通知给其他对象的，称为发送方（<code>publisher</code>）</p></li><li><p>希望关注变化的对象称为订阅者（<code>subscribers</code>）</p></li><li>为发送方添加订阅机制<ol><li>存储订阅者对象引用列表的成员变量</li><li>用于添加或删除列表中订阅者的方法</li></ol></li></ul><h4 id="UML类图-10"><a href="#UML类图-10" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/09/gsVNX4bzRZtIG9q.png" alt="image-20210609201714109"></p><h4 id="Code-Demo-10"><a href="#Code-Demo-10" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>抽象主题角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用来保存注册的观察者对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 注册观察者对象         </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        list.add(observer);</span><br><span class="line">        System.out.println(<span class="string">&quot;Attached an observer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 删除观察者对象         </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 通知所有注册的观察者对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nodifyObservers</span><span class="params">(String newState)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : list) &#123;</span><br><span class="line">            observer.update(newState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体主题角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">        System.out.println(<span class="string">&quot;主题状态为：&quot;</span> + state);</span><br><span class="line">        <span class="comment">//状态发生改变，通知各个观察者</span></span><br><span class="line">        <span class="built_in">this</span>.nodifyObservers(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 更新接口          </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state    更新的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String state)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体观察者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//观察者的状态</span></span><br><span class="line">    <span class="keyword">private</span> String observerState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String state)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致         </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        observerState = state;</span><br><span class="line">        System.out.println(<span class="string">&quot;状态为：&quot;</span> + observerState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//创建主题对象        </span></span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();        </span><br><span class="line">        <span class="comment">//创建观察者对象        </span></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();        </span><br><span class="line">        <span class="comment">//将观察者对象登记到主题对象上        </span></span><br><span class="line">        subject.attach(observer);        </span><br><span class="line">        <span class="comment">//改变主题对象的状态        </span></span><br><span class="line">        subject.change(<span class="string">&quot;new state&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式。</li><li>当应用中的一些对象必须观察其他对象时<strong>，</strong> 可使用该模式。 但仅能在有限时间内或特定情况下使用。</li></ul><h4 id="Ref-10"><a href="#Ref-10" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/observer">观察者模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">Java设计与模式-观察者模式</a></li></ul><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h4 id="意图-11"><a href="#意图-11" class="headerlink" title="意图"></a>意图</h4><p>状态模式（<code>State Pattern</code>）让你能在一个对象内部状态改变时，改变其行为。</p><h4 id="解决方案-11"><a href="#解决方案-11" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中</li><li>原始对象被称为上下文 （<code>context</code>）， 它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用， 且将所有与状态相关的工作委派给该对象</li></ul><h4 id="UML类图-11"><a href="#UML类图-11" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/10/PHqvo16adsj7uSK.png" alt="image-20210610225523664"></p><h4 id="Code-Demo-11"><a href="#Code-Demo-11" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>环境角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;    </span><br><span class="line">    <span class="comment">//持有一个State类型的对象实例    </span></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 用户感兴趣的接口方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">(String sampleParameter)</span> &#123;        </span><br><span class="line">        <span class="comment">//转调state来处理         </span></span><br><span class="line">        state.handle(sampleParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象状态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 状态对应的处理 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体状态类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateA</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteStateA handle ：&quot;</span> + sampleParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStateB</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(String sampleParameter)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteStateB handle ：&quot;</span> + sampleParameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        </span><br><span class="line">        <span class="comment">//创建状态        </span></span><br><span class="line">        <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>();        </span><br><span class="line">        <span class="comment">//创建环境        </span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();        </span><br><span class="line">        <span class="comment">//将状态设置到环境中        </span></span><br><span class="line">        context.setState(state);        </span><br><span class="line">        <span class="comment">//请求        </span></span><br><span class="line">        context.request(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-10"><a href="#适用场景-10" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>对象需要根据自身当前状态进行不同行为，同时状态的数量非常多且与状态相关的代码会频繁变更的话</li><li>类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时</li><li>当相似状态和基于条件的状态机转换中存在许多重复代码时</li></ul><h4 id="Ref-11"><a href="#Ref-11" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/state">状态模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html">Java设计与模式-状态模式</a></li></ul><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h4 id="意图-12"><a href="#意图-12" class="headerlink" title="意图"></a>意图</h4><p>策略模式（<code>Strategy Pattern</code>）：定义一系列算法，并将每个算法分别放入独立的类中，使算法对象能够相互替换</p><h4 id="解决方案-12"><a href="#解决方案-12" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>抽取不同方式完成特定任务的类，将其中的算法放到一个策略类中</li><li>包含上下文的原始类使用一个成员变量来保存所有策略的引用，并将具体工作委派给连接的策略对象</li><li>客户端将所需策略传递给上下文</li></ul><h4 id="UML类图-12"><a href="#UML类图-12" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/21/kB69zPKIUS4ELFl.png" alt="image-20210621214330052.png"></p><h4 id="Code-Demo-12"><a href="#Code-Demo-12" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>上下文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">//持有一个具体策略的对象    </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 构造函数，传入一个具体策略对象          </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strategy    具体策略对象 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Context</span><span class="params">(Strategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 策略方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.strategyInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 策略方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//相关的业务    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">strategyInterface</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//相关的业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-11"><a href="#适用场景-11" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>使用对象中各种不同的算法变体，并希望能在运行时切换算法时， 可使用策略模式</li><li>如果算法在上下文的逻辑不是很重要，使用该模式可以将业务与算法分离</li></ul><h4 id="Ref-12"><a href="#Ref-12" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/strategy">策略设计模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html">Java设计与模式-策略模式</a></li></ul><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><h4 id="意图-13"><a href="#意图-13" class="headerlink" title="意图"></a>意图</h4><p>模板方法模式（<code>Template Method Pattern</code>）：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p><h4 id="解决方案-13"><a href="#解决方案-13" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>将算法分解为一系列步骤， 然后将这些步骤改写为方法，放在模板方法中依次调用</li><li>客户端需要自行提供子类并实现所有的抽象步骤</li></ul><h4 id="UML类图-13"><a href="#UML类图-13" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/22/LFv2Ax9gInVReUT.png" alt="image-20210622144914125"></p><h4 id="Code-Demo-13"><a href="#Code-Demo-13" class="headerlink" title="Code Demo"></a>Code Demo</h4><p>抽象模板角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 模板方法 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//调用基本方法        </span></span><br><span class="line">        abstractMethod();</span><br><span class="line">        hookMethod();</span><br><span class="line">        concreteMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 基本方法的声明（由子类实现） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本方法(空方法)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基本方法（已经实现） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">concreteMethod</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//业务相关的代码    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体模板角色类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span> &#123;    </span><br><span class="line">    <span class="comment">//基本方法的实现        </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//业务相关的代码       </span></span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hookMethod</span><span class="params">()</span> &#123;        </span><br><span class="line">        <span class="comment">//业务相关的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="适用场景-12"><a href="#适用场景-12" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>只希望扩展某个特定算法步骤，而不是整个算法或其结构</li><li>多个类的算法除一些细微不同之外几乎完全一样时</li></ul><h4 id="Ref-13"><a href="#Ref-13" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://refactoringguru.cn/design-patterns/template-method">模板方法设计模式</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html">Java设计与模式</a></li></ul><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><h4 id="意图-14"><a href="#意图-14" class="headerlink" title="意图"></a>意图</h4><p>访问者模式（<code>Visitor Pattern</code>）：将算法与其所作用的对象隔离开来</p><h4 id="解决方案-14"><a href="#解决方案-14" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>将行为放入一个名为访问者的独立类中， 而不是试图将其整合到已有类中</li><li>将需要执行操作的原始对象作为参数传递给访问者中的方法</li></ul><h4 id="UML类图-14"><a href="#UML类图-14" class="headerlink" title="UML类图"></a>UML类图</h4><p><img src="https://i.loli.net/2021/06/23/vFeChU39TQ6M2mx.png" alt="image-20210623150808652"></p><h4 id="Code-Demo-14"><a href="#Code-Demo-14" class="headerlink" title="Code Demo"></a>Code Demo</h4><p><a href="https://refactoringguru.cn/design-patterns/visitor/java/example">https://refactoringguru.cn/design-patterns/visitor/java/example</a></p><h4 id="适用场景-13"><a href="#适用场景-13" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>需要对一个复杂对象结构（例如对象树）中的所有元素执行某些操作</li></ul><h4 id="Ref-14"><a href="#Ref-14" class="headerlink" title="Ref"></a>Ref</h4><ul><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/14/2545381.html">Java设计与模式-访问者模式</a></li><li><a href="https://refactoringguru.cn/design-patterns/visitor">访问者模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【REF】圣杯与银弹 · 没用的设计模式</title>
      <link href="/2021/06/0e41306eec32.html"/>
      <url>/2021/06/0e41306eec32.html</url>
      
        <content type="html"><![CDATA[<h1 id="圣杯与银弹-·-没用的设计模式"><a href="#圣杯与银弹-·-没用的设计模式" class="headerlink" title="圣杯与银弹 · 没用的设计模式"></a>圣杯与银弹 · 没用的设计模式</h1><p>原文：<a href="https://draveness.me/holy-grail-design-pattern/">圣杯与银弹 · 没用的设计模式</a></p>]]></content>
      
      
      <categories>
          
          <category> DesignPattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DesignPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s介绍</title>
      <link href="/2021/06/71f5243a03f4.html"/>
      <url>/2021/06/71f5243a03f4.html</url>
      
        <content type="html"><![CDATA[<h1 id="k8s-介绍"><a href="#k8s-介绍" class="headerlink" title="k8s 介绍"></a>k8s 介绍</h1><p>原文：<a href="https://www.jeremyjordan.me/kubernetes/">An introduction to Kubernetes</a></p><p>引用：<a href="http://wu.run/2021/04/20/an-introduction-to-k8s/">k8s介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> K8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uml类间关系</title>
      <link href="/2021/06/059817ed7752.html"/>
      <url>/2021/06/059817ed7752.html</url>
      
        <content type="html"><![CDATA[<h1 id="UML类间关系"><a href="#UML类间关系" class="headerlink" title="UML类间关系"></a>UML类间关系</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>uml类图中大概可以分为：泛化（Generalization）, 实现（Realization），关联（Association），聚合（Aggregation），组合（Composition），依赖（Dependency）此六种类间关系。</p><h2 id="经典实例"><a href="#经典实例" class="headerlink" title="经典实例"></a>经典实例</h2><p><img src="https://i.loli.net/2021/06/19/tPCN4Ekz7W5lFYo.png" alt="gGTPMWe23jayYd5"></p><ul><li>车的类图为&lt;\<interface\>&gt;，表明车是一个接口</li><li>小汽车与自行车继承车类；它们之间关系为<strong>实现</strong>关系，用带有<strong>空心箭头的虚线</strong>表示；</li><li>小汽车与SUV之间也是继承关系，它们之间关系为<strong>泛化</strong>关系，用<strong>带有空心箭头的实线</strong>表示；</li><li>小汽车与发动机之间是<strong>组合</strong>关系，用<strong>带有实心菱形箭头的实线</strong>表示；</li><li>学生与班级之间是<strong>聚合</strong>关系，用<strong>带有空心菱形箭头的实线</strong>表示；</li><li>学生与身份证之间为<strong>关联</strong>关系，用<strong>实线</strong>表示；</li><li>学生上学需要用到自行车，与自行车是一种<strong>依赖</strong>关系，用<strong>带箭头的虚线</strong>表示；</li></ul><h2 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h2><h3 id="泛化（Generalization）"><a href="#泛化（Generalization）" class="headerlink" title="泛化（Generalization）"></a>泛化（Generalization）</h3><p>泛化关系是模拟两个类之间强<code>is-a</code>的关系，强<code>is-a</code>表达的是一种继承关系；</p><p>UML图中，泛化关系使用带空心三角箭头的实线表示，箭头从子类指向父类。</p><p><img src="https://i.loli.net/2021/06/19/VetK2EFaCNZpRAv.png" alt="yAMR7WhDnw59ZQa" style="zoom:50%;" /></p><h3 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h3><p>实现关系是接口与接口的实现类之间的关系，是一种弱<code>is-a</code>的关系</p><p>UML图中，实现关系使用带空心三角箭头的虚线表示，箭头从实现类指向接口。</p><p><img src="https://i.loli.net/2021/06/19/FdDyWM7zKY4asfI.png" alt="51rtS63C7fyPFGN" style="zoom:50%;" /></p><h3 id="关联（Association）"><a href="#关联（Association）" class="headerlink" title="关联（Association）"></a>关联（Association）</h3><p>关联关系描述不同类对象间的结构关系；通常与运行状态无关；在最终代码中，关联对象通常是以成员变量的形式实现的。</p><p>UML图中，关联关系使用一条实线表示。</p><p><img src="https://i.loli.net/2021/06/19/Zpc8yrQUtxAFPOI.png" alt="cumSpEWxVDqrNYb" style="zoom:50%;" /></p><h3 id="聚合关系（Aggregation）"><a href="#聚合关系（Aggregation）" class="headerlink" title="聚合关系（Aggregation）"></a>聚合关系（Aggregation）</h3><p>聚合关系是关联关系的一种，表示整体由部分构成，属于<code>has-a</code>的关系。</p><p>聚合关系中，被聚合对象和聚合对象有着各自的生命周期。</p><p>UML图中，聚合关系使用带有空心菱形箭头的实线表示，箭头从聚合者指向被聚合者。</p><p><img src="https://i.loli.net/2021/06/19/iZcblG4q7MfWQrt.png" alt="cQVpx1eDFj5naO9" style="zoom:50%;" /></p><h3 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h3><p>组合关系也是关联关系的一种，也表示类之间的整体与部分的关系，是一种更强烈的聚合关系，是<code>contains-a</code> 关系。</p><p>组合关系中，整体对象可以控制部分对象的生命周期，部分对象不能脱离整体而存在。</p><p>UML图中，组合关系使用带有实心菱形箭头的实线表示，箭头从部分指向整体。</p><p><img src="https://i.loli.net/2021/06/19/GOQ397aTMriqAIu.png" alt="LbFAs6cXKCBraPV" style="zoom:50%;" /></p><h3 id="依赖（Dependency）"><a href="#依赖（Dependency）" class="headerlink" title="依赖（Dependency）"></a>依赖（Dependency）</h3><p>依赖关系是一种临时性的关系，描述一个对象的运行期间会用到另外一个对象的关系，是一种对象间关系耦合度较弱的关系。</p><p>在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>UML图中，依赖关系使用带箭头的虚线表示，从使用者指向被依赖者。</p><p><img src="https://i.loli.net/2021/06/19/s2gaXnNi5rcyCJW.png" alt="23XOyC8fWEc7GVJ" style="zoom:50%;" /></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://my.oschina.net/jackieyeah/blog/224265">UML类图中的六大关系：关联、聚合、组合、依赖、继承、实现</a></li><li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html">看懂UML类图和时序图</a></li><li><a href="http://c.biancheng.net/view/8374.html">UML类图及类图之间的关系</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL Explain详解</title>
      <link href="/2021/06/7e693b095c25.html"/>
      <url>/2021/06/7e693b095c25.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a>MySQL Explain详解</h1><h2 id="Explain是什么"><a href="#Explain是什么" class="headerlink" title="Explain是什么"></a>Explain是什么</h2><p><code>Explain</code><sup><a href="#fn_1" id="reffn_1">1</a></sup>是MySQL提供的一个工具，用来收集MySQL Statement执行计划的相关信息。</p><h2 id="Explain怎么使用"><a href="#Explain怎么使用" class="headerlink" title="Explain怎么使用"></a>Explain怎么使用</h2><p>explain的语句格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;EXPLAIN | DESCRIBE | DESC&#125;</span><br><span class="line">    tbl_name [col_name | wild]</span><br><span class="line"></span><br><span class="line">&#123;EXPLAIN | DESCRIBE | DESC&#125;</span><br><span class="line">    [explain_type]</span><br><span class="line">    &#123;explainable_stmt | FOR CONNECTION connection_id&#125;</span><br><span class="line"></span><br><span class="line">explain_type: &#123;</span><br><span class="line">    EXTENDED</span><br><span class="line">  | PARTITIONS</span><br><span class="line">  | FORMAT = format_name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">format_name: &#123;</span><br><span class="line">    TRADITIONAL</span><br><span class="line">  | JSON</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">explainable_stmt: &#123;</span><br><span class="line">    SELECT statement</span><br><span class="line">  | DELETE statement</span><br><span class="line">  | INSERT statement</span><br><span class="line">  | REPLACE statement</span><br><span class="line">  | UPDATE statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">devc.ctrl_area_id AS `name`,</span><br><span class="line">count( devc.ctrl_area_id ) AS `value` </span><br><span class="line">FROM</span><br><span class="line">zdcl_vhc_alarm_record record</span><br><span class="line">INNER JOIN zdcl_bas_control_area_devc devc ON record.bayonet_code = devc.devc_code </span><br><span class="line">WHERE</span><br><span class="line">record.monitor_type = &#x27;20&#x27; </span><br><span class="line">AND DATEDIFF( record.create_time, CURRENT_DATE ) = 0 </span><br><span class="line">GROUP BY</span><br><span class="line">devc.ctrl_area_id</span><br></pre></td></tr></table></figure><h2 id="Explain-解析"><a href="#Explain-解析" class="headerlink" title="Explain 解析"></a>Explain 解析</h2><div class="table-container"><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">id</td><td style="text-align:left">语句唯一标识</td></tr><tr><td style="text-align:left">select_type</td><td style="text-align:left">查询类型</td></tr><tr><td style="text-align:left">table</td><td style="text-align:left">表名</td></tr><tr><td style="text-align:left">partitions</td><td style="text-align:left">匹配的分区</td></tr><tr><td style="text-align:left">type</td><td style="text-align:left">联接类型</td></tr><tr><td style="text-align:left">possible_keys</td><td style="text-align:left">可能的索引选择</td></tr><tr><td style="text-align:left">key</td><td style="text-align:left">实际选择的索引</td></tr><tr><td style="text-align:left">key_len</td><td style="text-align:left">索引的长度</td></tr><tr><td style="text-align:left">ref</td><td style="text-align:left">索引的哪一列被引用了</td></tr><tr><td style="text-align:left">rows</td><td style="text-align:left">估计要扫描的行</td></tr><tr><td style="text-align:left">filtered</td><td style="text-align:left">表示符合查询条件的数据百分比</td></tr><tr><td style="text-align:left">Extra</td><td style="text-align:left">附加信息</td></tr></tbody></table></div><p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" title="字段说明">属性解读</a>：</p><p><strong>id</strong>：SQL语句顺序执行唯一标识。</p><ul><li><p>id如果相同，可以认为是一组，从上往下顺序执行</p></li><li><p>如果是子查询，id的序号会递增</p></li><li>在所有组中，id值越大，优先级越高，越先执行</li></ul><p><strong>select_type</strong>：查询类型</p><div class="table-container"><table><thead><tr><th style="text-align:left">查询类型</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">SIMPLE</td><td style="text-align:left">简单查询（未使用UNION或子查询）</td></tr><tr><td style="text-align:left">PRIMARY</td><td style="text-align:left">最外层的查询</td></tr><tr><td style="text-align:left">UNION</td><td style="text-align:left">UNION中的第二个或后面的查询</td></tr><tr><td style="text-align:left">DEPENDENT UNION</td><td style="text-align:left">UNION中的第二个或后面的查询，依赖了外面的查询</td></tr><tr><td style="text-align:left">UNION RESULT</td><td style="text-align:left">UNION的结果</td></tr><tr><td style="text-align:left">SUBQUERY</td><td style="text-align:left">子查询中的第一个 SELECT</td></tr><tr><td style="text-align:left">DEPENDENT SUBQUERY</td><td style="text-align:left">子查询中的第一个 SELECT，依赖了外面的查询</td></tr><tr><td style="text-align:left">DERIVED</td><td style="text-align:left">用来表示包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中。MySQL内部将其称为是Derived table（派生表），因为该临时表是从子查询派生出来的</td></tr><tr><td style="text-align:left">MATERIALIZED</td><td style="text-align:left">物化子查询</td></tr><tr><td style="text-align:left">UNCACHEABLE SUBQUERY</td><td style="text-align:left">子查询，结果无法缓存，必须针对外部查询的每一行重新评估</td></tr><tr><td style="text-align:left">UNCACHEABLE UNION</td><td style="text-align:left">UNION属于UNCACHEABLE SUBQUERY的第二个或后面的查询</td></tr></tbody></table></div><p><strong>table</strong>：当前这一行正在访问哪张表（或表的别名）</p><p><strong>partitions</strong>：查询匹配记录的分区。对于未分区的表，返回null</p><p><strong><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" title="Join Types">type</a></strong>：连接类型</p><ul><li><p>system：特殊的 const 连接，表中只有一行数据</p></li><li><p>const：表最多有一行匹配行，查询开始时被读取。常用作主键或唯一键的等值查询</p></li><li><p>eq_ref：使用索引的全部组成部分，常用于主键或唯一键的多表连接查询</p></li><li><p>ref：满足最左匹配原则，或者索引非主键或唯一键时，用到的连接方式</p><blockquote><p>Tips</p><p>最左前缀原则，指的是索引按照最左优先的方式匹配索引。比如创建了一个组合索引(column1, column2, column3)，那么，如果查询条件是：</p><ul><li><p>WHERE column1 = 1、WHERE column1= 1 AND column2 = 2、WHERE column1= 1 AND column2 = 2 AND column3 = 3 都可以使用该索引；</p></li><li><p>WHERE column1 = 2、WHERE column1 = 1 AND column3 = 3就无法匹配该索引。</p></li></ul></blockquote></li><li><p>fulltext：全文索引</p></li><li><p>ref_or_null：类似于ref，但是MySQL会额外搜索哪些行包含了NULL。这种类型常见于解析子查询</p></li><li><p>index_merge：使用索引合并，表示查询使用到了多个索引</p></li><li><p>unique_subquery：类似eq_ref，使用了<code>IN</code>查询，且子查询为主键或唯一键索引</p></li><li><p>index_subquery：类似unique_subquery，但是子查询使用的是非唯一索引</p></li><li><p>range：索引上的范围搜索，between或where子句中有&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN、LIKE、IN()操作</p></li><li><p>index：全索引扫描，与ALL类似，index是扫描索引的全部数据</p></li><li><p>all：全表扫描</p></li></ul><p><strong>possible_keys</strong>：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</p><p><strong>key</strong>：实际选择的索引</p><p><strong>key_len</strong>：索引使用的字节数</p><p><strong>ref</strong>：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p><p><strong>rows</strong>：扫描行数，越小越好</p><p><strong>filtered</strong>：表示符合条件的数据百分比</p><p><strong><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information" title="EXPLAIN Extra Information">extra</a></strong>：<a href="https://www.itmuch.com/mysql/explain/">Extra Information</a></p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="https://www.cnblogs.com/xuanzhi201111/p/4175635.html">https://www.cnblogs.com/xuanzhi201111/p/4175635.html</a></li><li><a href="https://www.itmuch.com/mysql/explain/">https://www.itmuch.com/mysql/explain/</a></li><li><a href="http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html">http://www.cnitblog.com/aliyiyi08/archive/2008/09/09/48878.html</a></li></ul><blockquote id="fn_1"><sup>1</sup>. EXPLAIN Statement <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html">https://dev.mysql.com/doc/refman/5.7/en/explain.html</a><a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pom中filtering对二进制文件的影响</title>
      <link href="/2021/05/efaa3b2d0bf9.html"/>
      <url>/2021/05/efaa3b2d0bf9.html</url>
      
        <content type="html"><![CDATA[<h1 id="pom中filtering对二进制文件的影响"><a href="#pom中filtering对二进制文件的影响" class="headerlink" title="pom中filtering对二进制文件的影响"></a>pom中filtering对二进制文件的影响</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>最近开发的业务中，有需要导入Excel数据的功能。我将自己设计的excel模板放到<code>resources</code>目录下，测试下载模板时，下载下来的Excel文件会报Excel文件格式错误，无法打开。但是其他项目的下载的Excel文件是OK的，WPS可以正确打开文件。经过仔细排查相关Jar包依赖以及对比其他项目实现方式，最终找到问题所在：即两个项目的POM文件中最相关的差异是开启了<code>resources</code>文件夹的<code>filtering</code>属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的操作就是对<code>resources</code>下所有文件进行<code>filtering</code>过滤，从而导致我通过接口下载的Excel文件无法打开。</p><h2 id="filtering"><a href="#filtering" class="headerlink" title="filtering"></a>filtering</h2><p><code>filtering</code>：决定是否将<code>resources</code>目录下文件中的token（通过@val@标识的变量）进行参数替换。</p><p>开启了此项配置，但是不做其他额外的处理的话，就会在编译时就会对Excel文件进行参数替换，从而导致下载的Excel文件无法打开。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li><p>如果没有相关变量需要替换，可以关闭此功能</p></li><li><p>通过配置非过滤资源文件扩展名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xlsx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>xls<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>zip<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>cer<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>pfx<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>py<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">nonFilteredFileExtension</span>&gt;</span>keystore<span class="tag">&lt;/<span class="name">nonFilteredFileExtension</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nonFilteredFileExtensions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">useDefaultDelimiters</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useDefaultDelimiters</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.jianshu.com/p/4410613bb36f">pom中的filtering</a></li><li><p><a href="https://juejin.cn/post/6844904185557680142">maven中filter的使用方法</a></p></li><li><p><a href="http://tunzao.me/articles/maven-profile/">使用 Maven Profile 和 Filtering 打各种环境的包</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown渲染测试</title>
      <link href="/2021/04/c26377f8f75a.html"/>
      <url>/2021/04/c26377f8f75a.html</url>
      
        <content type="html"><![CDATA[<h1 id="测试-Markdown-it-渲染器"><a href="#测试-Markdown-it-渲染器" class="headerlink" title="测试 Markdown-it 渲染器"></a>测试 Markdown-it 渲染器</h1><p>内容语法测试来自 <code>markdown-it</code> 的<a href="https://markdown-it.github.io/">官网测试内容</a></p><p>:rocket: <strong>Start Now</strong></p><hr><p><strong>Advertisement :)</strong></p><ul><li><strong><a href="https://nodeca.github.io/pica/demo/">pica</a></strong> - high quality and fast image<br>resize in browser.</li><li><strong><a href="https://github.com/nodeca/babelfish/">babelfish</a></strong> - developer friendly<br>i18n with plurals support and easy syntax.</li></ul><p>You will like those projects!</p><hr><h1 id="h1-Heading"><a href="#h1-Heading" class="headerlink" title="h1 Heading :-)"></a>h1 Heading :-)</h1><h2 id="h2-Heading"><a href="#h2-Heading" class="headerlink" title="h2 Heading"></a>h2 Heading</h2><h3 id="h3-Heading"><a href="#h3-Heading" class="headerlink" title="h3 Heading"></a>h3 Heading</h3><h4 id="h4-Heading"><a href="#h4-Heading" class="headerlink" title="h4 Heading"></a>h4 Heading</h4><h5 id="h5-Heading"><a href="#h5-Heading" class="headerlink" title="h5 Heading"></a>h5 Heading</h5><h6 id="h6-Heading"><a href="#h6-Heading" class="headerlink" title="h6 Heading"></a>h6 Heading</h6><h2 id="Horizontal-Rules"><a href="#Horizontal-Rules" class="headerlink" title="Horizontal Rules"></a>Horizontal Rules</h2><hr><hr><hr><h2 id="Typographic-replacements"><a href="#Typographic-replacements" class="headerlink" title="Typographic replacements"></a>Typographic replacements</h2><p>Enable typographer option to see result.</p><p>(c) (C) (r) (R) (tm) (TM) (p) (P) +-</p><p>test.. test… test….. test?….. test!….</p><p>!!!!!! ???? ,,  — —-</p><p>“Smartypants, double quotes” and ‘single quotes’</p><h2 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h2><p><strong>This is bold text</strong></p><p><strong>This is bold text</strong></p><p><em>This is italic text</em></p><p><em>This is italic text</em></p><p><del>Strikethrough</del></p><h2 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h2><blockquote><p>Blockquotes can also be nested…</p><blockquote><p>…by using additional greater-than signs right next to each other…</p><blockquote><p>…or with spaces between arrows.</p></blockquote></blockquote></blockquote><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>Unordered</p><ul><li>Create a list by starting a line with <code>+</code>, <code>-</code>, or <code>*</code></li><li><p>Sub-lists are made by indenting 2 spaces:</p><ul><li><p>Marker character change forces new list start:</p><ul><li>Ac tristique libero volutpat at</li></ul><ul><li>Facilisis in pretium nisl aliquet</li></ul><ul><li>Nulla volutpat aliquam velit</li></ul></li></ul></li><li>Very easy!</li></ul><p>Ordered</p><ol><li>Lorem ipsum dolor sit amet</li><li>Consectetur adipiscing elit</li><li>Integer molestie lorem at massa</li></ol><ol><li>You can use sequential numbers…</li><li>…or keep all the numbers as <code>1.</code></li></ol><p>Start numbering with offset:</p><ol><li>foo</li><li>bar</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Inline <code>code</code></p><p>Indented code</p><pre><code>// Some commentsline 1 of codeline 2 of codeline 3 of code</code></pre><p>Block code “fences”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sample text here...</span><br></pre></td></tr></table></figure><p>Syntax highlighting</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">bar</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> bar++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><div class="table-container"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>data</td><td>path to data files to supply the data that will be passed into templates.</td></tr><tr><td>engine</td><td>engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td>ext</td><td>extension to be used for dest files.</td></tr></tbody></table></div><p>Right aligned columns</p><div class="table-container"><table><thead><tr><th style="text-align:right">Option</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td style="text-align:right">data</td><td style="text-align:right">path to data files to supply the data that will be passed into templates.</td></tr><tr><td style="text-align:right">engine</td><td style="text-align:right">engine to be used for processing templates. Handlebars is the default.</td></tr><tr><td style="text-align:right">ext</td><td style="text-align:right">extension to be used for dest files.</td></tr></tbody></table></div><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p><a href="http://dev.nodeca.com">link text</a></p><p><a href="http://nodeca.github.io/pica/demo/" title="title text!">link with title</a></p><p>Autoconverted link <a href="https://github.com/nodeca/pica">https://github.com/nodeca/pica</a> (enable linkify to see)</p><h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p><img src="https://octodex.github.com/images/minion.png" alt="Minion"><br><img src="https://octodex.github.com/images/stormtroopocat.jpg" alt="Stormtroopocat" title="The Stormtroopocat"></p><p>Like links, Images also have a footnote style syntax</p><p><img src="https://octodex.github.com/images/dojocat.jpg" alt="Alt text" title="The Dojocat"></p><p>With a reference later in the document defining the URL location:</p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>The killer feature of <code>markdown-it</code> is very effective support of<br><a href="https://www.npmjs.org/browse/keyword/markdown-it-plugin">syntax plugins</a>.</p><h3 id="Emojies"><a href="#Emojies" class="headerlink" title="Emojies"></a><a href="https://github.com/markdown-it/markdown-it-emoji">Emojies</a></h3><blockquote><p>Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:</p><p>Shortcuts (emoticons): :-) :-( 8-) ;)</p></blockquote><p>see <a href="https://github.com/markdown-it/markdown-it-emoji#change-output">how to change output</a> with twemoji.</p><h3 id="Subscript-Superscript"><a href="#Subscript-Superscript" class="headerlink" title="Subscript / Superscript"></a><a href="https://github.com/markdown-it/markdown-it-sub">Subscript</a> / <a href="https://github.com/markdown-it/markdown-it-sup">Superscript</a></h3><ul><li>19^th^</li><li>H~2~O</li></ul><h3 id=""><a href="#" class="headerlink" title="\"></a><a href="https://github.com/markdown-it/markdown-it-ins">\<ins></a></h3><p>++Inserted text++</p><h3 id="-1"><a href="#-1" class="headerlink" title="\"></a><a href="https://github.com/markdown-it/markdown-it-mark">\<mark></a></h3><p>==Marked text==</p><h3 id="Footnotes"><a href="#Footnotes" class="headerlink" title="Footnotes"></a><a href="https://github.com/markdown-it/markdown-it-footnote">Footnotes</a></h3><p>Footnote 1 link<sup><a href="#fn_first" id="reffn_first">first</a></sup>.</p><p>Footnote 2 link<sup><a href="#fn_second" id="reffn_second">second</a></sup>.</p><p>Inline footnote^[Text of inline footnote] definition.</p><p>Duplicated footnote reference<sup><a href="#fn_second" id="reffn_second">second</a></sup>.</p><blockquote id="fn_first"><sup>first</sup>. Footnote <strong>can have markup</strong><a href="#reffn_first" title="Jump back to footnote [first] in the text."> &#8617;</a></blockquote><pre><code>and multiple paragraphs.</code></pre><blockquote id="fn_second"><sup>second</sup>. Footnote text.<a href="#reffn_second" title="Jump back to footnote [second] in the text."> &#8617;</a></blockquote><h3 id="Definition-lists"><a href="#Definition-lists" class="headerlink" title="Definition lists"></a><a href="https://github.com/markdown-it/markdown-it-deflist">Definition lists</a></h3><p>Term 1</p><p>:   Definition 1<br>with lazy continuation.</p><p>Term 2 with <em>inline markup</em></p><p>:   Definition 2</p><pre><code>    &#123; some code, part of Definition 2 &#125;</code></pre><p>Third paragraph of definition 2.</p><p><em>Compact style:</em></p><p>Term 1<br>  ~ Definition 1</p><p>Term 2<br>  ~ Definition 2a<br>  ~ Definition 2b</p><h3 id="Abbreviations"><a href="#Abbreviations" class="headerlink" title="Abbreviations"></a><a href="https://github.com/markdown-it/markdown-it-abbr">Abbreviations</a></h3><p>This is HTML abbreviation example.</p><p>It converts “HTML”, but keep intact partial entries like “xxxHTMLyyy” and so on.</p><p>*[HTML]: Hyper Text Markup Language</p><h3 id="Custom-containers"><a href="#Custom-containers" class="headerlink" title="Custom containers"></a><a href="https://github.com/markdown-it/markdown-it-container">Custom containers</a></h3><p>::: warning<br><em>here be dragons</em><br>:::</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
