<!DOCTYPE html>
<html lang=cn>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="3.1 生命周期3.1.1 认识生命周期生命周期，简而言之就是引用的有效作用域。 多数情况下编译器可以自动进行推导，用类型来类比下：  就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期 在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期">
<meta property="og:type" content="article">
<meta property="og:title" content="4.Rust高级进阶">
<meta property="og:url" content="http://example.com/2022/05/4403e2f5fb06.html">
<meta property="og:site_name" content="Ak1raKay&#39;s Blog">
<meta property="og:description" content="3.1 生命周期3.1.1 认识生命周期生命周期，简而言之就是引用的有效作用域。 多数情况下编译器可以自动进行推导，用类型来类比下：  就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期 在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期">
<meta property="og:locale">
<meta property="article:published_time" content="2022-05-05T05:56:33.000Z">
<meta property="article:modified_time" content="2022-07-21T11:06:19.000Z">
<meta property="article:author" content="Ak1raKay">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>4.Rust高级进阶</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" "Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags">tags</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post " href="/2023/06/cc1e007cc495.html"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post " href="/2022/03/5fff10cbfe3b.html"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top " href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post " href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/05/4403e2f5fb06.html"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/05/4403e2f5fb06.html&text=4.Rust高级进阶"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/05/4403e2f5fb06.html&is_video=false&description=4.Rust高级进阶"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=4.Rust高级进阶&body=Check out this article: http://example.com/2022/05/4403e2f5fb06.html"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/05/4403e2f5fb06.html&name=4.Rust高级进阶&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/05/4403e2f5fb06.html&t=4.Rust高级进阶"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">3.1 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E8%AE%A4%E8%AF%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">3.1.1 认识生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">悬垂指针与生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">借用检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">生命周期标注语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">函数签名中的生命周期标注</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">深入思考生命周期标注</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">结构体中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="toc-number">1.1.6.</span> <span class="toc-text">生命周期消除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%9D%A1%E6%B6%88%E9%99%A4%E8%A7%84%E5%88%99"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">三条消除规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">方法中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">静态生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%B7%B1%E5%85%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-TODO"><span class="toc-number">1.2.</span> <span class="toc-text">3.1.2 深入生命周期[TODO]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-amp-%E2%80%99static-%E5%92%8C-T-%E2%80%98static"><span class="toc-number">1.3.</span> <span class="toc-text">3.1.3 &amp;’static 和 T: ‘static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-%E2%80%99static"><span class="toc-number">1.3.1.</span> <span class="toc-text">&amp;’static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-%E2%80%98static"><span class="toc-number">1.3.2.</span> <span class="toc-text">T: ‘static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%88%B0%E5%BA%95%E9%92%88%E5%AF%B9%E8%B0%81%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">static 到底针对谁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%97%AD%E5%8C%85%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">3.2 函数式编程：闭包、迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%97%AD%E5%8C%85-Closure"><span class="toc-number">2.1.</span> <span class="toc-text">3.2.1 闭包 Closure</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用闭包简化代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">闭包实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text">闭包类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">2.1.4.</span> <span class="toc-text">结构体中的闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">2.1.5.</span> <span class="toc-text">捕获作用域中的值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">闭包对内存的影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Fn-%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.6.</span> <span class="toc-text">三种 Fn 特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#move-%E5%92%8C-Fn"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">move 和 Fn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Fn-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">三种 Fn 的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.1.7.</span> <span class="toc-text">闭包作为函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-number">2.2.</span> <span class="toc-text">3.2.2 迭代器 Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#For-%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">For 与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">惰性初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntoIterator%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">IntoIterator特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#into-iter-iter-iter-mut"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">into_iter, iter, iter_mut</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Iterator-%E5%92%8C-IntoIterator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">Iterator 和 IntoIterator 的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">消费者与适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">消费者适配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">迭代器适配器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3.3 深入类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-newtype-%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.3.1 newtype 和类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newtype"><span class="toc-number">3.1.1.</span> <span class="toc-text">newtype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">为外部类型实现外部特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.1.3.</span> <span class="toc-text">隐藏内部细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-Sized-%E5%92%8C%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8BDST"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.2 Sized 和不定长类型DST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B-DST"><span class="toc-number">3.3.1.</span> <span class="toc-text">动态大小类型 DST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Size-%E7%89%B9%E5%BE%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">Size 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-lt-str-gt"><span class="toc-number">3.3.3.</span> <span class="toc-text">Box&lt;str&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Box-%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">3.5.</span> <span class="toc-text">3.4.1 Box 堆对象分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust-%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-number">3.5.1.</span> <span class="toc-text">Rust 中的堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.2.</span> <span class="toc-text">Box 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">使用 Box 将数据存储在堆上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%A0%88%E4%B8%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">避免栈上数据的拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-Sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">将动态大小类型变为 Sized 固定大小类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">特征对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-leak"><span class="toc-number">3.5.3.</span> <span class="toc-text">Box::leak</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Deref-%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">3.4.2 Deref 解引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-%E8%8E%B7%E5%8F%96%E5%BC%95%E7%94%A8%E8%83%8C%E5%90%8E%E7%9A%84%E5%80%BC"><span class="toc-number">3.6.1.</span> <span class="toc-text">通过 * 获取引用背后的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">智能指针解引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">* 背后原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.4.</span> <span class="toc-text">函数和方法中的隐式 Deref 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%9A%90%E5%BC%8F-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">连续的隐式 Deref 转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deref-%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.5.</span> <span class="toc-text">Deref 规则总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.6.</span> <span class="toc-text">三种 Deref 转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-Drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">3.7.</span> <span class="toc-text">3.4.3 Drop 释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust-%E4%B8%AD%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">Rust 中资源回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Drop-%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">Drop 的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%9B%9E%E6%94%B6"><span class="toc-number">3.7.3.</span> <span class="toc-text">手动回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84-Copy-%E5%92%8C-Drop"><span class="toc-number">3.7.4.</span> <span class="toc-text">互斥的 Copy 和 Drop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-Rc-%E4%B8%8E-Arc-%E5%AE%9E%E7%8E%B0-1vN-%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">3.8.</span> <span class="toc-text">3.4.4 Rc 与 Arc 实现 1vN 所有权机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc-lt-T-gt"><span class="toc-number">3.8.1.</span> <span class="toc-text">Rc&lt;T&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rc-clone"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">Rc::clone</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">引用计数的变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">不可变引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.8.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-Cell-%E5%92%8C-RefCell-%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.9.</span> <span class="toc-text">3.4.5 Cell 和 RefCell 内部可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cell"><span class="toc-number">3.9.1.</span> <span class="toc-text">Cell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RefCell"><span class="toc-number">3.9.2.</span> <span class="toc-text">RefCell</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RefCell-%E4%B8%BA%E4%BD%95%E5%AD%98%E5%9C%A8"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">RefCell 为何存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RefCell-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.2.2.</span> <span class="toc-text">RefCell 简单总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">3.5 循环引用与自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-Week-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">3.5.1 Week 与循环引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Week"><span class="toc-number">4.1.1.</span> <span class="toc-text">Week</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">3.5.2 结构体中的自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">自引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Option"><span class="toc-number">4.2.2.</span> <span class="toc-text">使用 Option</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe-%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">Unsafe 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%A2%AB%E7%A7%BB%E5%8A%A8%E7%9A%84-Pin"><span class="toc-number">4.2.4.</span> <span class="toc-text">无法被移动的 Pin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">3.6 多线程并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">5.1.</span> <span class="toc-text">3.6.1 并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">3.6.2 使用多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">5.2.1.</span> <span class="toc-text">多线程编程的风险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">等待子线程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8-Move"><span class="toc-number">5.2.4.</span> <span class="toc-text">线程闭包中使用 Move</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">5.2.5.</span> <span class="toc-text">线程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.2.6.</span> <span class="toc-text">线程屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.7.</span> <span class="toc-text">线程局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">5.2.8.</span> <span class="toc-text">条件控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.9.</span> <span class="toc-text">只被调用一次的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.3.</span> <span class="toc-text">3.6.3 线程同步：消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93"><span class="toc-number">5.3.1.</span> <span class="toc-text">消息通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%91%E5%8D%95%E6%94%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">多发单收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%9A%84-try-recv-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">不阻塞的 try_recv 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.4.</span> <span class="toc-text">具有所有权的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.5.</span> <span class="toc-text">循环接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">5.3.6.</span> <span class="toc-text">多发送者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.3.7.</span> <span class="toc-text">消息顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.</span> <span class="toc-text">同步 &amp; 异步通道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.1.</span> <span class="toc-text">异步通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.2.</span> <span class="toc-text">同步通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.8.3.</span> <span class="toc-text">消息缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93"><span class="toc-number">5.3.9.</span> <span class="toc-text">关闭通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.10.</span> <span class="toc-text">传输多种类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%94%81%E3%80%81Condvar%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">3.6.4 线程同步：锁、Condvar、信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-Mutex"><span class="toc-number">5.4.1.</span> <span class="toc-text">互斥锁 Mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-Mutex"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">单线程中使用 Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-Mutex"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">多线程中使用 Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">内部可变性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">单线程死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">多线程死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-lock"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">try_lock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-RwLock"><span class="toc-number">5.4.3.</span> <span class="toc-text">读写锁 RwLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condvar%EF%BC%89%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.4.4.</span> <span class="toc-text">条件变量（Condvar）控制线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="toc-number">5.4.5.</span> <span class="toc-text">信号量 Semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9AAtomic-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">3.6.5 线程同步：Atomic 原子操作与内存顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Atomic-%E4%BD%9C%E4%B8%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">5.5.1.</span> <span class="toc-text">使用 Atomic 作为全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.5.2.</span> <span class="toc-text">内存顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E7%9A%845%E4%B8%AA%E8%A7%84%E5%88%99"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">限定内存顺序的5个规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">内存屏障</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-Atomic"><span class="toc-number">5.5.3.</span> <span class="toc-text">多线程使用 Atomic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E5%9F%BA%E4%BA%8E-Send-%E5%92%8C-Sync-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.6.</span> <span class="toc-text">3.6.6 基于 Send 和 Sync 的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84-Rc"><span class="toc-number">5.6.1.</span> <span class="toc-text">无法用于多线程的 Rc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc-%E5%92%8C-Arc-%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">5.6.2.</span> <span class="toc-text">Rc 和 Arc 源码对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Send-%E5%92%8C-Sync"><span class="toc-number">5.6.3.</span> <span class="toc-text">Send 和 Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Send-%E5%92%8C-Sync-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.4.</span> <span class="toc-text">实现 Send 和 Sync 的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0-Send"><span class="toc-number">5.6.5.</span> <span class="toc-text">裸指针实现 Send</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0-Sync"><span class="toc-number">5.6.6.</span> <span class="toc-text">裸指针实现 Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.6.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">3.7 全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">编译期初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">静态常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.3.</span> <span class="toc-text">原子类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">运行期初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lazy-static"><span class="toc-number">6.2.1.</span> <span class="toc-text">lazy_static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-leak-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">Box::leak</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">从函数中返回全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84-OnceCall"><span class="toc-number">6.3.</span> <span class="toc-text">标准库的 OnceCall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">3.8 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">组合器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#or-amp-and"><span class="toc-number">7.1.1.</span> <span class="toc-text">or() &amp; and()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#or-else-amp-and-then"><span class="toc-number">7.1.2.</span> <span class="toc-text">or_else() &amp; and_then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-number">7.1.3.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-amp-map-err"><span class="toc-number">7.1.4.</span> <span class="toc-text">map() &amp; map_err()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-or-amp-map-or-else"><span class="toc-number">7.1.5.</span> <span class="toc-text">map_or() &amp; map_or_else()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ok-or-amp-ok-or-else"><span class="toc-number">7.1.6.</span> <span class="toc-text">ok_or() &amp; ok_or_else()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">自定义错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2-From-%E7%89%B9%E5%BE%81"><span class="toc-number">7.2.1.</span> <span class="toc-text">错误转换 From 特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8D%E5%90%8C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.</span> <span class="toc-text">归一化不同错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-lt-dyn-Error-gt"><span class="toc-number">7.3.1.</span> <span class="toc-text">Box&lt;dyn Error&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">7.3.2.</span> <span class="toc-text">自定义错误类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">简化错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thiserror"><span class="toc-number">7.4.1.</span> <span class="toc-text">thiserror</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Unsafe-Rust"><span class="toc-number">8.</span> <span class="toc-text">3.9 Unsafe Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.1.</span> <span class="toc-text">Unsafe 出现的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">Unsafe 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E4%BA%94%E7%A7%8D%E4%BD%9C%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">3.9.1 五种作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.</span> <span class="toc-text">解引用裸指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">基于引用创建裸指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">基于内存地址创建裸指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">使用 * 解引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.4.</span> <span class="toc-text">基于智能指针创建裸指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-unsafe-%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">调用 unsafe 函数或方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FFI"><span class="toc-number">8.3.3.</span> <span class="toc-text">FFI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABI"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">ABI</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-unsafe-%E7%89%B9%E5%BE%81"><span class="toc-number">8.3.4.</span> <span class="toc-text">实现 unsafe 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-union-%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">8.3.5.</span> <span class="toc-text">访问 union 中的字段</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        4.Rust高级进阶
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Ak1raKay</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-05-05T05:56:33.000Z" itemprop="datePublished">2022-05-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Rust/">Rust</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Rust/" rel="tag">Rust</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="3-1-生命周期"><a href="#3-1-生命周期" class="headerlink" title="3.1 生命周期"></a>3.1 生命周期</h2><h3 id="3-1-1-认识生命周期"><a href="#3-1-1-认识生命周期" class="headerlink" title="3.1.1 认识生命周期"></a>3.1.1 认识生命周期</h3><p>生命周期，简而言之就是引用的有效作用域。</p>
<p>多数情况下编译器可以自动进行推导，用类型来类比下：</p>
<ul>
<li>就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期</li>
<li>在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期</li>
</ul>
<h4 id="悬垂指针与生命周期"><a href="#悬垂指针与生命周期" class="headerlink" title="悬垂指针与生命周期"></a>悬垂指针与生命周期</h4><p>生命周期的主要作用是避免悬垂引用，它会导致程序引用了本不该引用的数据：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">            r = &amp;x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码有几点值得注意:</p>
<ul>
<li><code>let r;</code> 的声明方式貌似存在使用 <code>null</code> 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错</li>
<li><p><code>r</code> 引用了内部花括号中的 <code>x</code> 变量，但是 <code>x</code> 会在内部花括号 <code>&#125;</code> 处被释放，因此回到外部花括号后，<code>r</code> 会引用一个无效的 <code>x</code></p>
<p><code>r</code> 就是一个悬垂指针，它引用了提前被释放的变量 <code>x</code></p>
</li>
</ul>
<h4 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h4><p>为保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)来检查我们程序借用的正确性：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#![allow(unused)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let r;                        // ---------+-- &#x27;a</span><br><span class="line">                                      //          |</span><br><span class="line">        &#123;                             //          |</span><br><span class="line">                                      //          |</span><br><span class="line">            let x = 5;                // -+-- &#x27;b  |</span><br><span class="line">            r = &amp;x;                   //  |       |</span><br><span class="line">        &#125;                             // -+       |</span><br><span class="line">                                      //          |</span><br><span class="line">        println!(&quot;r: &#123;&#125;&quot;, r);         //          |</span><br><span class="line">    &#125;                                 // ---------+</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器，Rust 会检查两个变量的生命周期，因为 <code>r</code> 的生命周期 <code>&#39;a</code>  比 <code>x</code> 的生命周期 <code>&#39;b</code> 要大，因此拒绝运行。</p>
<h4 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h4><p>思考下面的例子：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string2</span> = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="title function_ invoke__">longest</span>(string1.<span class="title function_ invoke__">as_str</span>(), string2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">22</span>:<span class="number">33</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>(x: &amp;<span class="type">str</span>, y: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">   |               ----     ----     ^ expected named lifetime parameter</span><br><span class="line">   |</span><br><span class="line">   = help: this function<span class="symbol">&#x27;s</span> <span class="keyword">return</span> <span class="keyword">type</span> <span class="title class_">contains</span> a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`</span><br><span class="line">help: consider introducing a named lifetime parameter</span><br><span class="line">   |</span><br><span class="line"><span class="number">22</span> | <span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">   |           ++++     ++          ++          ++</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0106`.</span><br></pre></td></tr></table></figure>
<p>编译器无法知道该函数的返回值到底引用 <code>x</code> 还是 <code>y</code> ，<strong>因为编译器需要知道这些，来确保函数调用后的引用生命周期分析</strong>。</p>
<p>在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</p>
<h4 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h4><blockquote>
<p>  生命周期标注并不会改变任何引用的实际作用域</p>
</blockquote>
<p>语法：以 <code>&#39;</code> 开头，名称往往是一个单独的小写字母。eg: ‘a.</p>
<p>引用类型参数 -&gt; 生命周期会位于引用符号 <code>&amp;</code> 之后，并用一个空格隔开。 eg: <code>&amp;&#39;a i32</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;<span class="type">i32</span>        <span class="comment">// 一个引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="type">i32</span>     <span class="comment">// 具有显式生命周期的引用</span></span><br><span class="line">&amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> <span class="type">i32</span> <span class="comment">// 具有显式生命周期的可变引用</span></span><br></pre></td></tr></table></figure>
<h5 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的点如下：</p>
<ul>
<li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li>
<li><code>x</code>、<code>y</code> 和返回值至少活得和 <code>&#39;a</code> 一样久(因为返回值要么是 <code>x</code>，要么是 <code>y</code>)</li>
</ul>
<h5 id="深入思考生命周期标注"><a href="#深入思考生命周期标注" class="headerlink" title="深入思考生命周期标注"></a>深入思考生命周期标注</h5><p><strong>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于</strong>：</p>
<ul>
<li>函数参数的生命周期</li>
<li>函数体中某个新建引用的生命周期</li>
</ul>
<p>若是后者情况，就是典型的悬垂引用场景：最好的办法就是返回内部字符串的所有权，然后把字符串的所有权转移给调用者。</p>
<p>对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。</p>
<h4 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h4><p>为结构体中每一项引用标注生命周期即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结构体 <code>ImportantExcerpt</code> 所引用的字符串 <code>str</code> 必须比该结构体活得更久</strong></p>
<h4 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h4><p>注意：</p>
<ul>
<li>消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期</li>
<li><strong>函数或者方法中，参数的生命周期被称为 <code>输入生命周期</code>，返回值的生命周期被称为 <code>输出生命周期</code></strong></li>
</ul>
<h5 id="三条消除规则"><a href="#三条消除规则" class="headerlink" title="三条消除规则"></a>三条消除规则</h5><ol>
<li><strong>每一个引用参数都会获得独自的生命周期</strong></li>
<li><strong>若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期</strong></li>
<li><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong></li>
</ol>
<h4 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h4><p>为具有生命周期的结构体实现方法时，我们使用的语法跟泛型参数语法很相似：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">level</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">            <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h4><p>Rust 中有一个非常特殊的生命周期，那就是 <code>&#39;static</code>，拥有该生命周期的引用可以和整个程序活得一样久。</p>
<p>总结如下：</p>
<ul>
<li>生命周期 <code>&#39;static</code> 意味着能和程序活得一样久，例如字符串字面量和特征对象</li>
<li>实在遇到解决不了的生命周期标注问题，可以尝试 <code>T: &#39;static</code>，有时候它会给你奇迹</li>
</ul>
<h3 id="3-1-2-深入生命周期-TODO"><a href="#3-1-2-深入生命周期-TODO" class="headerlink" title="3.1.2 深入生命周期[TODO]"></a>3.1.2 深入生命周期[TODO]</h3><h3 id="3-1-3-amp-’static-和-T-‘static"><a href="#3-1-3-amp-’static-和-T-‘static" class="headerlink" title="3.1.3 &amp;’static 和 T: ‘static"></a>3.1.3 &amp;’static 和 T: ‘static</h3><p><code>&#39;static</code> 在 Rust 中是相当常见的，例如字符串字面值就具有 <code>&#39;static</code> 生命周期:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mark_twain</span>: &amp;<span class="type">str</span> = <span class="string">&quot;Samuel Clemens&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print_author</span>(mark_twain);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_author</span>(author: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, author);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&#39;static</code> 的另一种使用场景:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mark_twain</span> = <span class="string">&quot;Samuel Clemens&quot;</span>;</span><br><span class="line">    <span class="title function_ invoke__">print</span>(&amp;mark_twain);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print</span>&lt;T: Display + <span class="symbol">&#x27;static</span>&gt;(message: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="amp-’static"><a href="#amp-’static" class="headerlink" title="&amp;’static"></a>&amp;’static</h4><p><code>&amp;&#39;static</code> 对于生命周期有着非常强的要求：一个引用必须要活得跟剩下的程序一样久，才能被标注为 <code>&amp;&#39;static</code>。</p>
<p><strong><code>&amp;&#39;static</code> 生命周期针对的仅仅是引用，而不是持有该引用的变量，对于变量来说，还是要遵循相应的作用域规则。</strong></p>
<h4 id="T-‘static"><a href="#T-‘static" class="headerlink" title="T: ‘static"></a>T: ‘static</h4><h4 id="static-到底针对谁？"><a href="#static-到底针对谁？" class="headerlink" title="static 到底针对谁？"></a>static 到底针对谁？</h4><ul>
<li><p>是 <code>&amp;&#39;static</code> 这个引用还是该引用指向的数据活得跟程序一样久呢？</p>
<p><strong>答案是引用指向的数据</strong>，而引用本身是要遵循其作用域范围的</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>经验之谈，可以这么来:</p>
<ul>
<li>如果你需要添加 <code>&amp;&#39;static</code> 来让代码工作，那很可能是设计上出问题了</li>
<li>如果你希望满足和取悦编译器，那就使用 <code>T: &#39;static</code>，很多时候它都能解决问题</li>
</ul>
<h2 id="3-2-函数式编程：闭包、迭代器"><a href="#3-2-函数式编程：闭包、迭代器" class="headerlink" title="3.2 函数式编程：闭包、迭代器"></a>3.2 函数式编程：闭包、迭代器</h2><h3 id="3-2-1-闭包-Closure"><a href="#3-2-1-闭包-Closure" class="headerlink" title="3.2.1 闭包 Closure"></a>3.2.1 闭包 <code>Closure</code></h3><p>闭包：匿名函数，可以赋值给变量或作为参数传递给其他函数，允许捕获调用者作用域中的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">let</span> <span class="variable">sum</span> = |y| x + y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, <span class="title function_ invoke__">sum</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用闭包简化代码"><a href="#使用闭包简化代码" class="headerlink" title="使用闭包简化代码"></a>使用闭包简化代码</h4><p>通过将函数赋值给某一变量，可以快速调整对此函数的使用。</p>
<h4 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h4><p>闭包的形式定义：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|param1, param2,...| &#123;</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    返回表达式</span><br><span class="line">&#125;</span><br><span class="line">or</span><br><span class="line">|param1| 返回表达式</span><br></pre></td></tr></table></figure>
<h4 id="闭包类型推导"><a href="#闭包类型推导" class="headerlink" title="闭包类型推导"></a>闭包类型推导</h4><p>多数情况下，不需要显式声明类型。</p>
<p>同一功能的函数与闭包实现形式：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span>  <span class="title function_">add_one_v1</span>   (x: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v2</span> = |x: <span class="type">u32</span>| <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v3</span> = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">add_one_v4</span> = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>
<p>闭包的类型推导中，<strong>当编译器推导出一种类型后，它就会一直使用该类型</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">example_closure</span> = |x| x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="title function_ invoke__">example_closure</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line">  -<span class="punctuation">-&gt;</span> src/main.rs:<span class="number">13</span>:<span class="number">29</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">13</span> |     <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">example_closure</span>(<span class="number">5</span>);</span><br><span class="line">   |                             ^- help: <span class="keyword">try</span> using a conversion method: `.<span class="title function_ invoke__">to_string</span>()`</span><br><span class="line">   |                             |</span><br><span class="line">   |                             expected <span class="keyword">struct</span> `<span class="type">String</span>`, found integer</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br></pre></td></tr></table></figure>
<h4 id="结构体中的闭包"><a href="#结构体中的闭包" class="headerlink" title="结构体中的闭包"></a>结构体中的闭包</h4><p>假设我们要实现一个简易缓存，功能是获取一个值，然后将其缓存起来，那么可以这样设计：</p>
<ul>
<li>一个闭包用于获取值</li>
<li>一个变量，用于存储该值</li>
</ul>
<p>可以使用结构体来代表缓存对象，最终设计如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Cacher</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    query: T,</span><br><span class="line">    value: <span class="type">Option</span>&lt;<span class="type">u32</span>&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  Fn 特征不仅仅适用于闭包，还适用于函数</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; Cacher&lt;T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: <span class="title function_ invoke__">Fn</span>(<span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(query: T) <span class="punctuation">-&gt;</span> Cacher&lt;T&gt; &#123;</span><br><span class="line">        Cacher &#123;</span><br><span class="line">            query,</span><br><span class="line">            value: <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先查询缓存值 `self.value`，若不存在，则调用 `query` 加载</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, arg: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.value &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(v) =&gt; v,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">v</span> = (<span class="keyword">self</span>.query)(arg);</span><br><span class="line">                <span class="keyword">self</span>.value = <span class="title function_ invoke__">Some</span>(v);</span><br><span class="line">                v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="捕获作用域中的值"><a href="#捕获作用域中的值" class="headerlink" title="捕获作用域中的值"></a>捕获作用域中的值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">equal_to_x</span> = |z| z == x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(<span class="title function_ invoke__">equal_to_x</span>(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>x</code> 并不是闭包 <code>equal_to_x</code> 的参数，但是它依然可以去使用 <code>x</code>，因为 <code>equal_to_x</code> 在 <code>x</code> 的作用域范围内。</p>
<h5 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h5><p>当闭包从环境中捕获一个值时，会<strong>分配内存</strong>去存储这些值。</p>
<h4 id="三种-Fn-特征"><a href="#三种-Fn-特征" class="headerlink" title="三种 Fn 特征"></a>三种 <code>Fn</code> 特征</h4><ol>
<li><p><code>FnOnce</code>，该类型的闭包会拿走被捕获变量的所有权。<code>Once</code> 顾名思义，说明该闭包只能运行一次：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">fn_once</span>&lt;F&gt;(func: F)</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    F: <span class="title function_ invoke__">FnOnce</span>(<span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="title function_ invoke__">func</span>(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_ invoke__">fn_once</span>(|z| z == x.<span class="title function_ invoke__">len</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  <strong>仅</strong>实现 <code>FnOnce</code> 特征的闭包在调用时会转移所有权。</p>
</blockquote>
</li>
<li><p><code>FnMut</code>，它以可变借用的方式捕获了环境中的值:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> = |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line">    <span class="title function_ invoke__">update_string</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Fn</code> 特征，它以不可变借用的方式捕获环境中的值:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> =  |<span class="type">str</span>| s.<span class="title function_ invoke__">push_str</span>(<span class="type">str</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;<span class="symbol">&#x27;a</span>, F: <span class="title function_ invoke__">Fn</span>(&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>)&gt;(<span class="keyword">mut</span> f: F)  &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="move-和-Fn"><a href="#move-和-Fn" class="headerlink" title="move 和 Fn"></a><code>move</code> 和 <code>Fn</code></h5><p><strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量</strong></p>
<h5 id="三种-Fn-的关系"><a href="#三种-Fn-的关系" class="headerlink" title="三种 Fn 的关系"></a>三种 <code>Fn</code> 的关系</h5><p>一个闭包并不仅仅实现某一种 <code>Fn</code> 特征，规则如下：</p>
<ul>
<li>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次</li>
<li>没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征</li>
<li>不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">update_string</span> = || <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">exec</span>(update_string);</span><br><span class="line">    <span class="title function_ invoke__">exec1</span>(update_string);</span><br><span class="line">    <span class="title function_ invoke__">exec2</span>(update_string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec</span>&lt;F: <span class="title function_ invoke__">FnOnce</span>()&gt;(f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec1</span>&lt;F: <span class="title function_ invoke__">FnMut</span>()&gt;(<span class="keyword">mut</span> f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">exec2</span>&lt;F: <span class="title function_ invoke__">Fn</span>()&gt;(f: F) &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="闭包作为函数返回值"><a href="#闭包作为函数返回值" class="headerlink" title="闭包作为函数返回值"></a>闭包作为函数返回值</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">factory</span>(x:<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">Box</span>&lt;<span class="keyword">dyn</span> <span class="title function_ invoke__">Fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span>&#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x + num)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="keyword">move</span> |x| x - num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-迭代器-Iterator"><a href="#3-2-2-迭代器-Iterator" class="headerlink" title="3.2.2 迭代器 Iterator"></a>3.2.2 迭代器 <code>Iterator</code></h3><h4 id="For-与迭代器"><a href="#For-与迭代器" class="headerlink" title="For 与迭代器"></a><code>For</code> 与迭代器</h4><p>区别在于是否通过<strong>索引</strong>来访问集合</p>
<p><code>Rust</code>中数组实现了 <code>IntoIterator</code>特征，通过<code>for</code>语法糖将该特征的数组转换为迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> arr &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>IntoIterator</code> 特征有一个 <code>into_iter</code> 方法，可以显式的把数组转换成迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">v</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">into_iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h4><p>Rust中迭代器是惰性的。</p>
<h4 id="IntoIterator特征"><a href="#IntoIterator特征" class="headerlink" title="IntoIterator特征"></a><code>IntoIterator</code>特征</h4><h5 id="into-iter-iter-iter-mut"><a href="#into-iter-iter-iter-mut" class="headerlink" title="into_iter, iter, iter_mut"></a><code>into_iter</code>, <code>iter</code>, <code>iter_mut</code></h5><ul>
<li><code>into_iter</code> 会夺走所有权</li>
<li><code>iter</code> 是借用</li>
<li><code>iter_mut</code> 是可变借用</li>
</ul>
<h5 id="Iterator-和-IntoIterator-的区别"><a href="#Iterator-和-IntoIterator-的区别" class="headerlink" title="Iterator 和 IntoIterator 的区别"></a><code>Iterator</code> 和 <code>IntoIterator</code> 的区别</h5><ul>
<li><code>Iterator</code> 就是迭代器特征，只有实现了它才能称为迭代器，才能调用 <code>next</code></li>
<li><code>IntoIterator</code> 强调的是某一个类型如果实现了该特征，它可以通过 <code>into_iter</code>，<code>iter</code> 等方法变成一个迭代器</li>
</ul>
<h4 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h4><h5 id="消费者适配器"><a href="#消费者适配器" class="headerlink" title="消费者适配器"></a>消费者适配器</h5><p>迭代器上的某个方法 <code>A</code> 在其内部调用了 <code>next</code> 方法，那么 <code>A</code> 就被称为<strong>消费性适配器</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1_iter</span> = v1.<span class="title function_ invoke__">iter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">total</span>: <span class="type">i32</span> = v1_iter.<span class="title function_ invoke__">sum</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(total, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// v1_iter 是借用了 v1，因此 v1 可以照常使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码会报错，因为 `sum` 拿到了迭代器 `v1_iter` 的所有权</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v1_iter);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h5><p>迭代器适配器，顾名思义，会返回一个新的迭代器。</p>
<p>迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v1</span>: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v2</span>: <span class="type">Vec</span>&lt;_&gt; = v1.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|x| x + <span class="number">1</span>).<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v2, <span class="built_in">vec!</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-深入类型"><a href="#3-3-深入类型" class="headerlink" title="3.3 深入类型"></a>3.3 深入类型</h2><h3 id="3-3-1-newtype-和类型别名"><a href="#3-3-1-newtype-和类型别名" class="headerlink" title="3.3.1 newtype 和类型别名"></a>3.3.1 <code>newtype</code> 和类型别名</h3><h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><p>使用<strong>元组结构体</strong>的方式将已有的类型包裹起来：<code>Meters（u32）</code>，<code>Meters</code> 就是一个<code>newtype</code>。</p>
<p>好处：</p>
<ul>
<li>自定义类型可以让我们给出更有意义和可读性的类型名</li>
<li>对于某些场景，只有 <code>newtype</code> 可以很好地解决</li>
<li>隐藏内部类型的细节</li>
</ul>
<h4 id="为外部类型实现外部特征"><a href="#为外部类型实现外部特征" class="headerlink" title="为外部类型实现外部特征"></a>为外部类型实现外部特征</h4><p>在外部类型上实现外部特征必须使用 <code>newtype</code> 的方式，否则你就得遵循孤儿规则：要为类型 <code>A</code> 实现特征 <code>T</code>，那么 <code>A</code> 或者 <code>T</code> 必须至少有一个在当前的作用范围内。</p>
<p>使用 <code>newtype</code> 对标注库类型 <code>Vec</code> 实现 <code>Display</code> 特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Wrapper</span>(<span class="type">Vec</span>&lt;<span class="type">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Wrapper</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;[&#123;&#125;]&quot;</span>, <span class="keyword">self</span>.<span class="number">0</span>.<span class="title function_ invoke__">join</span>(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">w</span> = <span class="title function_ invoke__">Wrapper</span>(<span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;w = &#123;&#125;&quot;</span>, w);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">w = [hello, world]</span><br></pre></td></tr></table></figure>
<h4 id="隐藏内部细节"><a href="#隐藏内部细节" class="headerlink" title="隐藏内部细节"></a>隐藏内部细节</h4><p>使用 <code>newtype</code> 对外隐藏内部细节：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Meters</span>(<span class="type">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span>: <span class="type">u32</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(i.<span class="title function_ invoke__">pow</span>(<span class="number">2</span>), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="title function_ invoke__">Meters</span>(i);</span><br><span class="line">    <span class="comment">// 下面的代码将报错，因为`Meters`类型上没有`pow`方法</span></span><br><span class="line">    <span class="comment">// assert_eq!(n.pow(2), 4);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>更传统的方式来创建新类型：类型别名</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Meters</span> = <span class="type">u32</span></span><br></pre></td></tr></table></figure>
<p><strong>类型别名并不是一个独立的全新的类型，而是某一个类型的别名</strong>。</p>
<h3 id="3-3-2-Sized-和不定长类型DST"><a href="#3-3-2-Sized-和不定长类型DST" class="headerlink" title="3.3.2 Sized 和不定长类型DST"></a>3.3.2 <code>Sized</code> 和不定长类型<code>DST</code></h3><ul>
<li>定长类型( sized )，这些类型的大小在编译时是已知的</li>
<li>不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST</li>
</ul>
<h4 id="动态大小类型-DST"><a href="#动态大小类型-DST" class="headerlink" title="动态大小类型 DST"></a>动态大小类型 <code>DST</code></h4><p><strong>因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译</strong>。</p>
<p>试图创建动态大小数组:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">my_function</span>(n: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">array</span> = [<span class="number">123</span>; n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切片:</p>
<p><code>str</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">str</span> = <span class="string">&quot;Hello there!&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span>: <span class="type">str</span> = <span class="string">&quot;How&#x27;s it going?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span>: &amp;<span class="type">str</span> = <span class="string">&quot;on?&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，将动态数据固定化的秘诀就是使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。</p>
<p>特征对象:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_1</span>(thing: &amp;<span class="keyword">dyn</span> MyThing) &#123;&#125; <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_2</span>(thing: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> MyThing&gt;) &#123;&#125; <span class="comment">// OK</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">foobar_3</span>(thing: MyThing) &#123;&#125; <span class="comment">// ERROR!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：只能间接使用的 DST</p>
<p>Rust 中常见的 <code>DST</code> 类型有: <code>str</code>、<code>[T]</code>、<code>dyn Trait</code>，<strong>它们都无法单独被使用，必须要通过引用或者 <code>Box</code> 来间接使用</strong> 。</p>
<h4 id="Size-特征"><a href="#Size-特征" class="headerlink" title="Size 特征"></a><code>Size</code> 特征</h4><p>Rust如何保证泛型参数是固定大小类型的？</p>
<p>编译器自动帮我们加上了 <code>Sized</code> 特征：<strong>所有在编译时就能知道其大小的类型，都会自动实现 <code>Sized</code> 特征</strong>。</p>
<p><strong>每一个特征都是一个可以通过名称来引用的动态大小类型</strong>。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 <code>&amp;dyn Trait</code> 或者 <code>Box&lt;dyn Trait&gt;</code> (还有 <code>Rc&lt;dyn Trait&gt;</code>)这些引用类型。</p>
<p>想在泛型函数中使用动态数据类型怎么办？可以使用 <code>?Sized</code> 特征：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">generic</span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>?Sized</code> 特征用于表明类型 <code>T</code> 是固定大小的类型，或者动态大小的类型。还有一点要注意的是，函数参数类型从 <code>T</code> 变成了 <code>&amp;T</code>，因为 <code>T</code> 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。</p>
<h4 id="Box-lt-str-gt"><a href="#Box-lt-str-gt" class="headerlink" title="Box&lt;str&gt;"></a><code>Box&lt;str&gt;</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span>: <span class="type">Box</span>&lt;<span class="type">str</span>&gt; = <span class="string">&quot;Hello there!&quot;</span>.<span class="title function_ invoke__">into</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-智能指针"><a href="#3-4-智能指针" class="headerlink" title="3.4 智能指针"></a>3.4 智能指针</h3><p>智能指针：通过比引用更复杂的数据结构，包含比引用更多的信息，例如元数据，当前长度，最大可用长度等。</p>
<h3 id="3-4-1-Box-堆对象分配"><a href="#3-4-1-Box-堆对象分配" class="headerlink" title="3.4.1 Box 堆对象分配"></a>3.4.1 <code>Box</code> 堆对象分配</h3><p> <code>Box&lt;T&gt;</code> 允许你将一个值分配到堆上，然后在栈上保留一个智能指针指向堆上的数据。</p>
<h4 id="Rust-中的堆栈"><a href="#Rust-中的堆栈" class="headerlink" title="Rust 中的堆栈"></a><code>Rust</code> 中的堆栈</h4><p>Rust 堆上对象有一个特殊之处，它们都拥有一个所有者，因此受所有权规则的限制：当赋值时，发生的是所有权的转移（只需浅拷贝栈上的引用或智能指针即可）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="title function_ invoke__">foo</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">foo</span>(x: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;Hello, &quot;</span>.<span class="title function_ invoke__">to_string</span>() + x;</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Box-使用场景"><a href="#Box-使用场景" class="headerlink" title="Box 使用场景"></a><code>Box</code> 使用场景</h4><p><code>Box</code> 特性：</p>
<ul>
<li>特意将数据分配在堆上</li>
<li>数据较大时，又不想在转移所有权时进行数据拷贝</li>
<li>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时</li>
<li>特征对象，用于说明对象实现了一个特征，而不是某个特定的类型</li>
</ul>
<h5 id="使用-Box-将数据存储在堆上"><a href="#使用-Box-将数据存储在堆上" class="headerlink" title="使用 Box 将数据存储在堆上"></a>使用 <code>Box</code> 将数据存储在堆上</h5><p>使用 <code>Deref</code> 解引用获取指针所指对象的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="comment">// a = 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面一行代码将报错</span></span><br><span class="line">    <span class="comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="避免栈上数据的拷贝"><a href="#避免栈上数据的拷贝" class="headerlink" title="避免栈上数据的拷贝"></a>避免栈上数据的拷贝</h5><p>当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 在栈上创建一个长度为1000的数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">0</span>; <span class="number">1000</span>];</span><br><span class="line">    <span class="comment">// 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> = arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 和 arr1 都拥有各自的栈上数组，因此不会报错</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="title function_ invoke__">len</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>([<span class="number">0</span>; <span class="number">1000</span>]);</span><br><span class="line">    <span class="comment">// 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝</span></span><br><span class="line">    <span class="comment">// 所有权顺利转移给 arr1，arr 不再拥有所有权</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> = arr;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    <span class="comment">// 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr.len());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="将动态大小类型变为-Sized-固定大小类型"><a href="#将动态大小类型变为-Sized-固定大小类型" class="headerlink" title="将动态大小类型变为 Sized 固定大小类型"></a>将动态大小类型变为 <code>Sized</code> 固定大小类型</h5><h5 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h5><p>实现不同类型组成的数组只有两个办法：枚举和特征对象。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Draw</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这是屏幕上第&#123;&#125;号按钮&quot;</span>, <span class="keyword">self</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">    id: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Draw</span> <span class="keyword">for</span> <span class="title class_">Select</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">draw</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;这个选择框贼难用&#123;&#125;&quot;</span>, <span class="keyword">self</span>.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">elems</span>: <span class="type">Vec</span>&lt;<span class="type">Box</span>&lt;<span class="keyword">dyn</span> Draw&gt;&gt; = <span class="built_in">vec!</span>[<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Button &#123; id: <span class="number">1</span> &#125;), <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Select &#123; id: <span class="number">2</span> &#125;)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> elems &#123;</span><br><span class="line">        e.<span class="title function_ invoke__">draw</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">这是屏幕上第<span class="number">1</span>号按钮</span><br><span class="line">这个选择框贼难用<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="Box-leak"><a href="#Box-leak" class="headerlink" title="Box::leak"></a><code>Box::leak</code></h4><p>它可以消费掉 <code>Box</code> 并且强制目标值从内存中泄漏。</p>
<p>使用场景：<br>如果你需要一个在运行期初始化的值，但是可以全局有效，也就是和整个程序活得一样久，那么就可以使用 <code>Box::leak</code>。</p>
<h3 id="3-4-2-Deref-解引用"><a href="#3-4-2-Deref-解引用" class="headerlink" title="3.4.2 Deref 解引用"></a>3.4.2 <code>Deref</code> 解引用</h3><h4 id="通过-获取引用背后的值"><a href="#通过-获取引用背后的值" class="headerlink" title="通过 * 获取引用背后的值"></a>通过 <code>*</code> 获取引用背后的值</h4><p>对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="智能指针解引用"><a href="#智能指针解引用" class="headerlink" title="智能指针解引用"></a>智能指针解引用</h4><p>智能指针通过实现 <code>Deref</code> 特征，自定义解引用结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T) <span class="punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">MyBox</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> <span class="title class_">MyBox</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Target</span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">deref</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">Self</span>::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<ul>
<li>在 <code>Deref</code> 特征中声明了关联类型 <code>Target</code>，在之前章节中介绍过，关联类型主要是为了提升代码可读性</li>
<li><code>deref</code> 返回的是一个常规引用，可以被 <code>*</code> 进行解引用</li>
</ul>
<h4 id="背后原理"><a href="#背后原理" class="headerlink" title="* 背后原理"></a><code>*</code> 背后原理</h4><p>智能指针 <code>Box</code> 解引用的背后：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(y.<span class="title function_ invoke__">deref</span>())</span><br></pre></td></tr></table></figure>
<p>首先调用 <code>deref()</code> 获取常规引用，再通过 <code>*</code> 对常规引用解引用，从而获取目标值。</p>
<h4 id="函数和方法中的隐式-Deref-转换"><a href="#函数和方法中的隐式-Deref-转换" class="headerlink" title="函数和方法中的隐式 Deref 转换"></a>函数和方法中的隐式 <code>Deref</code> 转换</h4><p>若一个类型实现了 <code>Deref</code> 特征，那它的引用在传给函数或方法时，会根据参数签名来决定是否进行隐式的 <code>Deref</code> 转换：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码有几点值得注意：</p>
<ul>
<li><code>String</code> 实现了 <code>Deref</code> 特征，可以在需要时自动被转换为 <code>&amp;str</code> 类型</li>
<li><code>&amp;s</code> 是一个 <code>&amp;String</code> 类型，当它被传给 <code>display</code> 函数时，自动通过 <code>Deref</code> 转换成了 <code>&amp;str</code></li>
<li>必须使用 <code>&amp;s</code> 的方式来触发 <code>Deref</code>(仅引用类型的实参才会触发自动解引用)</li>
</ul>
<h5 id="连续的隐式-Deref-转换"><a href="#连续的隐式-Deref-转换" class="headerlink" title="连续的隐式 Deref 转换"></a>连续的隐式 <code>Deref</code> 转换</h5><p><code>Deref</code> 可以支持连续的隐式转换，直到找到适合的形式为止：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = MyBox::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">    <span class="title function_ invoke__">display</span>(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">display</span>(s: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Deref-规则总结"><a href="#Deref-规则总结" class="headerlink" title="Deref 规则总结"></a><code>Deref</code> 规则总结</h4><h4 id="三种-Deref-转换"><a href="#三种-Deref-转换" class="headerlink" title="三种 Deref 转换"></a>三种 <code>Deref</code> 转换</h4><p>Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：</p>
<ul>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;T</code> 转换成 <code>&amp;U</code>，也就是我们之前看到的例子</li>
<li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;mut U</code></li>
<li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;U</code></li>
</ul>
<h3 id="3-4-3-Drop-释放资源"><a href="#3-4-3-Drop-释放资源" class="headerlink" title="3.4.3 Drop 释放资源"></a>3.4.3 <code>Drop</code> 释放资源</h3><h4 id="Rust-中资源回收"><a href="#Rust-中资源回收" class="headerlink" title="Rust 中资源回收"></a><code>Rust</code> 中资源回收</h4><p><code>Rust</code> 的自动资源回收依靠 <code>Drop</code> 特征。</p>
<h4 id="Drop-的顺序"><a href="#Drop-的顺序" class="headerlink" title="Drop 的顺序"></a><code>Drop</code> 的顺序</h4><ul>
<li><strong>变量级别，按照逆序的方式</strong></li>
<li><strong>结构体内部，按照顺序的方式</strong></li>
</ul>
<h4 id="手动回收"><a href="#手动回收" class="headerlink" title="手动回收"></a>手动回收</h4><p><code>Drop::drop</code> 只是借用了目标值的可变引用，后续代码依旧可以使用目标值。使用 <code>drop()</code> 函数获取目标值所有权，手动释放内存。</p>
<h4 id="互斥的-Copy-和-Drop"><a href="#互斥的-Copy-和-Drop" class="headerlink" title="互斥的 Copy 和 Drop"></a>互斥的 <code>Copy</code> 和 <code>Drop</code></h4><p>无法为一个类型同时实现 <code>Copy</code> 和 <code>Drop</code> 特征：因为实现了 <code>Copy</code> 的特征会被编译器隐式的复制，因此非常难以预测析构函数执行的时间和频率。</p>
<h3 id="3-4-4-Rc-与-Arc-实现-1vN-所有权机制"><a href="#3-4-4-Rc-与-Arc-实现-1vN-所有权机制" class="headerlink" title="3.4.4 Rc 与 Arc 实现 1vN 所有权机制"></a>3.4.4 <code>Rc</code> 与 <code>Arc</code> 实现 <code>1vN</code> 所有权机制</h3><p>Rust 所有权机制要求一个值只能有一个所有者，在如下情况中：</p>
<ul>
<li>在图数据结构中，多个边可能会拥有同一个节点，该节点直到没有边指向它时，才应该被释放清理</li>
<li>在多线程中，多个线程可能会持有同一个数据，但是你受限于 Rust 的安全机制，无法同时获取该数据的可变引用</li>
</ul>
<p>唯一所有者带来的限制处理起来就会很麻烦。因此 <code>Rust</code> 引入额外的实现：引用计数，允许一个数据资源在同一时刻拥有多个所有者。</p>
<p>此种实现机制即为：<code>Rc</code> 与 <code>Arc</code> ，前者使用单线程，后者适用多线程。</p>
<h4 id="Rc-lt-T-gt"><a href="#Rc-lt-T-gt" class="headerlink" title="Rc&lt;T&gt;"></a><code>Rc&lt;T&gt;</code></h4><p>使用 <code>Rc</code> 解决所有权转移问题：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello, world&quot;</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">2</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="title function_ invoke__">strong_count</span>(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Rc-clone"><a href="#Rc-clone" class="headerlink" title="Rc::clone"></a><code>Rc::clone</code></h5><p><code>Rc::clone</code>仅仅复制智能指针并增加引用计数，因此 <code>a</code> 和 <code>b</code> 共享底层数据。</p>
<h5 id="引用计数的变化"><a href="#引用计数的变化" class="headerlink" title="引用计数的变化"></a>引用计数的变化</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test ref counting&quot;</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating a = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after creating b = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">c</span> = Rc::<span class="title function_ invoke__">clone</span>(&amp;a);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;count after creating c = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count after c goes out of scope = &#123;&#125;&quot;</span>, Rc::<span class="title function_ invoke__">strong_count</span>(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">count after creating a = <span class="number">1</span></span><br><span class="line">count after creating b = <span class="number">2</span></span><br><span class="line">count after creating c = <span class="number">3</span></span><br><span class="line">count after c goes out of scope = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h5 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h5><p><code>Rc&lt;T&gt;</code> 是指向底层数据的不可变的引用，因此你无法通过它来修改数据，这也符合 Rust 的借用规则：要么存在多个不可变借用，要么只能存在一个可变借用。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><code>Rc/Arc</code> 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 <code>RefCell</code> 或互斥锁 <code>Mutex</code></li>
<li>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的</li>
<li><code>Rc</code> 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 <code>Arc</code></li>
<li><code>Rc&lt;T&gt;</code> 是一个智能指针，实现了 <code>Deref</code> 特征，因此你无需先解开 <code>Rc</code> 指针，再使用里面的 <code>T</code>，而是可以直接使用 <code>T</code></li>
</ul>
<h3 id="3-4-5-Cell-和-RefCell-内部可变性"><a href="#3-4-5-Cell-和-RefCell-内部可变性" class="headerlink" title="3.4.5 Cell 和 RefCell 内部可变性"></a>3.4.5 <code>Cell</code> 和 <code>RefCell</code> 内部可变性</h3><p>内部可变性的实现是因为 Rust 使用了 <code>unsafe</code> 来做到这一点。</p>
<h4 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a><code>Cell</code></h4><p><code>Cell</code> 和 <code>RefCell</code> 在功能上没有区别，区别在于 <code>Cell&lt;T&gt;</code> 适用于 <code>T</code> 实现 <code>Copy</code> 的情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::Cell;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">c</span> = Cell::<span class="title function_ invoke__">new</span>(<span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">one</span> = c.<span class="title function_ invoke__">get</span>();</span><br><span class="line">  c.<span class="title function_ invoke__">set</span>(<span class="string">&quot;qwer&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">two</span> = c.<span class="title function_ invoke__">get</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, one, two);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">asdf,qwer</span><br></pre></td></tr></table></figure>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a><code>RefCell</code></h4><div class="table-container">
<table>
<thead>
<tr>
<th>Rust 规则</th>
<th>智能指针带来的额外规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个数据只有一个所有者</td>
<td><code>Rc/Arc</code>让一个数据可以拥有多个所有者</td>
</tr>
<tr>
<td>要么多个不可变借用，要么一个可变借用</td>
<td><code>RefCell</code>实现编译期可变、不可变引用共存</td>
</tr>
<tr>
<td>违背规则导致<strong>编译错误</strong></td>
<td>违背规则导致<strong>运行时<code>panic</code></strong></td>
</tr>
</tbody>
</table>
</div>
<h5 id="RefCell-为何存在"><a href="#RefCell-为何存在" class="headerlink" title="RefCell 为何存在"></a><code>RefCell</code> 为何存在</h5><p><code>RefCell</code> 正是<strong>用于你确信代码是正确的，而编译器却发生了误判时</strong>。</p>
<h5 id="RefCell-简单总结"><a href="#RefCell-简单总结" class="headerlink" title="RefCell 简单总结"></a><code>RefCell</code> 简单总结</h5><ul>
<li>与 <code>Cell</code> 用于可 <code>Copy</code> 的值不同，<code>RefCell</code> 用于引用</li>
<li><code>RefCell</code> 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则</li>
<li><code>RefCell</code> 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li>
<li>使用 <code>RefCell</code> 时，违背借用规则会导致运行期的 <code>panic</code></li>
</ul>
<h2 id="3-5-循环引用与自引用"><a href="#3-5-循环引用与自引用" class="headerlink" title="3.5 循环引用与自引用"></a>3.5 循环引用与自引用</h2><h3 id="3-5-1-Week-与循环引用"><a href="#3-5-1-Week-与循环引用" class="headerlink" title="3.5.1 Week 与循环引用"></a>3.5.1 <code>Week</code> 与循环引用</h3><h4 id="Week"><a href="#Week" class="headerlink" title="Week"></a><code>Week</code></h4><div class="table-container">
<table>
<thead>
<tr>
<th><code>Weak</code></th>
<th><code>Rc</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>不计数</td>
<td>引用计数</td>
</tr>
<tr>
<td>不拥有所有权</td>
<td>拥有值的所有权</td>
</tr>
<tr>
<td>不阻止值被释放(drop)</td>
<td>所有权计数归零，才能 drop</td>
</tr>
<tr>
<td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td>
<td>引用的值必定存在</td>
</tr>
<tr>
<td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td>
<td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td>
</tr>
</tbody>
</table>
</div>
<p>使用方式简单总结下：<strong>对于父子引用关系，可以让父节点通过 <code>Rc</code> 来引用子节点，然后让子节点通过 <code>Weak</code> 来引用父节点</strong>。</p>
<h3 id="3-5-2-结构体中的自引用"><a href="#3-5-2-结构体中的自引用" class="headerlink" title="3.5.2 结构体中的自引用"></a>3.5.2 结构体中的自引用</h3><h4 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该引用指向上面的value</span></span><br><span class="line">    pointer_to_value: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-Option"><a href="#使用-Option" class="headerlink" title="使用 Option"></a>使用 <code>Option</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WhatAboutThis</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    nickname: <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tricky</span> = WhatAboutThis &#123;</span><br><span class="line">        name: <span class="string">&quot;Annabelle&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        nickname: <span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    tricky.nickname = <span class="title function_ invoke__">Some</span>(&amp;tricky.name[..<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, tricky);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">WhatAboutThis &#123; name: <span class="string">&quot;Annabelle&quot;</span>, nickname: <span class="title function_ invoke__">Some</span>(<span class="string">&quot;Anna&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unsafe-实现"><a href="#Unsafe-实现" class="headerlink" title="Unsafe 实现"></a><code>Unsafe</code> 实现</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">    value: <span class="type">String</span>,</span><br><span class="line">    pointer_to_value: *<span class="keyword">const</span> <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">SelfRef</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(txt: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        SelfRef &#123;</span><br><span class="line">            value: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(txt),</span><br><span class="line">            pointer_to_value: std::ptr::<span class="title function_ invoke__">null</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">init</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">self_ref</span>: *<span class="keyword">const</span> <span class="type">String</span> = &amp;<span class="keyword">self</span>.value;</span><br><span class="line">        <span class="keyword">self</span>.pointer_to_value = self_ref;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pointer_to_value</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(</span><br><span class="line">            !<span class="keyword">self</span>.pointer_to_value.<span class="title function_ invoke__">is_null</span>(),</span><br><span class="line">            <span class="string">&quot;Test::b called without Test::init being called first&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*(<span class="keyword">self</span>.pointer_to_value) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">t</span> = SelfRef::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    t.<span class="title function_ invoke__">init</span>();</span><br><span class="line">    <span class="comment">// 打印值和指针地址</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;:p&#125;&quot;</span>, t.<span class="title function_ invoke__">value</span>(), t.<span class="title function_ invoke__">pointer_to_value</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hello, <span class="number">0x7ff7b951b398</span></span><br></pre></td></tr></table></figure>
<h4 id="无法被移动的-Pin"><a href="#无法被移动的-Pin" class="headerlink" title="无法被移动的 Pin"></a>无法被移动的 <code>Pin</code></h4><p><code>Pin</code> 可以固定住一个值，防止该值在内存中被移动。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::marker::PhantomPinned;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"><span class="keyword">use</span> std::ptr::NonNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是一个自引用数据结构体，因为 slice 字段是一个指针，指向了 data 字段</span></span><br><span class="line"><span class="comment">// 我们无法使用普通引用来实现，因为违背了 Rust 的编译规则</span></span><br><span class="line"><span class="comment">// 因此，这里我们使用了一个裸指针，通过 NonNull 来确保它不会为 null</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    data: <span class="type">String</span>,</span><br><span class="line">    slice: NonNull&lt;<span class="type">String</span>&gt;,</span><br><span class="line">    _pin: PhantomPinned,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Unmovable</span> &#123;</span><br><span class="line">    <span class="comment">// 为了确保函数返回时数据的所有权不会被转移，我们将它放在堆上，唯一的访问方式就是通过指针</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(data: <span class="type">String</span>) <span class="punctuation">-&gt;</span> Pin&lt;<span class="type">Box</span>&lt;<span class="keyword">Self</span>&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = Unmovable &#123;</span><br><span class="line">            data,</span><br><span class="line">            <span class="comment">// 只有在数据到位时，才创建指针，否则数据会在开始之前就被转移所有权</span></span><br><span class="line">            slice: NonNull::<span class="title function_ invoke__">dangling</span>(),</span><br><span class="line">            _pin: PhantomPinned,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">boxed</span> = <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">slice</span> = NonNull::<span class="title function_ invoke__">from</span>(&amp;boxed.data);</span><br><span class="line">        <span class="comment">// 这里其实安全的，因为修改一个字段不会转移整个结构体的所有权</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">mut_ref</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt; = Pin::<span class="title function_ invoke__">as_mut</span>(&amp;<span class="keyword">mut</span> boxed);</span><br><span class="line">            Pin::<span class="title function_ invoke__">get_unchecked_mut</span>(mut_ref).slice = slice;</span><br><span class="line">        &#125;</span><br><span class="line">        boxed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">unmoved</span> = Unmovable::<span class="title function_ invoke__">new</span>(<span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line">    <span class="comment">// 只要结构体没有被转移，那指针就应该指向正确的位置，而且我们可以随意移动指针</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">still_unmoved</span> = unmoved;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(still_unmoved.slice, NonNull::<span class="title function_ invoke__">from</span>(&amp;still_unmoved.data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们的类型没有实现 `Unpin` 特征，下面这段代码将无法编译</span></span><br><span class="line">    <span class="comment">// let mut new_unmoved = Unmovable::new(&quot;world&quot;.to_string());</span></span><br><span class="line">    <span class="comment">// std::mem::swap(&amp;mut *still_unmoved, &amp;mut *new_unmoved);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-多线程并发编程"><a href="#3-6-多线程并发编程" class="headerlink" title="3.6 多线程并发编程"></a>3.6 多线程并发编程</h2><h3 id="3-6-1-并发与并行"><a href="#3-6-1-并发与并行" class="headerlink" title="3.6.1 并发与并行"></a>3.6.1 并发与并行</h3><p>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理。</p>
<h3 id="3-6-2-使用多线程"><a href="#3-6-2-使用多线程" class="headerlink" title="3.6.2 使用多线程"></a>3.6.2 使用多线程</h3><h4 id="多线程编程的风险"><a href="#多线程编程的风险" class="headerlink" title="多线程编程的风险"></a>多线程编程的风险</h4><ul>
<li>竞态条件</li>
<li>死锁</li>
<li>隐晦的BUG</li>
</ul>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hi number <span class="number">1</span> from the main thread!</span><br><span class="line">hi number <span class="number">1</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">2</span> from the main thread!</span><br><span class="line">hi number <span class="number">2</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the main thread!</span><br><span class="line">hi number <span class="number">4</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">4</span> from the main thread!</span><br><span class="line">hi number <span class="number">5</span> from the spawned thread!</span><br></pre></td></tr></table></figure>
<p>:warning: 注意：</p>
<ul>
<li>线程内部的代码使用闭包来执行</li>
<li><code>main</code> 线程一旦结束，程序就立刻结束</li>
<li><code>thread::sleep</code> 会让当前线程休眠指定的时间，随后其它线程会被调度运行</li>
</ul>
<h4 id="等待子线程结束"><a href="#等待子线程结束" class="headerlink" title="等待子线程结束"></a>等待子线程结束</h4><p>通过调用 <code>handle.join</code>，可以让当前线程阻塞，直到它等待的子线程的结束。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);</span><br><span class="line">        thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">hi number <span class="number">1</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">2</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">3</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">4</span> from the spawned thread!</span><br><span class="line">hi number <span class="number">1</span> from the main thread!</span><br><span class="line">hi number <span class="number">2</span> from the main thread!</span><br><span class="line">hi number <span class="number">3</span> from the main thread!</span><br><span class="line">hi number <span class="number">4</span> from the main thread!</span><br></pre></td></tr></table></figure>
<h4 id="线程闭包中使用-Move"><a href="#线程闭包中使用-Move" class="headerlink" title="线程闭包中使用 Move"></a>线程闭包中使用 <code>Move</code></h4><p>可以使用 <code>move</code> 来将所有权从一个线程转移到另外一个线程。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面代码会报错borrow of moved value: `v`</span></span><br><span class="line">    <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,v);</span></span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Here<span class="symbol">&#x27;s</span> a vector: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h4 id="线程结束"><a href="#线程结束" class="headerlink" title="线程结束"></a>线程结束</h4><p>线程代码执行完成，线程就会自动结束。如果不会执行完：</p>
<ul>
<li>IO型的任务，CPU占用比较小，线程大部分处于阻塞状态</li>
<li>CPU密集型任务，如果没有终止条件，可能会跑满CPU核心，直至 <code>main</code> 线程结束</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程A</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 再创建一个线程B</span></span><br><span class="line">        thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">loop</span> &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;I am a new thread.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待新创建的线程执行完成</span></span><br><span class="line">    new_thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Child thread is finish!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 睡眠一段时间，看子线程创建的子线程是否还在运行</span></span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程屏障"><a href="#线程屏障" class="headerlink" title="线程屏障"></a>线程屏障</h4><p>使用 <code>Barrier</code> 让多个线程都执行到某个点后，才继续一起往后执行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Barrier&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">barrier</span> = Arc::<span class="title function_ invoke__">new</span>(Barrier::<span class="title function_ invoke__">new</span>(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">6</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">b</span> = barrier.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span>|| &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;before wait&quot;</span>);</span><br><span class="line">            b.<span class="title function_ invoke__">wait</span>();</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;after wait&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">before wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br><span class="line">after wait</span><br></pre></td></tr></table></figure>
<h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line">    <span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line">    thread_local!(<span class="keyword">static</span> FOO: RefCell&lt;<span class="type">u32</span>&gt; = RefCell::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">        *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程开始时都会拿到线程局部变量的FOO的初始值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">            <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">1</span>);</span><br><span class="line">            *f.<span class="title function_ invoke__">borrow_mut</span>() = <span class="number">3</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管子线程中修改为了3，我们在这里依然拥有main线程中的局部值：2</span></span><br><span class="line">    FOO.<span class="title function_ invoke__">with</span>(|f| &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*f.<span class="title function_ invoke__">borrow</span>(), <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Condvar, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = Arc::<span class="title function_ invoke__">new</span>((Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>), Condvar::<span class="title function_ invoke__">new</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair2</span> = pair.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair2;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;changing started&quot;</span>);</span><br><span class="line">        *started = <span class="literal">true</span>;</span><br><span class="line">        cvar.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &amp;(<span class="keyword">ref</span> lock, <span class="keyword">ref</span> cvar) = &amp;*pair;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">started</span> = lock.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">while</span> !*started &#123;</span><br><span class="line">        started = cvar.<span class="title function_ invoke__">wait</span>(started).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;started changed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="只被调用一次的函数"><a href="#只被调用一次的函数" class="headerlink" title="只被调用一次的函数"></a>只被调用一次的函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::Once;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> VAL: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> INIT: Once = Once::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle1</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle2</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        INIT.<span class="title function_ invoke__">call_once</span>(|| &#123;</span><br><span class="line">            <span class="keyword">unsafe</span> &#123;</span><br><span class="line">                VAL = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle1.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    handle2.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">unsafe</span> &#123; VAL &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-3-线程同步：消息传递"><a href="#3-6-3-线程同步：消息传递" class="headerlink" title="3.6.3 线程同步：消息传递"></a>3.6.3 线程同步：消息传递</h3><blockquote>
<p>  Do not communicate by sharing memory; instead, share memory by communicating</p>
</blockquote>
<h4 id="消息通道"><a href="#消息通道" class="headerlink" title="消息通道"></a>消息通道</h4><p><code>Rust</code> 提供消息通道（<code>Channel</code>），支持<strong>多发多收</strong>特性。</p>
<h4 id="多发单收"><a href="#多发单收" class="headerlink" title="多发单收"></a>多发单收</h4><p>标准库提供了通道<code>std::sync::mpsc</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span></span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程，并发送消息</span></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span></span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span></span><br><span class="line">        <span class="comment">// tx.send(Some(1)).unwrap()</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在主线程中接收子线程发送的消息并输出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">receive <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="不阻塞的-try-recv-方法"><a href="#不阻塞的-try-recv-方法" class="headerlink" title="不阻塞的 try_recv 方法"></a>不阻塞的 <code>try_recv</code> 方法</h4><p>该方法并<strong>不会阻塞线程</strong>，当通道中没有消息时，它会立刻返回一个错误：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="title function_ invoke__">try_recv</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">receive <span class="title function_ invoke__">Err</span>(empty)</span><br></pre></td></tr></table></figure>
<h4 id="具有所有权的数据"><a href="#具有所有权的数据" class="headerlink" title="具有所有权的数据"></a>具有所有权的数据</h4><p>使用通道来传输数据，一样要遵循 Rust 的所有权规则：</p>
<ul>
<li>若值的类型实现了<code>Copy</code>特征，则直接复制一份该值，然后传输过去，例如之前的<code>i32</code>类型</li>
<li>若值没有实现<code>Copy</code>，则它的所有权会被转移给接收端，在发送端继续使用该值将报错</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;我，飞走咯!&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;val is &#123;&#125;&quot;</span>, s); <span class="comment">// value moved here</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">received</span> = rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="循环接收数据"><a href="#循环接收数据" class="headerlink" title="循环接收数据"></a>循环接收数据</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">vals</span> = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;from&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;the&quot;</span>),</span><br><span class="line">            <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;thread&quot;</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="variable">val</span> <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.<span class="title function_ invoke__">send</span>(val).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多发送者"><a href="#多发送者" class="headerlink" title="多发送者"></a>多发送者</h4><p>子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tx1</span> = tx.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from raw tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        tx1.<span class="title function_ invoke__">send</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi from cloned tx&quot;</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">received</span> <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Got: &#123;&#125;&quot;</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><p><code>FIFO</code> 原则</p>
<h4 id="同步-amp-异步通道"><a href="#同步-amp-异步通道" class="headerlink" title="同步 &amp; 异步通道"></a>同步 &amp; 异步通道</h4><h5 id="异步通道"><a href="#异步通道" class="headerlink" title="异步通道"></a>异步通道</h5><p>无论接收者是否正在接收消息，消息发送者在发送消息时都不会阻塞:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async channel</span></span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之前&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之后&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">睡眠之前</span><br><span class="line">发送之前</span><br><span class="line">发送之后</span><br><span class="line">睡眠之后</span><br><span class="line">receive <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h5 id="同步通道"><a href="#同步通道" class="headerlink" title="同步通道"></a>同步通道</h5><p>同步通道<strong>发送消息是阻塞的，只有在消息被接收后才解除阻塞</strong>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之前&quot;</span>);</span><br><span class="line">        tx.<span class="title function_ invoke__">send</span>(<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;发送之后&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之前&quot;</span>);</span><br><span class="line">    thread::<span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_secs</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;睡眠之后&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">    handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">睡眠之前</span><br><span class="line">发送之前</span><br><span class="line">睡眠之后</span><br><span class="line">receive <span class="number">1</span></span><br><span class="line">发送之后</span><br></pre></td></tr></table></figure>
<h5 id="消息缓存"><a href="#消息缓存" class="headerlink" title="消息缓存"></a>消息缓存</h5><p>通过创建通道时传递参数<code>mpsc::sync_channel(N);</code> N，来设置缓存大小。</p>
<h4 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h4><p><strong>所有发送者被<code>drop</code>或者所有接收者被<code>drop</code>后，通道会自动关闭</strong>。</p>
<h4 id="传输多种类型"><a href="#传输多种类型" class="headerlink" title="传输多种类型"></a>传输多种类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc::&#123;<span class="keyword">self</span>, Receiver, Sender&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Apple</span>(<span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">Orange</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx): (Sender&lt;Fruit&gt;, Receiver&lt;Fruit&gt;) = mpsc::<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Orange</span>(<span class="string">&quot;sweet&quot;</span>.<span class="title function_ invoke__">to_string</span>())).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    tx.<span class="title function_ invoke__">send</span>(Fruit::<span class="title function_ invoke__">Apple</span>(<span class="number">2</span>)).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> rx.<span class="title function_ invoke__">recv</span>().<span class="title function_ invoke__">unwrap</span>() &#123;</span><br><span class="line">            Fruit::<span class="title function_ invoke__">Apple</span>(count) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;received &#123;&#125; apples&quot;</span>, count),</span><br><span class="line">            Fruit::<span class="title function_ invoke__">Orange</span>(flavor) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;received &#123;&#125; oranges&quot;</span>, flavor),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">received sweet oranges</span><br><span class="line">received <span class="number">2</span> apples</span><br></pre></td></tr></table></figure>
<h3 id="3-6-4-线程同步：锁、Condvar、信号量"><a href="#3-6-4-线程同步：锁、Condvar、信号量" class="headerlink" title="3.6.4 线程同步：锁、Condvar、信号量"></a>3.6.4 线程同步：锁、Condvar、信号量</h3><h4 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 <code>Mutex</code></h4><h5 id="单线程中使用-Mutex"><a href="#单线程中使用-Mutex" class="headerlink" title="单线程中使用 Mutex"></a>单线程中使用 <code>Mutex</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">m</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取锁，然后deref为`m`的引用</span></span><br><span class="line">        <span class="comment">// lock返回的是Result</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = m.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">        <span class="comment">// 锁自动被drop</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;m = &#123;:?&#125;&quot;</span>, m);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">m = Mutex &#123; data: <span class="number">6</span>, poisoned: <span class="literal">false</span>, .. &#125;</span><br></pre></td></tr></table></figure>
<h5 id="多线程中使用-Mutex"><a href="#多线程中使用-Mutex" class="headerlink" title="多线程中使用 Mutex"></a>多线程中使用 <code>Mutex</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handles</span> = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">counter</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">handle</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.<span class="title function_ invoke__">push</span>(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="type">Result</span>: <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h5 id="内部可变性"><a href="#内部可变性" class="headerlink" title="内部可变性"></a>内部可变性</h5><p>简单总结下：<code>Rc&lt;T&gt;/RefCell&lt;T&gt;</code>用于单线程内部可变性， <code>Arc&lt;T&gt;/Mutext&lt;T&gt;</code>用于多线程内部可变性。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="单线程死锁"><a href="#单线程死锁" class="headerlink" title="单线程死锁"></a>单线程死锁</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d1</span> = data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">d2</span> = data.<span class="title function_ invoke__">lock</span>();</span><br><span class="line">&#125; <span class="comment">// d1锁在此处释放</span></span><br></pre></td></tr></table></figure>
<h5 id="多线程死锁"><a href="#多线程死锁" class="headerlink" title="多线程死锁"></a>多线程死锁</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread::sleep;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    sync::&#123;Mutex, MutexGuard&#125;,</span><br><span class="line">    thread,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MUTEX1: Mutex&lt;<span class="type">i64</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> MUTEX2: Mutex&lt;<span class="type">i64</span>&gt; = Mutex::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 存放子线程的句柄</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">children</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i_thread</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">2</span> &#123;</span><br><span class="line">        children.<span class="title function_ invoke__">push</span>(thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 线程1</span></span><br><span class="line">                <span class="keyword">if</span> i_thread % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">                    <span class="comment">// 锁住MUTEX1</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">guard</span>: MutexGuard&lt;<span class="type">i64</span>&gt; = MUTEX1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住了MUTEX1，接着准备去锁MUTEX2 !&quot;</span>, i_thread);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当前线程睡眠一小会儿，等待线程2锁住MUTEX2</span></span><br><span class="line">                    <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 去锁MUTEX2</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">guard</span> = MUTEX2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                <span class="comment">// 线程2</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 锁住MUTEX2</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_guard</span> = MUTEX2.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;线程 &#123;&#125; 锁住了MUTEX2, 准备去锁MUTEX1&quot;</span>, i_thread);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">_guard</span> = MUTEX1.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等子线程完成</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">child</span> <span class="keyword">in</span> children &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">_</span> = child.<span class="title function_ invoke__">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;死锁没有发生&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="try-lock"><a href="#try-lock" class="headerlink" title="try_lock"></a><code>try_lock</code></h5><p> <code>try_lock</code>会<strong>尝试</strong>去获取一次锁，如果无法获取会返回一个错误，因此<strong>不会发生阻塞</strong>。</p>
<h4 id="读写锁-RwLock"><a href="#读写锁-RwLock" class="headerlink" title="读写锁 RwLock"></a>读写锁 <code>RwLock</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::RwLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = RwLock::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间允许多个读</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r1</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">r2</span> = lock.<span class="title function_ invoke__">read</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r1, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*r2, <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="comment">// 读锁在此处被drop</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同一时间只允许一个写</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">w</span> = lock.<span class="title function_ invoke__">write</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        *w += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(*w, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下代码会panic，因为读和写不允许同时存在</span></span><br><span class="line">        <span class="comment">// 写锁w直到该语句块结束才被释放，因此下面的读锁依然处于`w`的作用域中</span></span><br><span class="line">        <span class="comment">// let r1 = lock.read();</span></span><br><span class="line">        <span class="comment">// println!(&quot;&#123;:?&#125;&quot;,r1);</span></span><br><span class="line">    &#125;<span class="comment">// 写锁在此处被drop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单总结下<code>RwLock</code>:</p>
<ol>
<li>同时允许多个读，但最多只能有一个写</li>
<li>读和写不能同时存在</li>
<li>读可以使用<code>read</code>、<code>try_read</code>，写<code>write</code>、<code>try_write</code>, 在实际项目中，<code>try_xxx</code>会安全的多</li>
</ol>
<h4 id="条件变量（Condvar）控制线程同步"><a href="#条件变量（Condvar）控制线程同步" class="headerlink" title="条件变量（Condvar）控制线程同步"></a>条件变量（Condvar）控制线程同步</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc,Mutex,Condvar&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;spawn,sleep&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">flag</span> = Arc::<span class="title function_ invoke__">new</span>(Mutex::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cond</span> = Arc::<span class="title function_ invoke__">new</span>(Condvar::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cflag</span> = flag.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ccond</span> = cond.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hdl</span> = <span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = &#123; *cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> !m &#123;</span><br><span class="line">                m = *ccond.<span class="title function_ invoke__">wait</span>(cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                m = <span class="literal">false</span>;</span><br><span class="line">                *cflag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            counter += <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;inner counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sleep</span>(Duration::<span class="title function_ invoke__">from_millis</span>(<span class="number">1000</span>));</span><br><span class="line">        *flag.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>() = <span class="literal">true</span>;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter &gt; <span class="number">3</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;outside counter: &#123;&#125;&quot;</span>, counter);</span><br><span class="line">        cond.<span class="title function_ invoke__">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    hdl.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, flag);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">outside counter: <span class="number">1</span></span><br><span class="line">inner counter: <span class="number">1</span></span><br><span class="line">outside counter: <span class="number">2</span></span><br><span class="line">inner counter: <span class="number">2</span></span><br><span class="line">outside counter: <span class="number">3</span></span><br><span class="line">inner counter: <span class="number">3</span></span><br><span class="line">Mutex &#123; data: <span class="literal">true</span>, poisoned: <span class="literal">false</span>, .. &#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 <code>Semaphore</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> tokio::sync::Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">semaphore</span> = Arc::<span class="title function_ invoke__">new</span>(Semaphore::<span class="title function_ invoke__">new</span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">join_handles</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">permit</span> = semaphore.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">acquire_owned</span>().<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        join_handles.<span class="title function_ invoke__">push</span>(tokio::<span class="title function_ invoke__">spawn</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 在这里执行任务...</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="title function_ invoke__">drop</span>(permit);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">handle</span> <span class="keyword">in</span> join_handles &#123;</span><br><span class="line">        handle.<span class="keyword">await</span>.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-5-线程同步：Atomic-原子操作与内存顺序"><a href="#3-6-5-线程同步：Atomic-原子操作与内存顺序" class="headerlink" title="3.6.5 线程同步：Atomic 原子操作与内存顺序"></a>3.6.5 线程同步：<code>Atomic</code> 原子操作与内存顺序</h3><h4 id="使用-Atomic-作为全局变量"><a href="#使用-Atomic-作为全局变量" class="headerlink" title="使用 Atomic 作为全局变量"></a>使用 <code>Atomic</code> 作为全局变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Sub;</span><br><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicU64, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Instant;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> N_TIMES: <span class="type">u64</span> = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">const</span> N_THREADS: <span class="type">usize</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> R: AtomicU64 = AtomicU64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add_n_times</span>(n: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            R.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Instant::<span class="title function_ invoke__">now</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">threads</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(N_THREADS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..N_THREADS &#123;</span><br><span class="line">        threads.<span class="title function_ invoke__">push</span>(<span class="title function_ invoke__">add_n_times</span>(N_TIMES));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">thread</span> <span class="keyword">in</span> threads &#123;</span><br><span class="line">        thread.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(N_TIMES * N_THREADS <span class="keyword">as</span> <span class="type">u64</span>, R.<span class="title function_ invoke__">load</span>(Ordering::Relaxed));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,Instant::<span class="title function_ invoke__">now</span>().<span class="title function_ invoke__">sub</span>(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存顺序"><a href="#内存顺序" class="headerlink" title="内存顺序"></a>内存顺序</h4><p>内存顺序是指 CPU 在访问内存时的顺序，该顺序可能受以下因素的影响：</p>
<ul>
<li>代码中的先后顺序</li>
<li>编译器优化导致在编译阶段发生改变(内存重排序 reordering)</li>
<li>运行阶段因 CPU 的缓存机制导致顺序被打乱</li>
</ul>
<h5 id="限定内存顺序的5个规则"><a href="#限定内存顺序的5个规则" class="headerlink" title="限定内存顺序的5个规则"></a>限定内存顺序的5个规则</h5><p><code>Ordering</code> 枚举有 5 个成员:</p>
<ul>
<li><strong>Relaxed</strong>， 这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序</li>
<li><strong>Release 释放</strong>，设定内存屏障(Memory barrier)，保证它之前的操作永远在它之前，但是它后面的操作可能被重排到它前面</li>
<li><strong>Acquire 获取</strong>, 设定内存屏障，保证在它之后的访问永远在它之后，但是它之前的操作却有可能被重排到它后面，往往和<code>Release</code>在不同线程中联合使用</li>
<li><strong>AcqRel</strong>, 是 <em>Acquire</em> 和 <em>Release</em> 的结合，同时拥有它们俩提供的保证。比如你要对一个 <code>atomic</code> 自增 1，同时希望该操作之前和之后的读取或写入操作不会被重新排序</li>
<li><strong>SeqCst 顺序一致性</strong>， <code>SeqCst</code>就像是<code>AcqRel</code>的加强版，它不管原子操作是属于读取还是写入的操作，只要某个线程有用到<code>SeqCst</code>的原子操作，线程中该<code>SeqCst</code>操作前的数据操作绝对不会被重新排在该<code>SeqCst</code>操作之后，且该<code>SeqCst</code>操作后的数据操作也绝对不会被重新排在<code>SeqCst</code>操作前。</li>
</ul>
<h5 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicBool, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread::&#123;<span class="keyword">self</span>, JoinHandle&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> DATA: <span class="type">u64</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> READY: AtomicBool = AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">reset</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        DATA = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    READY.<span class="title function_ invoke__">store</span>(<span class="literal">false</span>, Ordering::Relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">producer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            DATA = <span class="number">100</span>; <span class="comment">// A</span></span><br><span class="line">        &#125;</span><br><span class="line">        READY.<span class="title function_ invoke__">store</span>(<span class="literal">true</span>, Ordering::Release); <span class="comment">// B: 内存屏障 ↑</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">consumer</span>() <span class="punctuation">-&gt;</span> JoinHandle&lt;()&gt; &#123;</span><br><span class="line">    thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">while</span> !READY.<span class="title function_ invoke__">load</span>(Ordering::Acquire) &#123;&#125; <span class="comment">// C: 内存屏障 ↓</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(<span class="number">100</span>, <span class="keyword">unsafe</span> &#123; DATA &#125;); <span class="comment">// D</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_producer</span> = <span class="title function_ invoke__">producer</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t_consumer</span> = <span class="title function_ invoke__">consumer</span>();</span><br><span class="line"></span><br><span class="line">        t_producer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        t_consumer.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多线程使用-Atomic"><a href="#多线程使用-Atomic" class="headerlink" title="多线程使用 Atomic"></a>多线程使用 <code>Atomic</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">use</span> std::sync::Arc;</span><br><span class="line"><span class="keyword">use</span> std::&#123;hint, thread&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">spinlock_clone</span> = Arc::<span class="title function_ invoke__">clone</span>(&amp;spinlock);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">thread</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        spinlock_clone.<span class="title function_ invoke__">store</span>(<span class="number">0</span>, Ordering::SeqCst);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待其它线程释放锁</span></span><br><span class="line">    <span class="keyword">while</span> spinlock.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="number">0</span> &#123;</span><br><span class="line">        hint::<span class="title function_ invoke__">spin_loop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(panic) = thread.<span class="title function_ invoke__">join</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-6-基于-Send-和-Sync-的线程安全"><a href="#3-6-6-基于-Send-和-Sync-的线程安全" class="headerlink" title="3.6.6 基于 Send 和 Sync 的线程安全"></a>3.6.6 基于 <code>Send</code> 和 <code>Sync</code> 的线程安全</h3><h4 id="无法用于多线程的-Rc"><a href="#无法用于多线程的-Rc" class="headerlink" title="无法用于多线程的 Rc"></a>无法用于多线程的 <code>Rc</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = Rc::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Rc-和-Arc-源码对比"><a href="#Rc-和-Arc-源码对比" class="headerlink" title="Rc 和 Arc 源码对比"></a><code>Rc</code> 和 <code>Arc</code> 源码对比</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rc源码片段</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !marker::<span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Rc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arc源码片段</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> <span class="title class_">Arc</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Send</code>和<code>Sync</code>是在线程间安全使用一个值的关键。</p>
<h4 id="Send-和-Sync"><a href="#Send-和-Sync" class="headerlink" title="Send 和 Sync"></a><code>Send</code> 和 <code>Sync</code></h4><p><code>Send</code>和<code>Sync</code>它们只是标记特征(marker trait，该特征未定义任何行为), 它们的作用：</p>
<ul>
<li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权</li>
<li>实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li>
</ul>
<h4 id="实现-Send-和-Sync-的类型"><a href="#实现-Send-和-Sync-的类型" class="headerlink" title="实现 Send 和 Sync 的类型"></a>实现 <code>Send</code> 和 <code>Sync</code> 的类型</h4><p>在 Rust 中，几乎所有类型都默认实现了<code>Send</code>和<code>Sync</code>，而且由于这两个特征都是可自动派生的特征(通过<code>derive</code>派生)，意味着一个复合类型(例如结构体), 只要它内部的所有成员都实现了<code>Send</code>或者<code>Sync</code>，那么它就自动实现了<code>Send</code>或<code>Sync</code>。</p>
<p>以下情况除外：</p>
<ul>
<li>裸指针两者都没实现，因为它本身就没有任何安全保证</li>
<li><code>UnsafeCell</code>不是<code>Sync</code>，因此<code>Cell</code>和<code>RefCell</code>也不是</li>
<li><code>Rc</code>两者都没实现(因为内部的引用计数器不是线程安全的)</li>
</ul>
<h4 id="裸指针实现-Send"><a href="#裸指针实现-Send" class="headerlink" title="裸指针实现 Send"></a>裸指针实现 <code>Send</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyBox</span>(*<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="title class_">Send</span> <span class="keyword">for</span> <span class="title class_">MyBox</span> &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = <span class="title function_ invoke__">MyBox</span>(<span class="number">5</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">t</span> = thread::<span class="title function_ invoke__">spawn</span>(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, p);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t.<span class="title function_ invoke__">join</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="裸指针实现-Sync"><a href="#裸指针实现-Sync" class="headerlink" title="裸指针实现 Sync"></a>裸指针实现 <code>Sync</code></h4><p><a target="_blank" rel="noopener" href="https://course.rs/advance/concurrency-with-threads/send-sync.html#%E4%B8%BA%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0sync">https://course.rs/advance/concurrency-with-threads/send-sync.html#%E4%B8%BA%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0sync</a></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ol>
<li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权, 实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li>
<li>绝大部分类型都实现了<code>Send</code>和<code>Sync</code>，常见的未实现的有：裸指针、<code>Cell</code>、<code>RefCell</code>、<code>Rc</code> 等</li>
<li>可以为自定义类型实现<code>Send</code>和<code>Sync</code>，但是需要<code>unsafe</code>代码块</li>
<li>可以为部分 Rust 中的类型实现<code>Send</code>、<code>Sync</code>，但是需要使用<code>newtype</code>，例如文中的裸指针例子</li>
</ol>
<h2 id="3-7-全局变量"><a href="#3-7-全局变量" class="headerlink" title="3.7 全局变量"></a>3.7 全局变量</h2><h3 id="编译期初始化"><a href="#编译期初始化" class="headerlink" title="编译期初始化"></a>编译期初始化</h3><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_ID: <span class="type">usize</span> =  <span class="type">usize</span>::MAX / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;用户ID允许的最大值是&#123;&#125;&quot;</span>,MAX_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常量与普通变量的区别</strong></p>
<ul>
<li>关键字是<code>const</code>而不是<code>let</code></li>
<li>定义常量必须指明类型（如 i32）不能省略</li>
<li>定义常量时变量的命名规则一般是全部大写</li>
<li>常量可以在任意作用域进行定义，其生命周期贯穿整个程序的生命周期。编译时编译器会尽可能将其内联到代码中，所以在不同地方对同一常量的引用并不能保证引用到相同的内存地址</li>
<li>常量的赋值只能是常量表达式/数学表达式，也就是说必须是在编译期就能计算出的值，如果需要在运行时才能得出结果的值比如函数，则不能赋值给常量表达式</li>
<li>对于变量出现重复的定义(绑定)会发生变量遮盖，后面定义的变量会遮住前面定义的变量，常量则不允许出现重复的定义</li>
</ul>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> REQUEST_RECV: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">   <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        REQUEST_RECV += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(REQUEST_RECV, <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust 要求必须使用<code>unsafe</code>语句块才能访问和修改<code>static</code>变量。</p>
<p><strong>静态变量和常量的区别</strong></p>
<ul>
<li>静态变量不会被内联，在整个程序中，静态变量只有一个实例，所有的引用都会指向同一个地址</li>
<li>存储在静态变量中的值必须要实现 Sync trait</li>
</ul>
<h4 id="原子类型"><a href="#原子类型" class="headerlink" title="原子类型"></a>原子类型</h4><p>想要全局计数器、状态控制等功能，又想要线程安全的实现，原子类型是非常好的办法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;</span><br><span class="line"><span class="keyword">static</span> REQUEST_RECV: AtomicUsize  = AtomicUsize::<span class="title function_ invoke__">new</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">100</span> &#123;</span><br><span class="line">        REQUEST_RECV.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::Relaxed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;当前用户请求数&#123;:?&#125;&quot;</span>,REQUEST_RECV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行期初始化"><a href="#运行期初始化" class="headerlink" title="运行期初始化"></a>运行期初始化</h3><p>静态初始化的问题在于：无法利用函数进行静态初始化。</p>
<h4 id="lazy-static"><a href="#lazy-static" class="headerlink" title="lazy_static"></a><code>lazy_static</code></h4><p><code>lazy_static</code>允许我们在运行期初始化静态变量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static;</span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">ref</span> HASHMAP: HashMap&lt;<span class="type">u32</span>, &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">0</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">1</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        m.<span class="title function_ invoke__">insert</span>(<span class="number">2</span>, <span class="string">&quot;baz&quot;</span>);</span><br><span class="line">        m</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 首次访问`HASHMAP`的同时对其进行初始化</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `0` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">0</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续的访问仅仅获取值，再不会进行任何初始化操作</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The entry for `1` is \&quot;&#123;&#125;\&quot;.&quot;</span>, HASHMAP.<span class="title function_ invoke__">get</span>(&amp;<span class="number">1</span>).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Box-leak-1"><a href="#Box-leak-1" class="headerlink" title="Box::leak"></a><code>Box::leak</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        a: <span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        b: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 将`c`从内存中泄漏，变成`&#x27;static`生命周期</span></span><br><span class="line">        CONFIG = <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(c));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="从函数中返回全局变量"><a href="#从函数中返回全局变量" class="headerlink" title="从函数中返回全局变量"></a>从函数中返回全局变量</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">    b: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> CONFIG: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> Config&gt; = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">init</span>() <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Config&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(Config &#123;</span><br><span class="line">        a: <span class="string">&quot;A&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        b: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(<span class="type">Box</span>::<span class="title function_ invoke__">leak</span>(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        CONFIG = <span class="title function_ invoke__">init</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, CONFIG)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="标准库的-OnceCall"><a href="#标准库的-OnceCall" class="headerlink" title="标准库的 OnceCall"></a>标准库的 <code>OnceCall</code></h3><p><code>Rust</code> 标准库中提供 <code>lazy::OnceCell</code> 和 <code>lazy::SyncOnceCell</code> 两种 <code>Cell</code>，前者用于单线程，后者用于多线程，它们用来存储堆上的信息，并且具有最多只能赋值一次的特性。</p>
<h2 id="3-8-错误处理"><a href="#3-8-错误处理" class="headerlink" title="3.8 错误处理"></a>3.8 错误处理</h2><h3 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h3><h4 id="or-amp-and"><a href="#or-amp-and" class="headerlink" title="or() &amp; and()"></a><code>or()</code> &amp; <code>and()</code></h4><ul>
<li><code>or()</code>，表达式按照顺序求值，若任何一个表达式的结果是 <code>Some</code> 或 <code>Ok</code>，则该值会立刻返回</li>
<li><code>and()</code>，若两个表达式的结果都是 <code>Some</code> 或 <code>Ok</code>，则<strong>第二个表达式中的值被返回</strong>。若任何一个的结果是 <code>None</code> 或 <code>Err</code> ，则立刻返回。</li>
</ul>
<h4 id="or-else-amp-and-then"><a href="#or-else-amp-and-then" class="headerlink" title="or_else() &amp; and_then()"></a><code>or_else()</code> &amp; <code>and_then()</code></h4><p>跟 <code>or()</code> 和 <code>and()</code> 类似，唯一的区别在于，它们的第二个表达式是一个闭包。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// or_else with Option</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_some</span> = || <span class="title function_ invoke__">Some</span>(<span class="string">&quot;some2&quot;</span>); <span class="comment">// 类似于: let fn_some = || -&gt; Option&lt;&amp;str&gt; &#123; Some(&quot;some2&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span>: <span class="type">Option</span>&lt;&amp;<span class="type">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_none</span> = || <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">or_else</span>(fn_some), s1);  <span class="comment">// Some1 or_else Some2 = Some1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">or_else</span>(fn_none), s1);  <span class="comment">// Some or_else None = Some</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">or_else</span>(fn_some), s2);   <span class="comment">// None or_else Some = Some</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">or_else</span>(fn_none), <span class="literal">None</span>); <span class="comment">// None1 or_else None2 = None2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// or_else with Result</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o1</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">o2</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_ok</span> = |_| <span class="title function_ invoke__">Ok</span>(<span class="string">&quot;ok2&quot;</span>); <span class="comment">// 类似于: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; &#123; Ok(&quot;ok2&quot;) &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e1</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error1&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e2</span>: <span class="type">Result</span>&lt;&amp;<span class="type">str</span>, &amp;<span class="type">str</span>&gt; = <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error2&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_err</span> = |_| <span class="title function_ invoke__">Err</span>(<span class="string">&quot;error2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(o1.<span class="title function_ invoke__">or_else</span>(fn_ok), o1);  <span class="comment">// Ok1 or_else Ok2 = Ok1</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(o1.<span class="title function_ invoke__">or_else</span>(fn_err), o1); <span class="comment">// Ok or_else Err = Ok</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(e1.<span class="title function_ invoke__">or_else</span>(fn_ok), o2);  <span class="comment">// Err or_else Ok = Ok</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(e1.<span class="title function_ invoke__">or_else</span>(fn_err), e2); <span class="comment">// Err1 or_else Err2 = Err2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><code>filter</code></h4><p><code>filter</code> 用于对 <code>Option</code> 进行过滤：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="title function_ invoke__">Some</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">n</span> = <span class="literal">None</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fn_is_even</span> = |x: &amp;<span class="type">i8</span>| x % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s1.<span class="title function_ invoke__">filter</span>(fn_is_even), n);  <span class="comment">// Some(3) -&gt; 3 is not even -&gt; None</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(s2.<span class="title function_ invoke__">filter</span>(fn_is_even), s2); <span class="comment">// Some(6) -&gt; 6 is even -&gt; Some(6)</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n.<span class="title function_ invoke__">filter</span>(fn_is_even), n);   <span class="comment">// None -&gt; no value -&gt; None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map-amp-map-err"><a href="#map-amp-map-err" class="headerlink" title="map() &amp; map_err()"></a><code>map()</code> &amp; <code>map_err()</code></h4><p><code>map</code> 可以将 <code>Some</code> 或 <code>Ok</code> 中的值映射为另一个，<code>map_err()</code>用来将 <code>Err</code> 中的值进行改变。</p>
<h4 id="map-or-amp-map-or-else"><a href="#map-or-amp-map-or-else" class="headerlink" title="map_or() &amp; map_or_else()"></a><code>map_or()</code> &amp; <code>map_or_else()</code></h4><p><code>map_or</code> 在 <code>map</code> 的基础上提供了一个默认值，<code>map_or_else()</code> 通过一个闭包来提供默认值。</p>
<h4 id="ok-or-amp-ok-or-else"><a href="#ok-or-amp-ok-or-else" class="headerlink" title="ok_or() &amp; ok_or_else()"></a><code>ok_or()</code> &amp; <code>ok_or_else()</code></h4><p>可以将 <code>Option</code> 类型转换为 <code>Result</code> 类型。其中 <code>ok_or</code> 接收一个默认的 <code>Err</code> 参数，而 <code>ok_or_else</code> 接收一个闭包作为 <code>Err</code> 参数。</p>
<h3 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h3><p>自定义类型实现 <code>std::error::Error</code> 特征后，该类型就可以作为 <code>Err</code> 来使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    code: <span class="type">usize</span>,</span><br><span class="line">    message: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据错误码显示不同的错误信息</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">err_msg</span> = <span class="keyword">match</span> <span class="keyword">self</span>.code &#123;</span><br><span class="line">            <span class="number">404</span> =&gt; <span class="string">&quot;Sorry, Can not find the Page!&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="string">&quot;Sorry, something is wrong! Please Try Again!&quot;</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, err_msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(</span><br><span class="line">            f,</span><br><span class="line">            <span class="string">&quot;AppError &#123;&#123; code: &#123;&#125;, message: &#123;&#125; &#125;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.code, <span class="keyword">self</span>.message</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">produce_error</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(AppError &#123;</span><br><span class="line">        code: <span class="number">404</span>,</span><br><span class="line">        message: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Page not found&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="title function_ invoke__">produce_error</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, e), <span class="comment">// 抱歉，未找到指定的页面!</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;No error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="title function_ invoke__">produce_error</span>()); <span class="comment">// Err(AppError &#123; code: 404, message: Page not found &#125;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">eprintln!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, <span class="title function_ invoke__">produce_error</span>());</span><br><span class="line">    <span class="comment">// Err(</span></span><br><span class="line">    <span class="comment">//     AppError &#123; code: 404, message: Page not found &#125;</span></span><br><span class="line">    <span class="comment">// )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错误转换-From-特征"><a href="#错误转换-From-特征" class="headerlink" title="错误转换 From 特征"></a>错误转换 <code>From</code> 特征</h4><p>将其它的错误类型转换成自定义的错误类型：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    kind: <span class="type">String</span>,    <span class="comment">// 错误类型</span></span><br><span class="line">    message: <span class="type">String</span>, <span class="comment">// 错误信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 AppError 实现 std::convert::From 特征，由于 From 包含在 std::prelude 中，因此可以直接简化引入。</span></span><br><span class="line"><span class="comment">// 实现 From&lt;io::Error&gt; 意味着我们可以将 io::Error 错误转换成自定义的 AppError 错误</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;io::Error&gt; <span class="keyword">for</span> <span class="title class_">AppError</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">from</span>(error: io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        AppError &#123;</span><br><span class="line">            kind: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;io&quot;</span>),</span><br><span class="line">            message: error.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), AppError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;nonexistent_file.txt&quot;</span>)?;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Error: AppError &#123; kind: <span class="string">&quot;io&quot;</span>, message: <span class="string">&quot;No such file or directory (os error 2)&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="归一化不同错误类型"><a href="#归一化不同错误类型" class="headerlink" title="归一化不同错误类型"></a>归一化不同错误类型</h3><p>要在一个函数中返回不同的错误，要实现这个目的有三种方式:</p>
<ul>
<li>使用特征对象 <code>Box&lt;dyn Error&gt;</code></li>
<li>自定义错误类型</li>
<li>使用 <code>thiserror</code></li>
</ul>
<h4 id="Box-lt-dyn-Error-gt"><a href="#Box-lt-dyn-Error-gt" class="headerlink" title="Box&lt;dyn Error&gt;"></a><code>Box&lt;dyn Error&gt;</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"><span class="keyword">use</span> std::error::Error;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>Result</code> 实际上不会限制错误的类型，也就是一个类型就算不实现 <code>Error</code> 特征，它依然可以在 <code>Result&lt;T, E&gt;</code> 中作为 <code>E</code> 来使用，此时这种特征对象的解决方案就无能为力了。</p>
<h4 id="自定义错误类型-1"><a href="#自定义错误类型-1" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  EnvironmentVariableNotFound,</span><br><span class="line">  <span class="title function_ invoke__">IOError</span>(std::io::Error),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;std::env::VarError&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">from</span>(_: std::env::VarError) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span>::EnvironmentVariableNotFound</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">From</span>&lt;std::io::Error&gt; <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">from</span>(value: std::io::Error) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">Self</span>::<span class="title function_ invoke__">IOError</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::error::Error <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      MyError::EnvironmentVariableNotFound =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Environment variable not found&quot;</span>),</span><br><span class="line">      MyError::<span class="title function_ invoke__">IOError</span>(err) =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;IO Error: &#123;&#125;&quot;</span>, err.<span class="title function_ invoke__">to_string</span>()),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简化错误处理"><a href="#简化错误处理" class="headerlink" title="简化错误处理"></a>简化错误处理</h3><h4 id="thiserror"><a href="#thiserror" class="headerlink" title="thiserror"></a><code>thiserror</code></h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::read_to_string;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(), MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">html</span> = <span class="title function_ invoke__">render</span>()?;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, html);</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">render</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, MyError&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">file</span> = std::env::<span class="title function_ invoke__">var</span>(<span class="string">&quot;MARKDOWN&quot;</span>)?;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">source</span> = <span class="title function_ invoke__">read_to_string</span>(file)?;</span><br><span class="line">  <span class="title function_ invoke__">Ok</span>(source)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(thiserror::Error, Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyError</span> &#123;</span><br><span class="line">  <span class="meta">#[error(<span class="string">&quot;Environment variable not found&quot;</span>)]</span></span><br><span class="line">  <span class="title function_ invoke__">EnvironmentVariableNotFound</span>(<span class="meta">#[from]</span> std::env::VarError),</span><br><span class="line">  <span class="meta">#[error(transparent)]</span></span><br><span class="line">  <span class="title function_ invoke__">IOError</span>(<span class="meta">#[from]</span> std::io::Error),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-9-Unsafe-Rust"><a href="#3-9-Unsafe-Rust" class="headerlink" title="3.9 Unsafe Rust"></a>3.9 <code>Unsafe Rust</code></h2><h3 id="Unsafe-出现的原因"><a href="#Unsafe-出现的原因" class="headerlink" title="Unsafe 出现的原因"></a><code>Unsafe</code> 出现的原因</h3><ul>
<li>绕过编译器编译检查</li>
<li>特定任务需要</li>
</ul>
<h3 id="Unsafe-的作用"><a href="#Unsafe-的作用" class="headerlink" title="Unsafe 的作用"></a><code>Unsafe</code> 的作用</h3><ul>
<li>解引用裸指针</li>
<li>调用一个 <code>unsafe</code> 或外部的函数</li>
<li>访问或修改一个可变的<a target="_blank" rel="noopener" href="https://course.rs/advance/global-variable.html#静态变量">静态变量</a></li>
<li>实现一个 <code>unsafe</code> 特征</li>
<li>访问 <code>union</code> 中的字段</li>
</ul>
<h3 id="3-9-1-五种作用"><a href="#3-9-1-五种作用" class="headerlink" title="3.9.1 五种作用"></a>3.9.1 五种作用</h3><h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p>我们已经学过三种类似指针的概念：引用、智能指针和裸指针。与前两者不同，裸指针：</p>
<ul>
<li>可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针</li>
<li>并不能保证指向合法的内存</li>
<li>可以是 <code>null</code></li>
<li>没有实现任何自动的回收 (drop)</li>
</ul>
<h5 id="基于引用创建裸指针"><a href="#基于引用创建裸指针" class="headerlink" title="基于引用创建裸指针"></a>基于引用创建裸指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">i32</span>;</span><br></pre></td></tr></table></figure>
<p><strong>创建裸指针是安全的行为，而解引用裸指针才是不安全的行为</strong> :</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">num</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r1</span> = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于内存地址创建裸指针"><a href="#基于内存地址创建裸指针" class="headerlink" title="基于内存地址创建裸指针"></a>基于内存地址创建裸指针</h5><h5 id="使用-解引用"><a href="#使用-解引用" class="headerlink" title="使用 * 解引用"></a>使用 * 解引用</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;a;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, *c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基于智能指针创建裸指针"><a href="#基于智能指针创建裸指针" class="headerlink" title="基于智能指针创建裸指针"></a>基于智能指针创建裸指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>: <span class="type">Box</span>&lt;<span class="type">i32</span>&gt; = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 需要先解引用a</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span>: *<span class="keyword">const</span> <span class="type">i32</span> = &amp;*a;</span><br><span class="line">    <span class="comment">// 使用 into_raw 来创建</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span>: *<span class="keyword">const</span> <span class="type">i32</span> = <span class="type">Box</span>::<span class="title function_ invoke__">into_raw</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="调用-unsafe-函数或方法"><a href="#调用-unsafe-函数或方法" class="headerlink" title="调用 unsafe 函数或方法"></a>调用 <code>unsafe</code> 函数或方法</h4><p>它需要使用 <code>unsafe fn</code> 来进行定义。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dangerous</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">dangerous</span>(); </span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a>FFI</h4><p>可以用来与其它语言进行交互</p>
<h5 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h5><h4 id="实现-unsafe-特征"><a href="#实现-unsafe-特征" class="headerlink" title="实现 unsafe 特征"></a>实现 <code>unsafe</code> 特征</h4><p>通过 <code>unsafe impl</code> 的使用，我们告诉编译器：相应的正确性由我们自己来保证。</p>
<h4 id="访问-union-中的字段"><a href="#访问-union-中的字段" class="headerlink" title="访问 union 中的字段"></a>访问 <code>union</code> 中的字段</h4><p><code>union</code> 所有字段共享一个存储空间</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags">tags</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">3.1 生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E8%AE%A4%E8%AF%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">3.1.1 认识生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%AC%E5%9E%82%E6%8C%87%E9%92%88%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">悬垂指针与生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%A3%80%E6%9F%A5"><span class="toc-number">1.1.2.</span> <span class="toc-text">借用检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">函数中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">生命周期标注语法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">函数签名中的生命周期标注</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%A0%87%E6%B3%A8"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">深入思考生命周期标注</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">结构体中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B6%88%E9%99%A4"><span class="toc-number">1.1.6.</span> <span class="toc-text">生命周期消除</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%9D%A1%E6%B6%88%E9%99%A4%E8%A7%84%E5%88%99"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">三条消除规则</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">方法中的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">静态生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%B7%B1%E5%85%A5%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-TODO"><span class="toc-number">1.2.</span> <span class="toc-text">3.1.2 深入生命周期[TODO]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-amp-%E2%80%99static-%E5%92%8C-T-%E2%80%98static"><span class="toc-number">1.3.</span> <span class="toc-text">3.1.3 &amp;’static 和 T: ‘static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#amp-%E2%80%99static"><span class="toc-number">1.3.1.</span> <span class="toc-text">&amp;’static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T-%E2%80%98static"><span class="toc-number">1.3.2.</span> <span class="toc-text">T: ‘static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-%E5%88%B0%E5%BA%95%E9%92%88%E5%AF%B9%E8%B0%81%EF%BC%9F"><span class="toc-number">1.3.3.</span> <span class="toc-text">static 到底针对谁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%97%AD%E5%8C%85%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">3.2 函数式编程：闭包、迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E9%97%AD%E5%8C%85-Closure"><span class="toc-number">2.1.</span> <span class="toc-text">3.2.1 闭包 Closure</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">使用闭包简化代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">闭包实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">2.1.3.</span> <span class="toc-text">闭包类型推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">2.1.4.</span> <span class="toc-text">结构体中的闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">2.1.5.</span> <span class="toc-text">捕获作用域中的值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%AF%B9%E5%86%85%E5%AD%98%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">闭包对内存的影响</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Fn-%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.6.</span> <span class="toc-text">三种 Fn 特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#move-%E5%92%8C-Fn"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">move 和 Fn</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Fn-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">三种 Fn 的关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.1.7.</span> <span class="toc-text">闭包作为函数返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%BF%AD%E4%BB%A3%E5%99%A8-Iterator"><span class="toc-number">2.2.</span> <span class="toc-text">3.2.2 迭代器 Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#For-%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">For 与迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">惰性初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntoIterator%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">IntoIterator特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#into-iter-iter-iter-mut"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">into_iter, iter, iter_mut</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Iterator-%E5%92%8C-IntoIterator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">Iterator 和 IntoIterator 的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">消费者与适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">消费者适配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">迭代器适配器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%B7%B1%E5%85%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">3.3 深入类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-newtype-%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.1.</span> <span class="toc-text">3.3.1 newtype 和类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newtype"><span class="toc-number">3.1.1.</span> <span class="toc-text">newtype</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E5%A4%96%E9%83%A8%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%A4%96%E9%83%A8%E7%89%B9%E5%BE%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">为外部类型实现外部特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%86%85%E9%83%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.1.3.</span> <span class="toc-text">隐藏内部细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.2.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-Sized-%E5%92%8C%E4%B8%8D%E5%AE%9A%E9%95%BF%E7%B1%BB%E5%9E%8BDST"><span class="toc-number">3.3.</span> <span class="toc-text">3.3.2 Sized 和不定长类型DST</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B-DST"><span class="toc-number">3.3.1.</span> <span class="toc-text">动态大小类型 DST</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Size-%E7%89%B9%E5%BE%81"><span class="toc-number">3.3.2.</span> <span class="toc-text">Size 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-lt-str-gt"><span class="toc-number">3.3.3.</span> <span class="toc-text">Box&lt;str&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Box-%E5%A0%86%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D"><span class="toc-number">3.5.</span> <span class="toc-text">3.4.1 Box 堆对象分配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust-%E4%B8%AD%E7%9A%84%E5%A0%86%E6%A0%88"><span class="toc-number">3.5.1.</span> <span class="toc-text">Rust 中的堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.2.</span> <span class="toc-text">Box 使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Box-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8%E5%A0%86%E4%B8%8A"><span class="toc-number">3.5.2.1.</span> <span class="toc-text">使用 Box 将数据存储在堆上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%A0%88%E4%B8%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.5.2.2.</span> <span class="toc-text">避免栈上数据的拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%8A%A8%E6%80%81%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B%E5%8F%98%E4%B8%BA-Sized-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.3.</span> <span class="toc-text">将动态大小类型变为 Sized 固定大小类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.5.2.4.</span> <span class="toc-text">特征对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-leak"><span class="toc-number">3.5.3.</span> <span class="toc-text">Box::leak</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Deref-%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">3.4.2 Deref 解引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-%E8%8E%B7%E5%8F%96%E5%BC%95%E7%94%A8%E8%83%8C%E5%90%8E%E7%9A%84%E5%80%BC"><span class="toc-number">3.6.1.</span> <span class="toc-text">通过 * 获取引用背后的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">3.6.2.</span> <span class="toc-text">智能指针解引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E5%90%8E%E5%8E%9F%E7%90%86"><span class="toc-number">3.6.3.</span> <span class="toc-text">* 背后原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.4.</span> <span class="toc-text">函数和方法中的隐式 Deref 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E7%9A%84%E9%9A%90%E5%BC%8F-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">连续的隐式 Deref 转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deref-%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="toc-number">3.6.5.</span> <span class="toc-text">Deref 规则总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-Deref-%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.6.6.</span> <span class="toc-text">三种 Deref 转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-Drop-%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">3.7.</span> <span class="toc-text">3.4.3 Drop 释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust-%E4%B8%AD%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6"><span class="toc-number">3.7.1.</span> <span class="toc-text">Rust 中资源回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Drop-%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.7.2.</span> <span class="toc-text">Drop 的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%9B%9E%E6%94%B6"><span class="toc-number">3.7.3.</span> <span class="toc-text">手动回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84-Copy-%E5%92%8C-Drop"><span class="toc-number">3.7.4.</span> <span class="toc-text">互斥的 Copy 和 Drop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-Rc-%E4%B8%8E-Arc-%E5%AE%9E%E7%8E%B0-1vN-%E6%89%80%E6%9C%89%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">3.8.</span> <span class="toc-text">3.4.4 Rc 与 Arc 实现 1vN 所有权机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc-lt-T-gt"><span class="toc-number">3.8.1.</span> <span class="toc-text">Rc&lt;T&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Rc-clone"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">Rc::clone</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">引用计数的变化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8"><span class="toc-number">3.8.1.3.</span> <span class="toc-text">不可变引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.8.1.4.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-Cell-%E5%92%8C-RefCell-%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">3.9.</span> <span class="toc-text">3.4.5 Cell 和 RefCell 内部可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cell"><span class="toc-number">3.9.1.</span> <span class="toc-text">Cell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RefCell"><span class="toc-number">3.9.2.</span> <span class="toc-text">RefCell</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RefCell-%E4%B8%BA%E4%BD%95%E5%AD%98%E5%9C%A8"><span class="toc-number">3.9.2.1.</span> <span class="toc-text">RefCell 为何存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RefCell-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.2.2.</span> <span class="toc-text">RefCell 简单总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E4%B8%8E%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">3.5 循环引用与自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1-Week-%E4%B8%8E%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">3.5.1 Week 与循环引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Week"><span class="toc-number">4.1.1.</span> <span class="toc-text">Week</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">3.5.2 结构体中的自引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BC%95%E7%94%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">自引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Option"><span class="toc-number">4.2.2.</span> <span class="toc-text">使用 Option</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe-%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">Unsafe 实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%A2%AB%E7%A7%BB%E5%8A%A8%E7%9A%84-Pin"><span class="toc-number">4.2.4.</span> <span class="toc-text">无法被移动的 Pin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">3.6 多线程并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">5.1.</span> <span class="toc-text">3.6.1 并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">3.6.2 使用多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">5.2.1.</span> <span class="toc-text">多线程编程的风险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">5.2.3.</span> <span class="toc-text">等待子线程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%AD%E5%8C%85%E4%B8%AD%E4%BD%BF%E7%94%A8-Move"><span class="toc-number">5.2.4.</span> <span class="toc-text">线程闭包中使用 Move</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">5.2.5.</span> <span class="toc-text">线程结束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.2.6.</span> <span class="toc-text">线程屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">5.2.7.</span> <span class="toc-text">线程局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">5.2.8.</span> <span class="toc-text">条件控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%A2%AB%E8%B0%83%E7%94%A8%E4%B8%80%E6%AC%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.9.</span> <span class="toc-text">只被调用一次的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">5.3.</span> <span class="toc-text">3.6.3 线程同步：消息传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%80%9A%E9%81%93"><span class="toc-number">5.3.1.</span> <span class="toc-text">消息通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%91%E5%8D%95%E6%94%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">多发单收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E9%98%BB%E5%A1%9E%E7%9A%84-try-recv-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">不阻塞的 try_recv 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.4.</span> <span class="toc-text">具有所有权的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.5.</span> <span class="toc-text">循环接收数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">5.3.6.</span> <span class="toc-text">多发送者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.3.7.</span> <span class="toc-text">消息顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5-amp-%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.</span> <span class="toc-text">同步 &amp; 异步通道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.1.</span> <span class="toc-text">异步通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E9%81%93"><span class="toc-number">5.3.8.2.</span> <span class="toc-text">同步通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.8.3.</span> <span class="toc-text">消息缓存</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E9%80%9A%E9%81%93"><span class="toc-number">5.3.9.</span> <span class="toc-text">关闭通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.10.</span> <span class="toc-text">传输多种类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%94%81%E3%80%81Condvar%E3%80%81%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">3.6.4 线程同步：锁、Condvar、信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-Mutex"><span class="toc-number">5.4.1.</span> <span class="toc-text">互斥锁 Mutex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-Mutex"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">单线程中使用 Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8-Mutex"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">多线程中使用 Mutex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">内部可变性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">单线程死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">多线程死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-lock"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">try_lock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-RwLock"><span class="toc-number">5.4.3.</span> <span class="toc-text">读写锁 RwLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condvar%EF%BC%89%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">5.4.4.</span> <span class="toc-text">条件变量（Condvar）控制线程同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-Semaphore"><span class="toc-number">5.4.5.</span> <span class="toc-text">信号量 Semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9AAtomic-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.5.</span> <span class="toc-text">3.6.5 线程同步：Atomic 原子操作与内存顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Atomic-%E4%BD%9C%E4%B8%BA%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">5.5.1.</span> <span class="toc-text">使用 Atomic 作为全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.5.2.</span> <span class="toc-text">内存顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E5%86%85%E5%AD%98%E9%A1%BA%E5%BA%8F%E7%9A%845%E4%B8%AA%E8%A7%84%E5%88%99"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">限定内存顺序的5个规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">内存屏障</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-Atomic"><span class="toc-number">5.5.3.</span> <span class="toc-text">多线程使用 Atomic</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6-%E5%9F%BA%E4%BA%8E-Send-%E5%92%8C-Sync-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.6.</span> <span class="toc-text">3.6.6 基于 Send 和 Sync 的线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84-Rc"><span class="toc-number">5.6.1.</span> <span class="toc-text">无法用于多线程的 Rc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc-%E5%92%8C-Arc-%E6%BA%90%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">5.6.2.</span> <span class="toc-text">Rc 和 Arc 源码对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Send-%E5%92%8C-Sync"><span class="toc-number">5.6.3.</span> <span class="toc-text">Send 和 Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Send-%E5%92%8C-Sync-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.6.4.</span> <span class="toc-text">实现 Send 和 Sync 的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0-Send"><span class="toc-number">5.6.5.</span> <span class="toc-text">裸指针实现 Send</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88%E5%AE%9E%E7%8E%B0-Sync"><span class="toc-number">5.6.6.</span> <span class="toc-text">裸指针实现 Sync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">5.6.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">3.7 全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">编译期初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">静态常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.3.</span> <span class="toc-text">原子类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%9F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.2.</span> <span class="toc-text">运行期初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lazy-static"><span class="toc-number">6.2.1.</span> <span class="toc-text">lazy_static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-leak-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">Box::leak</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">从函数中返回全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84-OnceCall"><span class="toc-number">6.3.</span> <span class="toc-text">标准库的 OnceCall</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">3.8 错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%99%A8"><span class="toc-number">7.1.</span> <span class="toc-text">组合器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#or-amp-and"><span class="toc-number">7.1.1.</span> <span class="toc-text">or() &amp; and()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#or-else-amp-and-then"><span class="toc-number">7.1.2.</span> <span class="toc-text">or_else() &amp; and_then()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-number">7.1.3.</span> <span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-amp-map-err"><span class="toc-number">7.1.4.</span> <span class="toc-text">map() &amp; map_err()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-or-amp-map-or-else"><span class="toc-number">7.1.5.</span> <span class="toc-text">map_or() &amp; map_or_else()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ok-or-amp-ok-or-else"><span class="toc-number">7.1.6.</span> <span class="toc-text">ok_or() &amp; ok_or_else()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">自定义错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2-From-%E7%89%B9%E5%BE%81"><span class="toc-number">7.2.1.</span> <span class="toc-text">错误转换 From 特征</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E4%B8%80%E5%8C%96%E4%B8%8D%E5%90%8C%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.</span> <span class="toc-text">归一化不同错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-lt-dyn-Error-gt"><span class="toc-number">7.3.1.</span> <span class="toc-text">Box&lt;dyn Error&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">7.3.2.</span> <span class="toc-text">自定义错误类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">简化错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thiserror"><span class="toc-number">7.4.1.</span> <span class="toc-text">thiserror</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-Unsafe-Rust"><span class="toc-number">8.</span> <span class="toc-text">3.9 Unsafe Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E5%87%BA%E7%8E%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.1.</span> <span class="toc-text">Unsafe 出现的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.2.</span> <span class="toc-text">Unsafe 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-1-%E4%BA%94%E7%A7%8D%E4%BD%9C%E7%94%A8"><span class="toc-number">8.3.</span> <span class="toc-text">3.9.1 五种作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.</span> <span class="toc-text">解引用裸指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%BC%95%E7%94%A8%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">基于引用创建裸指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">基于内存地址创建裸指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E8%A7%A3%E5%BC%95%E7%94%A8"><span class="toc-number">8.3.1.3.</span> <span class="toc-text">使用 * 解引用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-number">8.3.1.4.</span> <span class="toc-text">基于智能指针创建裸指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8-unsafe-%E5%87%BD%E6%95%B0%E6%88%96%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">调用 unsafe 函数或方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FFI"><span class="toc-number">8.3.3.</span> <span class="toc-text">FFI</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABI"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">ABI</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-unsafe-%E7%89%B9%E5%BE%81"><span class="toc-number">8.3.4.</span> <span class="toc-text">实现 unsafe 特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE-union-%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">8.3.5.</span> <span class="toc-text">访问 union 中的字段</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2022/05/4403e2f5fb06.html"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2022/05/4403e2f5fb06.html&text=4.Rust高级进阶"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2022/05/4403e2f5fb06.html&is_video=false&description=4.Rust高级进阶"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=4.Rust高级进阶&body=Check out this article: http://example.com/2022/05/4403e2f5fb06.html"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2022/05/4403e2f5fb06.html&title=4.Rust高级进阶"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2022/05/4403e2f5fb06.html&name=4.Rust高级进阶&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2022/05/4403e2f5fb06.html&t=4.Rust高级进阶"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2025
    Ak1raKay
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags">tags</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->
 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script> 




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script> 
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
